<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie - Service & Installation Clearance Checker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f5f5f5;
        color: #333;
        overflow-x: hidden;
    }

    .container {
        max-width: 100%;
        margin: 0 auto;
        padding: 10px;
    }

    h1 {
        font-size: 24px;
        margin: 20px 0;
        text-align: center;
        color: #2c3e50;
    }

    .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 14px;
        margin-bottom: 20px;
    }

    .step {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .step h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #34495e;
        display: flex;
        align-items: center;
    }

    .step-number {
        background: #3498db;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        font-weight: bold;
    }

    .hidden {
        display: none !important;
    }

    button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        font-weight: 600;
    }

    button:active {
        background: #2980b9;
    }

    button:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }

    button.secondary {
        background: #95a5a6;
    }

    button.danger {
        background: #e74c3c;
    }

    input[type="file"] {
        display: none;
    }

    .file-upload-btn {
        display: block;
        text-align: center;
        padding: 40px;
        border: 2px dashed #3498db;
        border-radius: 8px;
        cursor: pointer;
        background: #ecf0f1;
    }

    .file-upload-btn:hover {
        background: #d5dbdb;
    }

    #photoCanvas,
    #photoCanvas2,
    #photoCanvas3,
    #photoCanvas4 {
        width: 100%;
        max-width: 100%;
        border: 2px solid #3498db;
        border-radius: 8px;
        margin: 10px 0;
        display: block;
        touch-action: none;
    }

    .input-group {
        margin: 15px 0;
    }

    .input-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #555;
    }

    .input-group input,
    .input-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
    }

    .instructions {
        background: #e8f4f8;
        padding: 12px;
        border-radius: 6px;
        margin: 10px 0;
        font-size: 14px;
        line-height: 1.5;
    }

    .equipment-type-selector {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
    }

    .equipment-type-btn {
        padding: 40px 20px;
        border: 3px solid #ddd;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s;
    }

    .equipment-type-btn:hover {
        border-color: #3498db;
    }

    .equipment-type-btn.active {
        border-color: #3498db;
        background: #e8f4f8;
    }

    .equipment-type-btn .icon {
        font-size: 40px;
        margin-bottom: 10px;
    }

    .equipment-type-btn .label {
        font-weight: 600;
        color: #2c3e50;
    }

    .obstacle-list {
        margin: 15px 0;
    }

    .obstacle-item {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 6px;
        margin: 8px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .obstacle-item button {
        width: auto;
        padding: 6px 12px;
        margin: 0;
        font-size: 14px;
    }

    .compliance-result {
        padding: 20px;
        border-radius: 8px;
        margin: 15px 0;
        font-weight: 600;
        text-align: center;
    }

    .compliance-pass {
        background: #d4edda;
        color: #155724;
        border: 2px solid #c3e6cb;
    }

    .compliance-fail {
        background: #f8d7da;
        color: #721c24;
        border: 2px solid #f5c6cb;
    }

    .violation-list {
        list-style: none;
        margin-top: 10px;
        text-align: left;
    }

    .violation-list li {
        padding: 8px;
        margin: 5px 0;
        background: rgba(255,255,255,0.5);
        border-radius: 4px;
    }

    .legend {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        flex-wrap: wrap;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin: 5px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 8px;
    }

    .info-box {
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 6px;
        padding: 12px;
        margin: 10px 0;
        font-size: 14px;
    }

    .info-box strong {
        color: #856404;
    }

    @media (max-width: 600px) {
        .container {
            padding: 5px;
        }
        
        h1 {
            font-size: 20px;
            margin: 10px 0;
        }
        
        .step {
            padding: 15px;
            margin: 10px 0;
        }

        .equipment-type-selector {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>
        <div class="subtitle">Service & Installation Clearance Checker</div>

```
    <!-- Step 0: Select Equipment Type -->
    <div class="step" id="step0">
        <h2><span class="step-number">0</span> Select Equipment Type</h2>
        <div class="equipment-type-selector">
            <div class="equipment-type-btn" onclick="selectEquipmentType('flue')">
                <div class="icon">üå¨Ô∏è</div>
                <div class="label">Flue Terminal</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('boiler')">
                <div class="icon">üî•</div>
                <div class="label">Boiler</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('radiator')">
                <div class="icon">‚ô®Ô∏è</div>
                <div class="label">Radiator</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('cylinder')">
                <div class="icon">üõ¢Ô∏è</div>
                <div class="label">Cylinder</div>
            </div>
        </div>
        <div class="info-box" id="equipmentInfo">
            Select the type of equipment you're checking clearances for.
        </div>
    </div>

    <!-- Step 1: Upload Photo -->
    <div class="step hidden" id="step1">
        <h2><span class="step-number">1</span> Add Photo</h2>
        <div class="instructions">
            Choose how you want to add a photo:
        </div>
        <label for="photoCameraInput" class="file-upload-btn" style="margin-bottom: 10px;">
            üì∏ Take Photo with Camera
        </label>
        <input type="file" id="photoCameraInput" accept="image/*" capture="environment">
        <label for="photoUploadInput" class="file-upload-btn">
            üìÅ Upload Existing Photo
        </label>
        <input type="file" id="photoUploadInput" accept="image/*">
    </div>

    <!-- Step 2: Set Scale -->
    <div class="step hidden" id="step2">
        <h2><span class="step-number">2</span> Set Scale</h2>

        <!-- AI Detection Section -->
        <div class="instructions">
            <strong>ü§ñ Option 1: Automatic Detection (Recommended)</strong><br>
            Include a reference object in your photo:
            <ul style="margin: 5px 0 5px 20px;">
                <li><strong>Credit card</strong> (85.6mm √ó 54mm) - Best accuracy</li>
                <li><strong>Standard UK brick</strong> (215mm √ó 102.5mm) - Good for outdoor photos</li>
            </ul>
            Click the button below to let AI find and calibrate automatically.
        </div>
        <div class="instructions" style="background: #e3f2fd; border-left: 4px solid #2196f3;">
            üí° <strong>For best results:</strong> Ensure the object is fully visible, well-lit, flat, and not tilted.
        </div>
        <button id="autoDetectBtn" style="margin-bottom: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            ü§ñ Auto-Detect Calibration Object (AI)
        </button>
        <div id="autoDetectStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Manual Calibration Section -->
        <div class="instructions" style="background: #fff9e6; border-left: 4px solid #ff9800; margin-top: 20px;">
            <strong>üìè Option 2: Manual Calibration</strong><br>
            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px; font-family: monospace; text-align: center;">
                <strong>Example: Measuring credit card width</strong><br>
                <div style="margin: 10px 0; font-size: 18px;">
                    üìç<span style="color: #2e7d32;">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>üìç<br>
                    <span style="font-size: 12px;">üëÜ Point 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85mm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point 2 üëÜ</span>
                </div>
            </div>
            <strong style="color: #e65100;">Step 1:</strong> Move mouse/finger over the photo to see magnifying glass<br>
            <strong style="color: #e65100;">Step 2:</strong> Click the üìç button in the center of the magnifying glass to mark TWO points<br>
            <strong style="color: #e65100;">Step 3:</strong> Enter the distance between those points (85mm for card width)<br>
            <span style="font-size: 0.9em;">üí≥ Standard credit card: <strong>Width = 85mm</strong> | Height = 54mm</span>
        </div>
        <div id="manualCalibrationGuide" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 14px; display: none;">
            <strong>üìå Point 1:</strong> <span id="point1Status" style="color: #e74c3c;">Not set - Click the üìç button in magnifying glass</span>
            <button id="undoPoint1Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(1)">‚Ü∂ Undo</button><br>
            <strong>üìå Point 2:</strong> <span id="point2Status" style="color: #95a5a6;">Waiting for Point 1...</span>
            <button id="undoPoint2Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(2)">‚Ü∂ Undo</button>
            <br>
            <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px;">
                üîç <strong>Magnifying glass active</strong> - Move your mouse/finger over the photo to position the magnifying glass, then release. The magnifier stays visible so you can adjust the zoom slider and click the üìç button to mark the exact position.
            </div>
        </div>
        <div style="position: relative; margin: 10px 0;">
            <canvas id="photoCanvas"></canvas>
            <!-- Magnifying Glass -->
            <div id="magnifyingGlass" style="display: none; position: absolute; width: 150px; height: 150px; border: 3px solid #3498db; border-radius: 50%; pointer-events: none; box-shadow: 0 0 15px rgba(0,0,0,0.5); overflow: visible; z-index: 1000; background: white;">
                <canvas id="magnifyCanvas" width="150" height="150"></canvas>
                <div style="position: absolute; top: 50%; left: 50%; width: 2px; height: 20px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <div style="position: absolute; top: 50%; left: 50%; width: 20px; height: 2px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <!-- Center button for marking positions -->
                <button id="markPositionBtn" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; border-radius: 50%; background: rgba(52, 152, 219, 0.8); border: 2px solid white; color: white; font-size: 20px; cursor: pointer; pointer-events: auto; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; padding: 0; font-weight: bold; z-index: 1001;">üìç</button>
            </div>
            <!-- Zoom Slider -->
            <div id="zoomSliderContainer" style="display: none; position: absolute; background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 999; pointer-events: auto;">
                <label style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 5px; color: #333;">Zoom Level</label>
                <input type="range" id="zoomSlider" min="2" max="8" step="0.5" value="3" style="width: 150px; cursor: pointer;">
                <div style="text-align: center; font-size: 12px; color: #666; margin-top: 3px;"><span id="zoomValue">3</span>x</div>
            </div>
        </div>
        <div class="input-group">
            <label for="knownDistance"><strong>Distance between the two points you tapped:</strong></label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="number" id="knownDistance" placeholder="85" value="85" min="1" style="flex: 1;">
                <span style="font-weight: bold; color: #666;">millimeters (mm)</span>
            </div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                Examples: Credit card width = 85mm, Height = 54mm, Phone width ‚âà 70-80mm
            </div>
        </div>
        <button id="confirmScaleBtn" disabled>‚úì Confirm Scale</button>
        <button class="secondary" id="resetScaleBtn">‚Üª Reset Points & Try Again</button>
    </div>

    <!-- Step 3: Mark Equipment -->
    <div class="step hidden" id="step3">
        <h2><span class="step-number">3</span> Mark <span id="equipmentLabel">Equipment</span> Position</h2>
        <div class="instructions">
            <strong>üìç Find your <span id="equipmentLabel2" style="color: #e74c3c; font-size: 1.1em;">Equipment</span> in the photo below</strong>
        </div>
        <div class="instructions" id="step3Instructions" style="background: #fff3cd; border-left: 4px solid #ffc107;">
            Tap the center of the equipment on the photo.
        </div>
        <canvas id="photoCanvas2"></canvas>
        <button id="confirmEquipmentBtn" disabled>Confirm Position</button>
    </div>

    <!-- Step 4: Mark Obstacles -->
    <div class="step hidden" id="step4">
        <h2><span class="step-number">4</span> Mark Clearance Obstacles</h2>
        <div class="instructions" id="step4Instructions">
            Draw rectangles around walls, windows, doors, and other obstacles.
        </div>
        <canvas id="photoCanvas3"></canvas>
        <div class="input-group">
            <label for="obstacleType">Obstacle Type:</label>
            <select id="obstacleType">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <div class="obstacle-list" id="obstacleList"></div>
        <button id="nextToRulesBtn">Continue to Clearance Check</button>
    </div>

    <!-- Step 5: Select Brand & Generate -->
    <div class="step hidden" id="step5">
        <h2><span class="step-number">5</span> Select Manufacturer & Check</h2>
        <div class="input-group" id="brandSelectGroup">
            <label for="brand">Manufacturer:</label>
            <select id="brand">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <button id="generateBtn">Generate Clearance Overlay</button>
    </div>

    <!-- Step 6: Results -->
    <div class="step hidden" id="step6">
        <h2><span class="step-number">6</span> Results</h2>
        <canvas id="photoCanvas4"></canvas>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,0,0,0.3);"></div>
                <span>Prohibited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,165,0,0.3);"></div>
                <span>Warning</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0,255,0,0.3);"></div>
                <span>Service Access</span>
            </div>
        </div>
        
        <div id="complianceResult"></div>
        
        <button id="downloadBtn">Download Annotated Photo</button>
        <button class="secondary" id="startOverBtn">Start Over</button>
    </div>
</div>

<script>
    // Application state
    const state = {
        equipmentType: null,
        photo: null,
        photoWidth: 0,
        photoHeight: 0,
        scale: {
            point1: null,
            point2: null,
            distanceMM: 85,
            pixelsPerMM: 0
        },
        equipment: null,
        obstacles: [],
        brand: null,
        currentObstacleStart: null,
        currentMagnifierPosition: null
    };

    // Equipment type configurations
    const EQUIPMENT_INFO = {
        flue: {
            name: "Flue Terminal",
            icon: "üå¨Ô∏è",
            description: "Check clearances around boiler flue terminals to windows, doors, vents, and building features.",
            markingInstruction: "Tap the center of the flue terminal.",
            obstacles: ['opening_window', 'non_opening_window', 'vent', 'door', 'corner', 'ground']
        },
        boiler: {
            name: "Boiler",
            icon: "üî•",
            description: "Check service clearances around the boiler for maintenance access and ventilation.",
            markingInstruction: "Tap the center of the boiler.",
            obstacles: ['wall', 'ceiling', 'floor', 'corner', 'door', 'window']
        },
        radiator: {
            name: "Radiator",
            icon: "‚ô®Ô∏è",
            description: "Check clearances around radiators for air circulation, curtains, and furniture.",
            markingInstruction: "Tap the center of the radiator.",
            obstacles: ['wall', 'floor', 'window', 'curtain_rail', 'furniture', 'socket']
        },
        cylinder: {
            name: "Cylinder",
            icon: "üõ¢Ô∏è",
            description: "Check service clearances around hot water cylinders for maintenance and safety valve access.",
            markingInstruction: "Tap the center of the cylinder.",
            obstacles: ['wall', 'ceiling', 'floor', 'door', 'corner']
        }
    };

    // Comprehensive clearance rules database
    const CLEARANCE_RULES = {
        // FLUE RULES
        flue: {
            worcester_bosch: {
                name: "Worcester Bosch",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ground', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            },
            vaillant: {
                name: "Vaillant",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            },
            ideal: {
                name: "Ideal",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // BOILER RULES
        boiler: {
            worcester_bosch: {
                name: "Worcester Bosch",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 500 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            },
            vaillant: {
                name: "Vaillant",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            },
            ideal: {
                name: "Ideal",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // RADIATOR RULES
        radiator: {
            general: {
                name: "General Standards",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'circulation', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'window', clearances: { above: 50, below: 0, sides: 50 }, zone_type: 'recommended', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'curtain_rail', clearances: { above: 100, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'furniture', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                    { obstacle_type: 'socket', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'safety', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // CYLINDER RULES
        cylinder: {
            general: {
                name: "General Standards",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'ceiling', clearances: { above: 450, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 400 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'corner', clearances: { above: 450, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            }
        }
    };

    // Obstacle type labels
    const OBSTACLE_LABELS = {
        opening_window: "Opening Window",
        non_opening_window: "Non-Opening Window",
        vent: "Vent / Air Brick",
        door: "Door",
        corner: "Building Corner",
        ground: "Ground Level",
        wall: "Wall",
        ceiling: "Ceiling",
        floor: "Floor",
        window: "Window",
        curtain_rail: "Curtain Rail",
        furniture: "Furniture",
        socket: "Electrical Socket"
    };

    // Step 0: Equipment Type Selection
    window.selectEquipmentType = function(type) {
        state.equipmentType = type;
        
        // Update active button
        document.querySelectorAll('.equipment-type-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.closest('.equipment-type-btn').classList.add('active');
        
        // Update info box
        const info = EQUIPMENT_INFO[type];
        document.getElementById('equipmentInfo').innerHTML = `
            <strong>${info.icon} ${info.name}:</strong> ${info.description}
        `;
        
        // Show next step button
        setTimeout(() => {
            document.getElementById('step0').classList.add('hidden');
            document.getElementById('step1').classList.remove('hidden');
        }, 500);
    };

    // Utility: Get canvas coordinates from touch/click event
    function getCanvasCoordinates(canvas, event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // Step 1: Photo Upload (handles both camera and file upload)
    function handlePhotoUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                state.photo = img;
                state.photoWidth = img.width;
                state.photoHeight = img.height;

                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
                setupScaleCanvas();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('photoCameraInput').addEventListener('change', handlePhotoUpload);
    document.getElementById('photoUploadInput').addEventListener('change', handlePhotoUpload);

    // Step 2: Scale Calibration
    function setupScaleCanvas() {
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        drawPhotoAndPoints(ctx);

        // Add magnifying glass on hover/touch (no click handlers - only button marks positions)
        canvas.addEventListener('mousemove', handleMagnifyMove);
        canvas.addEventListener('mouseenter', showMagnifier);
        canvas.addEventListener('mouseleave', hideMagnifier);
        canvas.addEventListener('touchmove', handleMagnifyTouch);
        canvas.addEventListener('touchstart', showMagnifierTouch);
        // Note: No touchend handler - magnifier stays visible for button click

        // Add button click handler for marking positions
        document.getElementById('markPositionBtn').addEventListener('click', handleMarkPositionClick);

        // Add zoom slider handler
        const zoomSlider = document.getElementById('zoomSlider');
        zoomSlider.addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = e.target.value;
        });
    }

    function showMagnifier() {
        document.getElementById('magnifyingGlass').style.display = 'block';
        document.getElementById('zoomSliderContainer').style.display = 'block';
    }

    function hideMagnifier() {
        document.getElementById('magnifyingGlass').style.display = 'none';
        document.getElementById('zoomSliderContainer').style.display = 'none';
    }

    function showMagnifierTouch(e) {
        // Don't prevent default here - let touchmove handle it
        showMagnifier();
    }

    function handleMagnifyMove(e) {
        const canvas = document.getElementById('photoCanvas');
        const magnifier = document.getElementById('magnifyingGlass');
        const magnifyCanvas = document.getElementById('magnifyCanvas');
        const magnifyCtx = magnifyCanvas.getContext('2d');
        const zoomSliderContainer = document.getElementById('zoomSliderContainer');

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Position magnifier near cursor (offset to avoid blocking view)
        const magnifierLeft = e.clientX - rect.left + 20;
        const magnifierTop = e.clientY - rect.top - 80;
        magnifier.style.left = magnifierLeft + 'px';
        magnifier.style.top = magnifierTop + 'px';

        // Position zoom slider below magnifier
        zoomSliderContainer.style.left = magnifierLeft + 'px';
        zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

        // Get canvas coordinates
        const canvasX = (x * canvas.width) / rect.width;
        const canvasY = (y * canvas.height) / rect.height;

        // Store current canvas position for button click handler
        state.currentMagnifierPosition = { canvasX, canvasY };

        // Draw magnified portion (use zoom slider value)
        const zoom = parseFloat(document.getElementById('zoomSlider').value);
        const magRadius = 75; // Half of magnifier size
        const sourceSize = magRadius / zoom;

        magnifyCtx.clearRect(0, 0, 150, 150);
        magnifyCtx.drawImage(
            state.photo,
            Math.max(0, canvasX - sourceSize),
            Math.max(0, canvasY - sourceSize),
            sourceSize * 2,
            sourceSize * 2,
            0, 0, 150, 150
        );
    }

    function handleMagnifyTouch(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            const canvas = document.getElementById('photoCanvas');
            const magnifier = document.getElementById('magnifyingGlass');
            const magnifyCanvas = document.getElementById('magnifyCanvas');
            const magnifyCtx = magnifyCanvas.getContext('2d');
            const zoomSliderContainer = document.getElementById('zoomSliderContainer');

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Show magnifier
            magnifier.style.display = 'block';
            zoomSliderContainer.style.display = 'block';

            // Position magnifier above touch point
            const magnifierLeft = touch.clientX - rect.left + 20;
            const magnifierTop = touch.clientY - rect.top - 180;
            magnifier.style.left = magnifierLeft + 'px';
            magnifier.style.top = magnifierTop + 'px';

            // Position zoom slider below magnifier (but above touch point)
            zoomSliderContainer.style.left = magnifierLeft + 'px';
            zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

            // Get canvas coordinates
            const canvasX = (x * canvas.width) / rect.width;
            const canvasY = (y * canvas.height) / rect.height;

            // Store current canvas position for button click handler
            state.currentMagnifierPosition = { canvasX, canvasY };

            // Draw magnified portion (use zoom slider value)
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            const magRadius = 75;
            const sourceSize = magRadius / zoom;

            magnifyCtx.clearRect(0, 0, 150, 150);
            magnifyCtx.drawImage(
                state.photo,
                Math.max(0, canvasX - sourceSize),
                Math.max(0, canvasY - sourceSize),
                sourceSize * 2,
                sourceSize * 2,
                0, 0, 150, 150
            );
        }
    }

    // Mark position button click handler (triggered when user clicks the center button)
    function handleMarkPositionClick(e) {
        e.stopPropagation(); // Prevent event bubbling

        if (!state.currentMagnifierPosition) {
            return; // No position stored yet
        }

        const coords = {
            x: state.currentMagnifierPosition.canvasX,
            y: state.currentMagnifierPosition.canvasY
        };

        handleScalePoint(coords);

        // Keep magnifier visible for marking the second point
        // User can reposition by touching/moving on the canvas again
    }

    function handleScalePoint(coords) {
        // Show the manual calibration guide when user starts clicking button
        const guide = document.getElementById('manualCalibrationGuide');
        guide.style.display = 'block';

        if (!state.scale.point1) {
            state.scale.point1 = coords;
            // Update status
            document.getElementById('point1Status').textContent = '‚úì Set';
            document.getElementById('point1Status').style.color = '#2e7d32';
            document.getElementById('undoPoint1Btn').style.display = 'inline-block';
            document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
            document.getElementById('point2Status').style.color = '#e74c3c';
        } else if (!state.scale.point2) {
            state.scale.point2 = coords;
            document.getElementById('confirmScaleBtn').disabled = false;
            // Update status
            document.getElementById('point2Status').textContent = '‚úì Set';
            document.getElementById('point2Status').style.color = '#2e7d32';
            document.getElementById('undoPoint2Btn').style.display = 'inline-block';
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    // Undo point function
    function undoPoint(pointNumber) {
        if (pointNumber === 1) {
            state.scale.point1 = null;
            state.scale.point2 = null; // Also reset point 2 if undoing point 1
            document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
            document.getElementById('point1Status').style.color = '#e74c3c';
            document.getElementById('undoPoint1Btn').style.display = 'none';
            document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
            document.getElementById('point2Status').style.color = '#95a5a6';
            document.getElementById('undoPoint2Btn').style.display = 'none';
            document.getElementById('confirmScaleBtn').disabled = true;
        } else if (pointNumber === 2) {
            state.scale.point2 = null;
            document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
            document.getElementById('point2Status').style.color = '#e74c3c';
            document.getElementById('undoPoint2Btn').style.display = 'none';
            document.getElementById('confirmScaleBtn').disabled = true;
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    function drawPhotoAndPoints(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);
        
        if (state.scale.point1) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(state.scale.point1.x, state.scale.point1.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        if (state.scale.point2) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(state.scale.point2.x, state.scale.point2.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(state.scale.point1.x, state.scale.point1.y);
            ctx.lineTo(state.scale.point2.x, state.scale.point2.y);
            ctx.stroke();
        }
    }

    document.getElementById('resetScaleBtn').addEventListener('click', () => {
        state.scale.point1 = null;
        state.scale.point2 = null;
        document.getElementById('confirmScaleBtn').disabled = true;

        // Hide magnifier when resetting
        hideMagnifier();

        // Reset the guide status
        document.getElementById('manualCalibrationGuide').style.display = 'none';
        document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
        document.getElementById('point1Status').style.color = '#e74c3c';
        document.getElementById('undoPoint1Btn').style.display = 'none';
        document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
        document.getElementById('point2Status').style.color = '#95a5a6';
        document.getElementById('undoPoint2Btn').style.display = 'none';

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    });

    // Auto-Detect Credit Card using AI
    document.getElementById('autoDetectBtn').addEventListener('click', async () => {
        const statusDiv = document.getElementById('autoDetectStatus');
        const btn = document.getElementById('autoDetectBtn');

        // Show loading status
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Detecting credit card with AI...';
        btn.disabled = true;

        try {
            // Convert image to base64
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = state.photoWidth;
            canvas.height = state.photoHeight;
            ctx.drawImage(state.photo, 0, 0);
            const imageBase64 = canvas.toDataURL('image/jpeg', 0.8);

            // Call AI Worker (use minimal object detection to save API costs)
            let response;
            try {
                response = await fetch('https://clearance.martinbibb.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: imageBase64,
                        equipmentType: state.equipmentType,
                        detectObjects: [] // Empty array - we only need card detection
                    }),
                    signal: AbortSignal.timeout(30000) // 30 second timeout
                });
            } catch (fetchError) {
                // Network error or timeout
                if (fetchError.name === 'TimeoutError') {
                    throw new Error('Request timed out after 30 seconds. The image may be too large or the service is slow. Try a smaller image.');
                } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('Load failed')) {
                    throw new Error('Cannot connect to AI service. Check your internet connection or the service may be temporarily unavailable.');
                }
                throw new Error(`Network error: ${fetchError.message}`);
            }

            if (!response.ok) {
                let errorMessage = `API returned error status ${response.status}`;
                try {
                    const errorData = await response.json();
                    if (errorData.error) {
                        errorMessage = errorData.error;
                    }
                } catch (e) {
                    // Could not parse error response
                }
                throw new Error(errorMessage);
            }

            const result = await response.json();

            // Check what was detected (priority: card > brick > nothing)
            if (result.calibration && result.calibration.creditCardDetected) {
                // CREDIT CARD DETECTED
                const cardBounds = result.calibration.creditCardBounds.bounds;

                // Scale factor: API returns coordinates based on 1000x1000 reference
                const scaleX = state.photoWidth / 1000;
                const scaleY = state.photoHeight / 1000;

                // Scale card bounds to actual image dimensions
                const cardWidthPx = cardBounds.width * scaleX;
                const cardHeightPx = cardBounds.height * scaleY;

                // Determine which dimension is width (should be larger for credit card)
                const actualCardWidthPx = Math.max(cardWidthPx, cardHeightPx);

                // Calculate pixels per mm based on 85mm credit card width
                state.scale.pixelsPerMM = actualCardWidthPx / 85;
                state.scale.distanceMM = 85; // Credit card width

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>Credit card detected!</strong><br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.creditCardBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: 85mm credit card width`;

                // Auto-advance to next step after 1.5 seconds
                setTimeout(() => {
                    // Hide magnifier when moving to next step
                    hideMagnifier();

                    document.getElementById('step2').classList.add('hidden');
                    document.getElementById('step3').classList.remove('hidden');

                    // Update step 3 labels
                    const info = EQUIPMENT_INFO[state.equipmentType];
                    document.getElementById('equipmentLabel').textContent = info.name;
                    document.getElementById('equipmentLabel2').textContent = info.name;
                    document.getElementById('step3Instructions').textContent = info.markingInstruction;

                    setupEquipmentCanvas();
                }, 1500);

            } else if (result.calibration && result.calibration.brickDetected) {
                // BRICK DETECTED (FALLBACK)
                const brickBounds = result.calibration.brickBounds.bounds;
                const orientation = result.calibration.brickBounds.orientation;

                // Scale factor: API returns coordinates based on 1000x1000 reference
                const scaleX = state.photoWidth / 1000;
                const scaleY = state.photoHeight / 1000;

                // Scale brick bounds to actual image dimensions
                const brickWidthPx = brickBounds.width * scaleX;
                const brickHeightPx = brickBounds.height * scaleY;

                // Standard UK brick: 215mm x 102.5mm x 65mm
                // Use the appropriate dimension based on orientation
                let referenceMM;
                let actualSizePx;
                let brickDimension;

                if (orientation === 'horizontal') {
                    // Width should be ~215mm
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 215;
                    brickDimension = 'length (215mm)';
                } else {
                    // Height/width might be 102.5mm or 65mm
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 102.5;
                    brickDimension = 'width (102.5mm)';
                }

                // Calculate pixels per mm based on brick
                state.scale.pixelsPerMM = actualSizePx / referenceMM;
                state.scale.distanceMM = referenceMM;

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>Brick detected!</strong> (No card found - using brick as reference)<br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.brickBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: Standard UK brick ${brickDimension}`;

                // Auto-advance to next step after 2 seconds (give user time to read)
                setTimeout(() => {
                    // Hide magnifier when moving to next step
                    hideMagnifier();

                    document.getElementById('step2').classList.add('hidden');
                    document.getElementById('step3').classList.remove('hidden');

                    // Update step 3 labels
                    const info = EQUIPMENT_INFO[state.equipmentType];
                    document.getElementById('equipmentLabel').textContent = info.name;
                    document.getElementById('equipmentLabel2').textContent = info.name;
                    document.getElementById('step3Instructions').textContent = info.markingInstruction;

                    setupEquipmentCanvas();
                }, 2000);

            } else {
                // NOTHING DETECTED - clear message about what AI tried
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.innerHTML = '‚ö†Ô∏è <strong>AI Detection: No calibration objects found</strong><br>' +
                    '<small>Searched for: Credit card, Standard bricks</small><br><br>' +
                    '<strong>üí° To improve detection:</strong><br>' +
                    '‚Ä¢ Include a credit card (85mm wide) OR standard brick in your photo<br>' +
                    '‚Ä¢ Ensure good lighting without glare or shadows<br>' +
                    '‚Ä¢ Object should be fully visible and flat<br>' +
                    '‚Ä¢ Avoid tilted or partially visible objects<br><br>' +
                    '<strong>üìè Or use Manual Calibration below:</strong><br>' +
                    '1. <strong>Tap two points</strong> on any known object (card, brick, ruler, etc.)<br>' +
                    '2. <strong>Enter the distance</strong> between those points in mm<br>' +
                    '   ‚Ä¢ Credit card width = <strong>85mm</strong><br>' +
                    '   ‚Ä¢ Standard brick length = <strong>215mm</strong><br>' +
                    '3. Click <strong>"Confirm Scale"</strong>';
                btn.disabled = false;

                // Show the manual calibration guide
                setTimeout(() => {
                    const canvas = document.getElementById('photoCanvas');
                    canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 500);
            }

        } catch (error) {
            console.error('Auto-detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';

            // Provide specific guidance based on error type
            let guidance = '';
            if (error.message.includes('connect') || error.message.includes('unavailable')) {
                guidance = `<strong>üîå Connection Issue</strong><br>` +
                    `‚Ä¢ Check your internet connection<br>` +
                    `‚Ä¢ The AI service may be temporarily down<br>` +
                    `‚Ä¢ Try refreshing the page and uploading again<br><br>`;
            } else if (error.message.includes('timeout') || error.message.includes('too large')) {
                guidance = `<strong>‚è±Ô∏è Timeout or Large Image</strong><br>` +
                    `‚Ä¢ Try taking a photo at lower resolution<br>` +
                    `‚Ä¢ Compress the image before uploading<br>` +
                    `‚Ä¢ Ensure your internet connection is stable<br><br>`;
            } else if (error.message.includes('API key') || error.message.includes('401') || error.message.includes('403')) {
                guidance = `<strong>üîë Service Configuration Issue</strong><br>` +
                    `‚Ä¢ The AI service may not be properly configured<br>` +
                    `‚Ä¢ Contact support if this persists<br><br>`;
            } else {
                guidance = `<strong>‚ö†Ô∏è Unexpected Error</strong><br>` +
                    `Technical details: ${error.message}<br><br>`;
            }

            statusDiv.innerHTML = `‚ùå <strong>AI Detection Failed</strong><br><br>` +
                guidance +
                `üìù <strong>Solution: Use Manual Calibration below</strong><br>` +
                `1. <strong>Tap two points</strong> on a credit card (85mm) or brick (215mm)<br>` +
                `2. <strong>Enter the distance</strong> in the field below<br>` +
                `3. <strong>Click "Confirm Scale"</strong> to continue`;
            btn.disabled = false;
        }
    });

    document.getElementById('confirmScaleBtn').addEventListener('click', () => {
        const distanceMM = parseFloat(document.getElementById('knownDistance').value);
        if (!distanceMM || distanceMM <= 0) {
            alert('Please enter a valid distance');
            return;
        }

        const pixelDistance = Math.sqrt(
            Math.pow(state.scale.point2.x - state.scale.point1.x, 2) +
            Math.pow(state.scale.point2.y - state.scale.point1.y, 2)
        );

        state.scale.distanceMM = distanceMM;
        state.scale.pixelsPerMM = pixelDistance / distanceMM;

        // Hide magnifier when moving to next step
        hideMagnifier();

        document.getElementById('step2').classList.add('hidden');
        document.getElementById('step3').classList.remove('hidden');

        // Update step 3 labels
        const info = EQUIPMENT_INFO[state.equipmentType];
        document.getElementById('equipmentLabel').textContent = info.name;
        document.getElementById('equipmentLabel2').textContent = info.name;
        document.getElementById('step3Instructions').textContent = info.markingInstruction;

        setupEquipmentCanvas();
    });

    // Step 3: Mark Equipment
    function setupEquipmentCanvas() {
        const canvas = document.getElementById('photoCanvas2');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        drawPhotoWithEquipment(ctx);
        
        canvas.addEventListener('click', handleEquipmentClick);
        canvas.addEventListener('touchstart', handleEquipmentTouchStart);
    }

    function handleEquipmentClick(e) {
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = coords;
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function handleEquipmentTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = coords;
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function drawPhotoWithEquipment(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);
        
        if (state.equipment) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

    document.getElementById('confirmEquipmentBtn').addEventListener('click', () => {
        document.getElementById('step3').classList.add('hidden');
        document.getElementById('step4').classList.remove('hidden');
        
        // Populate obstacle types
        const info = EQUIPMENT_INFO[state.equipmentType];
        const select = document.getElementById('obstacleType');
        select.innerHTML = '';
        info.obstacles.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = OBSTACLE_LABELS[type];
            select.appendChild(option);
        });
        
        setupObstacleCanvas();
    });

    // Step 4: Mark Obstacles
    function setupObstacleCanvas() {
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        drawPhotoWithObstacles(ctx);
        
        canvas.addEventListener('mousedown', handleObstacleMouseDown);
        canvas.addEventListener('mousemove', handleObstacleMouseMove);
        canvas.addEventListener('mouseup', handleObstacleMouseUp);
        
        canvas.addEventListener('touchstart', handleObstacleTouchStart);
        canvas.addEventListener('touchmove', handleObstacleTouchMove);
        canvas.addEventListener('touchend', handleObstacleTouchEnd);
    }

    function handleObstacleMouseDown(e) {
        const canvas = document.getElementById('photoCanvas3');
        state.currentObstacleStart = getCanvasCoordinates(canvas, e);
    }

    function handleObstacleMouseMove(e) {
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);
        
        drawPhotoWithObstacles(ctx);
        
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(
            state.currentObstacleStart.x,
            state.currentObstacleStart.y,
            current.x - state.currentObstacleStart.x,
            current.y - state.currentObstacleStart.y
        );
    }

    function handleObstacleMouseUp(e) {
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const current = getCanvasCoordinates(canvas, e);
        
        const obstacleType = document.getElementById('obstacleType').value;
        
        state.obstacles.push({
            type: obstacleType,
            bounds: {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            }
        });
        
        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function handleObstacleTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas3');
        state.currentObstacleStart = getCanvasCoordinates(canvas, e);
    }

    function handleObstacleTouchMove(e) {
        e.preventDefault();
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);
        
        drawPhotoWithObstacles(ctx);
        
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(
            state.currentObstacleStart.x,
            state.currentObstacleStart.y,
            current.x - state.currentObstacleStart.x,
            current.y - state.currentObstacleStart.y
        );
    }

    function handleObstacleTouchEnd(e) {
        e.preventDefault();
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const touch = e.changedTouches[0];
        const current = getCanvasCoordinates(canvas, { clientX: touch.clientX, clientY: touch.clientY });
        
        const obstacleType = document.getElementById('obstacleType').value;
        
        state.obstacles.push({
            type: obstacleType,
            bounds: {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            }
        });
        
        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function drawPhotoWithObstacles(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);
        
        if (state.equipment) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, 15, 0, Math.PI * 2);
            ctx.fill();
        }
        
        state.obstacles.forEach((obstacle, index) => {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(
                obstacle.bounds.x,
                obstacle.bounds.y,
                obstacle.bounds.width,
                obstacle.bounds.height
            );
            
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`${index + 1}`, obstacle.bounds.x + 10, obstacle.bounds.y + 30);
        });
    }

    function updateObstacleList() {
        const list = document.getElementById('obstacleList');
        list.innerHTML = '<h3 style="margin: 10px 0;">Marked Obstacles:</h3>';
        
        state.obstacles.forEach((obstacle, index) => {
            const item = document.createElement('div');
            item.className = 'obstacle-item';
            item.innerHTML = `
                <span>${index + 1}. ${OBSTACLE_LABELS[obstacle.type]}</span>
                <button onclick="removeObstacle(${index})">Remove</button>
            `;
            list.appendChild(item);
        });
    }

    window.removeObstacle = function(index) {
        state.obstacles.splice(index, 1);
        updateObstacleList();
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        drawPhotoWithObstacles(ctx);
    };

    document.getElementById('nextToRulesBtn').addEventListener('click', () => {
        if (state.obstacles.length === 0) {
            alert('Please mark at least one obstacle');
            return;
        }
        
        document.getElementById('step4').classList.add('hidden');
        document.getElementById('step5').classList.remove('hidden');
        
        // Populate manufacturer options
        const brandSelect = document.getElementById('brand');
        brandSelect.innerHTML = '';
        const manufacturers = CLEARANCE_RULES[state.equipmentType];
        Object.keys(manufacturers).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = manufacturers[key].name;
            brandSelect.appendChild(option);
        });
    });

    // Step 5: Generate Clearance Overlay
    document.getElementById('generateBtn').addEventListener('click', () => {
        state.brand = document.getElementById('brand').value;
        
        document.getElementById('step5').classList.add('hidden');
        document.getElementById('step6').classList.remove('hidden');
        
        generateClearanceOverlay();
    });

    function generateClearanceOverlay() {
        const canvas = document.getElementById('photoCanvas4');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        ctx.drawImage(state.photo, 0, 0);
        
        const rules = CLEARANCE_RULES[state.equipmentType][state.brand].rules;
        const violations = [];
        
        state.obstacles.forEach(obstacle => {
            const rule = rules.find(r => r.obstacle_type === obstacle.type);
            if (!rule) return;
            
            const clearancePx = {
                above: rule.clearances.above * state.scale.pixelsPerMM,
                below: rule.clearances.below * state.scale.pixelsPerMM,
                sides: rule.clearances.sides * state.scale.pixelsPerMM
            };
            
            ctx.fillStyle = rule.color;
            ctx.fillRect(
                obstacle.bounds.x - clearancePx.sides,
                obstacle.bounds.y - clearancePx.above,
                obstacle.bounds.width + (2 * clearancePx.sides),
                obstacle.bounds.height + clearancePx.above + clearancePx.below
            );
            
            ctx.strokeStyle = rule.stroke;
            ctx.lineWidth = 3;
            ctx.strokeRect(
                obstacle.bounds.x - clearancePx.sides,
                obstacle.bounds.y - clearancePx.above,
                obstacle.bounds.width + (2 * clearancePx.sides),
                obstacle.bounds.height + clearancePx.above + clearancePx.below
            );
            
            if (state.equipment.x >= obstacle.bounds.x - clearancePx.sides &&
                state.equipment.x <= obstacle.bounds.x + obstacle.bounds.width + clearancePx.sides &&
                state.equipment.y >= obstacle.bounds.y - clearancePx.above &&
                state.equipment.y <= obstacle.bounds.y + obstacle.bounds.height + clearancePx.below) {
                violations.push({ obstacle, rule });
            }
        });
        
        ctx.fillStyle = violations.length > 0 ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.arc(state.equipment.x, state.equipment.y, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.stroke();
        
        displayComplianceResult(violations);
    }

    function displayComplianceResult(violations) {
        const resultDiv = document.getElementById('complianceResult');
        
        if (violations.length === 0) {
            resultDiv.className = 'compliance-result compliance-pass';
            resultDiv.innerHTML = `‚úÖ COMPLIANT<br>${EQUIPMENT_INFO[state.equipmentType].name} position meets all clearance requirements.`;
        } else {
            resultDiv.className = 'compliance-result compliance-fail';
            let html = '‚ùå NON-COMPLIANT<br><ul class="violation-list">';
            violations.forEach(v => {
                const typeLabel = OBSTACLE_LABELS[v.obstacle.type];
                html += `<li>Too close to ${typeLabel} (requires ${Math.max(v.rule.clearances.above, v.rule.clearances.sides, v.rule.clearances.below)}mm clearance)</li>`;
            });
            html += '</ul>';
            resultDiv.innerHTML = html;
        }
    }

    document.getElementById('downloadBtn').addEventListener('click', () => {
        const canvas = document.getElementById('photoCanvas4');
        const link = document.createElement('a');
        link.download = `clearance-check-${state.equipmentType}-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
    });

    document.getElementById('startOverBtn').addEventListener('click', () => {
        location.reload();
    });
</script>
```

</body>
</html>
