<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2563eb">
    <meta name="description" content="Heating equipment clearance checking tool with AI-powered object detection">
    <link rel="manifest" href="/manifest.json">
    <title>Clearance Genie - Service & Installation Clearance Checker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f5f5f5;
        color: #333;
        overflow-x: hidden;
        padding-top: 60px;
    }

    .fixed-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 1000;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .fixed-header h1 {
        font-size: 18px;
        margin: 0;
        flex: 1;
    }

    .start-over-btn {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        font-weight: 600;
        white-space: nowrap;
        margin-left: 10px;
    }

    .start-over-btn:active {
        background: #c0392b;
    }

    .container {
        max-width: 100%;
        margin: 0 auto;
        padding: 10px;
    }

    h1 {
        font-size: 24px;
        margin: 20px 0;
        text-align: center;
        color: #2c3e50;
    }

    .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 14px;
        margin-bottom: 20px;
    }

    .step {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .step h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #34495e;
        display: flex;
        align-items: center;
    }

    .step-number {
        background: #3498db;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        font-weight: bold;
    }

    .hidden {
        display: none !important;
    }

    button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        font-weight: 600;
    }

    button:active {
        background: #2980b9;
    }

    button:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }

    button.secondary {
        background: #95a5a6;
    }

    button.danger {
        background: #e74c3c;
    }

    input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 1px;
        height: 1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
    }

    .file-upload-btn {
        display: block;
        text-align: center;
        padding: 40px;
        border: 2px dashed #3498db;
        border-radius: 8px;
        cursor: pointer;
        background: #ecf0f1;
    }

    .file-upload-btn:hover {
        background: #d5dbdb;
    }

    #photoCanvas,
    #photoCanvas2,
    #photoCanvas3,
    #photoCanvas4 {
        width: 100%;
        max-width: 100%;
        border: 2px solid #3498db;
        border-radius: 8px;
        margin: 10px 0;
        display: block;
        touch-action: none;
    }

    .input-group {
        margin: 15px 0;
    }

    .input-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #555;
    }

    .input-group input,
    .input-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
    }

    .instructions {
        background: #e8f4f8;
        padding: 12px;
        border-radius: 6px;
        margin: 10px 0;
        font-size: 14px;
        line-height: 1.5;
    }

    .equipment-type-selector {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
    }

    .equipment-type-btn {
        padding: 40px 20px;
        border: 3px solid #ddd;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s;
        touch-action: manipulation;
        user-select: none;
    }

    .equipment-type-btn:hover {
        border-color: #3498db;
    }

    .equipment-type-btn.active {
        border-color: #3498db;
        background: #e8f4f8;
    }

    .equipment-type-btn .icon {
        font-size: 40px;
        margin-bottom: 10px;
    }

    .equipment-type-btn .label {
        font-weight: 600;
        color: #2c3e50;
    }

    .obstacle-list {
        margin: 15px 0;
    }

    .obstacle-item {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 6px;
        margin: 8px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .obstacle-item button {
        width: auto;
        padding: 6px 12px;
        margin: 0;
        font-size: 14px;
    }

    .compliance-result {
        padding: 20px;
        border-radius: 8px;
        margin: 15px 0;
        font-weight: 600;
        text-align: center;
    }

    .compliance-pass {
        background: #d4edda;
        color: #155724;
        border: 2px solid #c3e6cb;
    }

    .compliance-fail {
        background: #f8d7da;
        color: #721c24;
        border: 2px solid #f5c6cb;
    }

    .violation-list {
        list-style: none;
        margin-top: 10px;
        text-align: left;
    }

    .violation-list li {
        padding: 8px;
        margin: 5px 0;
        background: rgba(255,255,255,0.5);
        border-radius: 4px;
    }

    .legend {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        flex-wrap: wrap;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin: 5px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 8px;
    }

    .info-box {
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 6px;
        padding: 12px;
        margin: 10px 0;
        font-size: 14px;
    }

    .info-box strong {
        color: #856404;
    }

    @media (max-width: 600px) {
        .container {
            padding: 5px;
        }
        
        h1 {
            font-size: 20px;
            margin: 10px 0;
        }
        
        .step {
            padding: 15px;
            margin: 10px 0;
        }

        .equipment-type-selector {
            grid-template-columns: 1fr;
        }
    }

    /* Magnifying glass mark position button - Enhanced for mobile touch */
    #markPositionBtn:hover {
        background: rgba(52, 152, 219, 1);
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    }

    #markPositionBtn:active {
        background: rgba(41, 128, 185, 1);
        transform: translate(-50%, -50%) scale(0.95);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    /* Ensure button is accessible on touch devices */
    #markPositionBtn {
        min-width: 56px;
        min-height: 56px;
    }

    /* Tool buttons styling */
    .tool-btn {
        transition: all 0.2s ease;
    }

    .tool-btn:active, .tool-btn.active {
        border-color: #2ecc71 !important;
        background: #2ecc71 !important;
        transform: scale(0.98);
    }

    .tool-btn:hover:not(.active) {
        opacity: 0.9;
        transform: scale(1.02);
    }

    /* Object editing controls */
    .object-editor {
        background: white;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border: 2px solid #3498db;
    }

    .object-editor h3 {
        font-size: 16px;
        margin-bottom: 10px;
        color: #2c3e50;
    }

    .arrow-controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        max-width: 200px;
        margin: 10px auto;
    }

    .arrow-btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 15px;
        border-radius: 6px;
        font-size: 20px;
        cursor: pointer;
        font-weight: 600;
        width: 100%;
        margin: 0;
    }

    .arrow-btn:active {
        background: #2980b9;
    }

    .arrow-btn:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }

    .size-editor {
        margin-top: 15px;
    }

    .size-editor label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #34495e;
    }

    .size-editor select,
    .size-editor input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        margin-bottom: 10px;
    }

    .model-editor {
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
    }

    .model-editor h3 {
        font-size: 16px;
        margin-bottom: 10px;
        color: #856404;
    }

    .drag-hint {
        background: #e8f4f8;
        border: 1px dashed #3498db;
        border-radius: 6px;
        padding: 10px;
        margin: 10px 0;
        text-align: center;
        font-size: 13px;
        color: #2c3e50;
    }
</style>

</head>
<body>
    <div class="fixed-header">
        <h1>üî• Clearance Genie</h1>
        <button class="start-over-btn" onclick="startOver()">Start Over</button>
    </div>

    <div class="container">
        <div class="subtitle">Service & Installation Clearance Checker</div>

    <!-- Step 0: Select Equipment Type -->
    <div class="step" id="step0">
        <h2><span class="step-number">0</span> Select Equipment Type</h2>
        <div class="equipment-type-selector">
            <div class="equipment-type-btn" data-equipment-type="boiler">
                <div class="icon">üî•</div>
                <div class="label">Boiler</div>
            </div>
            <div class="equipment-type-btn" data-equipment-type="flue">
                <div class="icon">üå¨Ô∏è</div>
                <div class="label">Flue Terminal</div>
            </div>
            <div class="equipment-type-btn" data-equipment-type="cylinder">
                <div class="icon">üõ¢Ô∏è</div>
                <div class="label">Cylinder</div>
            </div>
            <div class="equipment-type-btn" data-equipment-type="radiator">
                <div class="icon">‚ô®Ô∏è</div>
                <div class="label">Radiator</div>
            </div>
        </div>
        <div class="info-box" id="equipmentInfo">
            Select the type of equipment you're checking clearances for.
        </div>
    </div>

    <!-- Step 1: Upload Photo -->
    <div class="step hidden" id="step1">
        <h2><span class="step-number">1</span> Add Photo</h2>
        <div class="instructions">
            Choose how you want to add a photo:
        </div>
        <label for="photoCameraInput" class="file-upload-btn" style="margin-bottom: 10px;">
            üì∏ Take Photo with Camera
        </label>
        <input type="file" id="photoCameraInput" accept="image/*" capture="environment">
        <label for="photoUploadInput" class="file-upload-btn">
            üìÅ Upload Existing Photo
        </label>
        <input type="file" id="photoUploadInput" accept="image/*">
    </div>

    <!-- Step 2: Set Scale -->
    <div class="step hidden" id="step2">
        <h2><span class="step-number">2</span> Set Scale</h2>

        <!-- AI Detection with Lasso Section -->
        <div class="instructions">
            <strong>ü§ñ Option 1: AI-Assisted Detection (Recommended)</strong><br>
            <strong>Step 1:</strong> Draw a rough lasso around your reference object (üîµ blue card or brick)<br>
            <strong>Step 2:</strong> AI will find exact edges within that area
            <ul style="margin: 5px 0 5px 20px;">
                <li><strong>üîµ Blue credit/debit card</strong> (85.6mm √ó 54mm) - Best accuracy</li>
                <li><strong>Standard UK brick</strong> (215mm √ó 102.5mm) - Good for outdoor photos</li>
            </ul>
        </div>
        <div class="instructions" style="background: #e3f2fd; border-left: 4px solid #2196f3;">
            üí° <strong>How it works:</strong> You roughly circle the card, AI refines the exact edges. Much more reliable than auto-detect!
        </div>
        <button id="startLassoBtn" style="margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            ‚úèÔ∏è Draw Lasso Around Card/Brick
        </button>
        <button id="detectInLassoBtn" style="margin-bottom: 20px; display: none; background: #2e7d32;">
            ü§ñ Detect Card in Selected Area
        </button>
        <button id="cancelLassoBtn" style="margin-bottom: 20px; display: none; background: #e74c3c;">
            ‚úñ Cancel Lasso
        </button>
        <div id="lassoStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Magnifying Glass Controls -->
        <div class="instructions" style="background: #f0f0f0; border-left: 4px solid #666; margin-top: 20px;">
            <strong>üîç Magnifying Glass Settings</strong><br>
            <div style="margin: 10px 0;">
                <label style="display: inline-flex; align-items: center; cursor: pointer; margin-right: 20px;">
                    <input type="checkbox" id="magnifyEnabled" checked style="width: auto; margin-right: 8px;">
                    <span>Enable Magnifying Glass</span>
                </label>
                <label style="display: inline-flex; align-items: center; cursor: pointer; margin-right: 10px;">
                    <input type="radio" id="magnifyRight" name="magnifyHand" value="right" checked style="width: auto; margin-right: 5px;">
                    <span>Right Hand</span>
                </label>
                <label style="display: inline-flex; align-items: center; cursor: pointer;">
                    <input type="radio" id="magnifyLeft" name="magnifyHand" value="left" style="width: auto; margin-right: 5px;">
                    <span>Left Hand üëà</span>
                </label>
            </div>
        </div>

        <!-- Manual Calibration Section -->
        <div class="instructions" style="background: #fff9e6; border-left: 4px solid #ff9800; margin-top: 20px;">
            <strong>üìè Option 2: Manual Calibration</strong><br>
            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px; font-family: monospace; text-align: center;">
                <strong>Example: Measuring credit card width</strong><br>
                <div style="margin: 10px 0; font-size: 18px;">
                    üìç<span style="color: #2e7d32;">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>üìç<br>
                    <span style="font-size: 12px;">üëÜ Point 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85mm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point 2 üëÜ</span>
                </div>
            </div>
            <strong style="color: #e65100;">Step 1:</strong> Move mouse/finger over the photo to see magnifying glass<br>
            <strong style="color: #e65100;">Step 2:</strong> Click the üìç button in the center of the magnifying glass to mark TWO points<br>
            <strong style="color: #e65100;">Step 3:</strong> Enter the distance between those points (85mm for card width)<br>
            <span style="font-size: 0.9em;">üîµ <strong>Blue card recommended for best results</strong> | Standard card: <strong>Width = 85mm</strong> | Height = 54mm</span>
        </div>
        <div id="manualCalibrationGuide" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 14px; display: none;">
            <div style="margin-bottom: 10px;">
                <strong>Calibration Mode:</strong>
                <button id="twoPointModeBtn" style="padding: 5px 12px; font-size: 12px; margin-left: 5px; background: #3498db;" onclick="setCalibrationMode('two-point')">2-Point (Fast)</button>
                <button id="fourPointModeBtn" style="padding: 5px 12px; font-size: 12px; margin-left: 5px; background: #95a5a6;" onclick="setCalibrationMode('four-point')">4-Point (Accurate)</button>
            </div>
            <div id="twoPointInstructions">
                <strong>üìå Point 1:</strong> <span id="point1Status" style="color: #e74c3c;">Not set - Click the üìç button in magnifying glass</span>
                <button id="undoPoint1Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(1)">‚Ü∂ Undo</button><br>
                <strong>üìå Point 2:</strong> <span id="point2Status" style="color: #95a5a6;">Waiting for Point 1...</span>
                <button id="undoPoint2Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(2)">‚Ü∂ Undo</button>
            </div>
            <div id="fourPointInstructions" style="display: none;">
                <div style="margin-bottom: 8px; padding: 6px; background: #fff3e0; border-radius: 4px; font-size: 13px;">
                    ‚ÑπÔ∏è <strong>Mark all 4 corners</strong> of a üîµ blue card clockwise: Top-Left ‚Üí Top-Right ‚Üí Bottom-Right ‚Üí Bottom-Left
                </div>
                <strong>üìå Corner 1 (Top-Left):</strong> <span id="point1Status4pt" style="color: #e74c3c;">Not set</span>
                <button id="undoPoint1Btn4pt" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(1)">‚Ü∂ Undo</button><br>
                <strong>üìå Corner 2 (Top-Right):</strong> <span id="point2Status4pt" style="color: #95a5a6;">Waiting...</span>
                <button id="undoPoint2Btn4pt" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(2)">‚Ü∂ Undo</button><br>
                <strong>üìå Corner 3 (Bottom-Right):</strong> <span id="point3Status4pt" style="color: #95a5a6;">Waiting...</span>
                <button id="undoPoint3Btn4pt" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(3)">‚Ü∂ Undo</button><br>
                <strong>üìå Corner 4 (Bottom-Left):</strong> <span id="point4Status4pt" style="color: #95a5a6;">Waiting...</span>
                <button id="undoPoint4Btn4pt" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(4)">‚Ü∂ Undo</button>
            </div>
            <div id="perspectiveWarningDiv" style="display: none; margin-top: 10px; padding: 8px; background: #fff3e0; border-radius: 5px; border-left: 4px solid #ff9800;">
                <strong>‚ö†Ô∏è Perspective Distortion Detected</strong><br>
                <span style="font-size: 12px;">The photo appears to be taken at an angle. Scale variation: <span id="scaleVariation"></span>%<br>
                For best accuracy, retake the photo more straight-on or accept the averaged scale.</span>
            </div>
            <br>
            <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px;">
                üîç <strong>Magnifying glass active</strong> - Move your mouse/finger over the photo to position the magnifying glass, then release. The magnifier stays visible so you can adjust the zoom slider and click the üìç button to mark the exact position.
            </div>
        </div>
        <div style="position: relative; margin: 10px 0;">
            <canvas id="photoCanvas"></canvas>
            <!-- Magnifying Glass -->
            <div id="magnifyingGlass" style="display: none; position: absolute; width: 150px; height: 150px; border: 3px solid #3498db; border-radius: 50%; pointer-events: none; box-shadow: 0 0 15px rgba(0,0,0,0.5); overflow: visible; z-index: 1000; background: white;">
                <canvas id="magnifyCanvas" width="150" height="150"></canvas>
                <div style="position: absolute; top: 50%; left: 50%; width: 2px; height: 20px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <div style="position: absolute; top: 50%; left: 50%; width: 20px; height: 2px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <!-- Center button for marking positions - Optimized for mobile touch -->
                <button id="markPositionBtn" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 56px; height: 56px; border-radius: 50%; background: rgba(52, 152, 219, 0.9); border: 3px solid white; color: white; font-size: 24px; cursor: pointer; pointer-events: auto; box-shadow: 0 3px 12px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; padding: 0; font-weight: bold; z-index: 1001; touch-action: manipulation; -webkit-tap-highlight-color: rgba(52, 152, 219, 0.3); transition: all 0.15s ease;">üìç</button>
            </div>
            <!-- Zoom Slider -->
            <div id="zoomSliderContainer" style="display: none; position: absolute; background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 999; pointer-events: auto;">
                <label style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 5px; color: #333;">Zoom Level</label>
                <input type="range" id="zoomSlider" min="2" max="8" step="0.5" value="3" style="width: 150px; cursor: pointer;">
                <div style="text-align: center; font-size: 12px; color: #666; margin-top: 3px;"><span id="zoomValue">3</span>x</div>
            </div>
        </div>
        <div class="input-group">
            <label for="knownDistance"><strong>Distance between the two points you tapped:</strong></label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="number" id="knownDistance" placeholder="85" value="85" min="1" style="flex: 1;">
                <span style="font-weight: bold; color: #666;">millimeters (mm)</span>
            </div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                Examples: üîµ Blue card width = 85mm (best), Height = 54mm, Phone width ‚âà 70-80mm
            </div>
        </div>
        <button id="confirmScaleBtn" disabled>‚úì Confirm Scale</button>
        <button class="secondary" id="resetScaleBtn">‚Üª Reset Points & Try Again</button>
    </div>

    <!-- Step 3: Mark Equipment -->
    <div class="step hidden" id="step3">
        <h2><span class="step-number">3</span> Mark <span id="equipmentLabel">Equipment</span> Position</h2>
        <div class="instructions">
            <strong>üìç Find your <span id="equipmentLabel2" style="color: #e74c3c; font-size: 1.1em;">Equipment</span> in the photo below</strong>
        </div>
        <div class="instructions" id="step3Instructions" style="background: #fff3cd; border-left: 4px solid #ffc107;">
            <strong>Tap/Click</strong> the center of the equipment on the photo.<br>
            <strong>‚å®Ô∏è Use arrow keys</strong> to fine-tune position (Hold Shift for faster movement).
        </div>
        <canvas id="photoCanvas2"></canvas>
        <button id="confirmEquipmentBtn" disabled>Confirm Position</button>
    </div>

    <!-- Step 4: Mark Obstacles -->
    <div class="step hidden" id="step4">
        <h2><span class="step-number">4</span> Mark Clearance Obstacles</h2>

        <!-- AI Context Message Panel -->
        <div class="instructions" style="background: #f3e5f5; border-left: 4px solid #9c27b0; margin-bottom: 20px;">
            <strong>üí¨ Optional: Provide Context to AI</strong><br>
            Give the AI additional instructions to improve detection accuracy
        </div>
        <div style="margin-bottom: 20px; padding: 15px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px;">
            <label for="aiMessageInput" style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">
                Message to AI (optional):
            </label>
            <textarea
                id="aiMessageInput"
                placeholder="e.g., 'Cupboard to be removed to fit boiler', 'Vent to be sealed', 'Shelf to be removed', 'Ignore kitchen appliances'"
                style="width: 100%; min-height: 80px; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-family: Arial, sans-serif; font-size: 14px; resize: vertical;"
            ></textarea>
            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                <strong>Examples:</strong> "Cupboard to be removed to fit boiler" ‚Ä¢ "Vent to be sealed" ‚Ä¢ "Ignore kitchen appliances" ‚Ä¢ "Shelf to be removed"
            </div>
        </div>

        <!-- Lasso + AI Detection Section (Primary Method) -->
        <div class="instructions">
            <strong>‚ú® Option 1: Lasso + AI Detection (Recommended)</strong><br>
            <strong>Step 1:</strong> Draw a rough lasso around an obstacle<br>
            <strong>Step 2:</strong> AI will find exact boundaries within that area<br>
            <strong>Step 3:</strong> Select the obstacle type and confirm<br>
            The AI will lock onto the true edges only (e.g., just the window opening without surrounding brickwork) for pixel-perfect marking, including soffits.
        </div>
        <div class="instructions" style="background: #e8f5e9; border-left: 4px solid #4caf50;">
            üí° <strong>Why use lasso+AI?</strong> Much more accurate and faster! You roughly circle obstacles like windows, doors, or walls, and AI refines the exact edges. This combines your knowledge of what's important with AI precision!
        </div>
        <button id="startObstacleLassoBtn" style="margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            ‚úèÔ∏è Draw Lasso Around Obstacle
        </button>
        <button id="detectInObstacleLassoBtn" style="margin-bottom: 10px; display: none; background: #2e7d32; color: white;">
            ü§ñ Detect Obstacle with AI
        </button>
        <button id="clearObstacleLassoBtn" style="margin-bottom: 10px; display: none; background: #e74c3c; color: white;">
            üóëÔ∏è Clear Lasso
        </button>
        <div id="obstacleLassoStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Auto-Detect All (Secondary AI Option) -->
        <div class="instructions" style="margin-top: 20px; background: #e3f2fd; border-left: 4px solid #2196f3;">
            <strong>ü§ñ Or: Auto-Detect All Obstacles</strong><br>
            Let AI try to detect all obstacles automatically (may miss some or be less accurate).
        </div>
        <button id="autoDetectObstaclesBtn" style="margin-bottom: 20px; background: #2196f3; color: white;">
            ü§ñ Auto-Detect All Obstacles (AI)
        </button>
        <div id="autoDetectObstaclesStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Manual Marking Section (Fallback) -->
        <details style="margin-top: 20px;">
            <summary style="cursor: pointer; padding: 12px; background: #fff9e6; border: 2px dashed #ff9800; border-radius: 8px; font-weight: 600; user-select: none;">
                üìè Option 2: Manual Tools (Fallback - Click to Expand)
            </summary>
            <div style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                <div class="instructions" style="background: #fff3cd; border-left: 4px solid #ffc107; margin-bottom: 10px;" id="step4Instructions">
                    <strong>‚ö†Ô∏è Manual Marking:</strong> Use these tools only if lasso+AI doesn't work for a specific obstacle. These require precise drawing and are more time-consuming.
                </div>
                <strong style="display: block; margin-bottom: 10px;">Marking Tools:</strong>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="rectangleToolBtn" class="tool-btn" style="flex: 1; min-width: 120px; padding: 10px; background: #3498db; border: 2px solid transparent; border-radius: 6px; font-size: 14px; cursor: pointer;">
                        üìê Rectangle<br><span style="font-size: 11px; opacity: 0.9;">Windows, Doors</span>
                    </button>
                    <button id="lineToolBtn" class="tool-btn" style="flex: 1; min-width: 120px; padding: 10px; background: #95a5a6; border: 2px solid transparent; border-radius: 6px; font-size: 14px; cursor: pointer;">
                        üìè Line<br><span style="font-size: 11px; opacity: 0.9;">Edges, Soffits</span>
                    </button>
                    <button id="circleToolBtn" class="tool-btn" style="flex: 1; min-width: 120px; padding: 10px; background: #95a5a6; border: 2px solid transparent; border-radius: 6px; font-size: 14px; cursor: pointer;">
                        ‚≠ï Circle<br><span style="font-size: 11px; opacity: 0.9;">Round Objects</span>
                    </button>
                    <button id="paintToolBtn" class="tool-btn" style="flex: 1; min-width: 120px; padding: 10px; background: #95a5a6; border: 2px solid transparent; border-radius: 6px; font-size: 14px; cursor: pointer;">
                        üñåÔ∏è Paint<br><span style="font-size: 11px; opacity: 0.9;">AI Confirm Area</span>
                    </button>
                </div>
                <div id="toolInstructions" style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px; font-size: 13px;">
                    <strong>üìê Rectangle Tool:</strong> Tap two corners to draw a rectangle around the obstacle
                </div>
                <div id="paintToolControls" style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 5px; display: none;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Brush Size: <span id="brushSizeValue">30</span>px</label>
                    <input type="range" id="brushSizeSlider" min="10" max="100" value="30" style="width: 100%;">
                    <button id="confirmPaintMaskBtn" style="margin-top: 8px; padding: 8px; background: #2e7d32; color: white; border: none; border-radius: 4px; width: 100%; font-size: 13px;">
                        ü§ñ Confirm Masked Area with AI
                    </button>
                    <button id="clearPaintMaskBtn" style="margin-top: 5px; padding: 6px; background: #e74c3c; color: white; border: none; border-radius: 4px; width: 100%; font-size: 12px;">
                        Clear Paint Mask
                    </button>
                </div>
            </div>
        </details>

        <canvas id="photoCanvas3"></canvas>
        <div class="input-group">
            <label for="obstacleType">Obstacle Type:</label>
            <select id="obstacleType">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <div class="obstacle-list" id="obstacleList"></div>
        <button id="nextToRulesBtn">Continue to Clearance Check</button>
    </div>

    <!-- Step 5: Select Brand & Model & Generate -->
    <div class="step hidden" id="step5">
        <h2><span class="step-number">5</span> Select Manufacturer & Model</h2>
        <div class="input-group" id="boilerTypeGroup" style="display: none;">
            <label for="boilerType">Boiler Type:</label>
            <select id="boilerType">
                <option value="">-- Select Boiler Type --</option>
                <option value="combi">Combi</option>
                <option value="system">System</option>
                <option value="regular">Regular</option>
            </select>
        </div>
        <div class="input-group" id="brandSelectGroup">
            <label for="brand">Manufacturer:</label>
            <select id="brand">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <div class="input-group" id="modelSelectGroup" style="display: none;">
            <label for="model">Model:</label>
            <select id="model">
                <!-- Will be populated based on selected brand -->
            </select>
        </div>
        <div class="info-box" style="background: #e3f2fd; border-color: #2196f3;">
            <strong>üí° Model-Specific Clearances:</strong> Each model has specific clearance requirements. Select the exact model for accurate compliance checking.
            <br><strong>Boilers:</strong> Choose the boiler type (Combi/System/Regular) alongside the make and model so the correct clearances are applied.
        </div>
        <button id="generateBtn">Generate Clearance Overlay</button>
    </div>

    <!-- Step 6: Results -->
    <div class="step hidden" id="step6">
        <h2><span class="step-number">6</span> Results</h2>
        <canvas id="photoCanvas4"></canvas>

        <div class="model-editor" id="modelEditorSection" style="display: none;">
            <h3>Change Make & Model</h3>
            <div class="size-editor" id="boilerTypeResultsGroup" style="display: none;">
                <label for="boilerTypeResults">Boiler Type:</label>
                <select id="boilerTypeResults" onchange="updateBoilerTypeSelectionInResults()">
                    <option value="combi">Combi</option>
                    <option value="system">System</option>
                    <option value="regular">Regular</option>
                </select>
            </div>
            <div class="size-editor">
                <label for="brandSelectResults">Brand:</label>
                <select id="brandSelectResults" onchange="updateBrandSelection()">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="size-editor">
                <label for="modelSelectResults">Model:</label>
                <select id="modelSelectResults" onchange="updateModelSelection()">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <button onclick="hideModelEditor()" style="background: #95a5a6; margin-top: 10px;">Close</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,0,0,0.3);"></div>
                <span>Prohibited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,165,0,0.3);"></div>
                <span>Warning</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0,255,0,0.3);"></div>
                <span>Service Access</span>
            </div>
        </div>
        
        <div id="complianceResult"></div>

        <button onclick="showModelEditorInResults()" style="background: #f39c12;">Change Make/Model</button>
        <button id="downloadBtn">Download Annotated Photo</button>
        <button class="secondary" id="startOverBtn">Start Over</button>
        <button class="danger" id="forceResetBtn">üîÑ Force Reset (Clear All Data)</button>
    </div>
</div>

<script>
    // Radiator reference data from November 2025 price book
    const RADIATOR_MAKES = ['Stelrad', 'Myson', 'Kudox'];
    const RADIATOR_TYPES = [
        { value: 'type11', label: 'Single panel single convector (Type 11)' },
        { value: 'type21', label: 'Double panel single convector (Type 21)' },
        { value: 'type22', label: 'Double panel double convector (Type 22)' },
        { value: 'vertical', label: 'Vertical radiator (selected sizes, usually 1800√ó400/600mm)' },
        { value: 'towel_rail', label: 'Towel rail (300/400/500 √ó 800/1200/1600mm, chrome or white)' },
        { value: 'column', label: 'Column radiator (varied sizes, mainly Stelrad)' }
    ];
    const RADIATOR_SIZES = [
        '400x400', '600x400', '800x400', '1000x400', '1200x400', '1400x400', '1600x400', '1800x400', '2000x400',
        '400x600', '600x600', '800x600', '1000x600', '1200x600', '1400x600', '1600x600', '1800x600', '2000x600',
        '400x700', '600x700', '800x700', '1000x700', '1200x700'
    ];

    // Application state
    const state = {
        equipmentType: null,
        boilerType: null,
        photo: null,
        photoWidth: 0,
        photoHeight: 0,
        scale: {
            point1: null,
            point2: null,
            point3: null,
            point4: null,
            calibrationMode: 'two-point', // 'two-point' or 'four-point'
            distanceMM: 85,
            pixelsPerMM: 0,
            perspectiveWarning: false
        },
        equipment: null,
        obstacles: [],
        brand: null,
        model: null, // Selected model
        aiMessage: '', // User's optional message to AI for context
        currentObstacleStart: null,
        currentMagnifierPosition: null,
        lassoMode: false,
        lassoPoints: [],
        lassoComplete: false,
        drawingTool: 'rectangle', // 'rectangle', 'line', 'circle', or 'paint'
        paintMasks: [], // Array of painted mask regions for AI confirmation
        paintBrushSize: 30, // Paint brush size in pixels
        isPainting: false,
        currentPaintStroke: null,
        magnifyEnabled: true,
        magnifyHandedness: 'right', // 'left' or 'right'
        cylinderSize: '120L', // Default cylinder size
        radiatorMake: 'Stelrad',
        radiatorType: 'type22',
        radiatorSize: '1200x600', // Default radiator size (width x height in mm)
        selectedObject: null, // Currently selected object for editing {type: 'equipment'|'obstacle', index: null}
        dragOffset: null, // Offset for dragging
        recentDetection: null // Temporary highlight of the latest AI-mapped obstacle
    };

    // Equipment type configurations
    const EQUIPMENT_INFO = {
        flue: {
            name: "Flue Terminal",
            icon: "üå¨Ô∏è",
            description: "Check clearances around boiler flue terminals to windows, doors, vents, soffits, and building features.",
            markingInstruction: "Tap the center of the flue terminal.",
            obstacles: ['opening_window', 'non_opening_window', 'vent', 'door', 'corner', 'ground', 'soffit', 'gutter', 'balcony', 'canopy']
        },
        boiler: {
            name: "Boiler",
            icon: "üî•",
            description: "Check service clearances around boilers for maintenance access, ventilation, and safe installation.",
            markingInstruction: "Tap the center of the boiler.",
            obstacles: ['wall', 'ceiling', 'floor', 'corner', 'door', 'window', 'pipe', 'duct', 'beam', 'cupboard']
        },
        radiator: {
            name: "Radiator",
            icon: "‚ô®Ô∏è",
            description: "Check clearances around radiators for air circulation, curtains, and furniture.",
            markingInstruction: "Tap the center of the radiator.",
            obstacles: ['wall', 'floor', 'window', 'curtain_rail', 'furniture', 'socket', 'skirting_board', 'shelf', 'desk', 'sofa']
        },
        cylinder: {
            name: "Cylinder",
            icon: "üõ¢Ô∏è",
            description: "Check service clearances around hot water cylinders for maintenance and safety valve access.",
            markingInstruction: "Tap the center of the cylinder.",
            obstacles: ['wall', 'ceiling', 'floor', 'door', 'corner', 'pipe', 'tank', 'shelf', 'cupboard']
        }
    };

    // Comprehensive clearance rules database with model-specific data
    const CLEARANCE_RULES = {
        // FLUE RULES
        flue: {
            worcester_bosch: {
                name: "Worcester Bosch",
                models: {
                    greenstar_8000: {
                        name: "Greenstar 8000 Style",
                        dimensions: { width: 100, height: 100, depth: 50 }, // mm (flue terminal dimensions)
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    greenstar_4000: {
                        name: "Greenstar 4000",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    greenstar_2000: {
                        name: "Greenstar 2000",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    }
                }
            },
            vaillant: {
                name: "Vaillant",
                models: {
                    ecotec_plus: {
                        name: "ecoTEC Plus",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    ecotec_exclusive: {
                        name: "ecoTEC Exclusive",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    }
                }
            },
            ideal: {
                name: "Ideal",
                models: {
                    logic_plus: {
                        name: "Logic Plus",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    logic_max: {
                        name: "Logic Max",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    vogue_max: {
                        name: "Vogue Max",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    }
                }
            },
            viessmann: {
                name: "Viessmann",
                models: {
                    vitodens_050: {
                        name: "Vitodens 050-W",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 2130, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    vitodens_100: {
                        name: "Vitodens 100-W",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 2130, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    vitodens_200: {
                        name: "Vitodens 200-W",
                        dimensions: { width: 100, height: 100, depth: 50 },
                        rules: [
                            { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'ground', clearances: { above: 0, below: 2130, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'soffit', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    }
                }
            }
        },
        
        // COMBI BOILER RULES
        combi_boiler: {
            worcester_bosch: {
                name: "Worcester Bosch",
                models: {
                    greenstar_8000_life_25: { name: "Greenstar 8000 Life 25kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_life_30: { name: "Greenstar 8000 Life 30kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_style_30: { name: "Greenstar 8000 Style 30kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_style_35: { name: "Greenstar 8000 Style 35kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_4000_25: { name: "Greenstar 4000 25kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_4000_30: { name: "Greenstar 4000 30kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_2000_24: { name: "Greenstar 2000 24kW", dimensions: { width: 390, height: 700, depth: 310 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_2000_30: { name: "Greenstar 2000 30kW", dimensions: { width: 390, height: 700, depth: 310 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_1200_ri_18: { name: "Greenstar 1200 Ri 18kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_1200_ri_24: { name: "Greenstar 1200 Ri 24kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_compact_25: { name: "Greenstar Compact 25kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_compact_30: { name: "Greenstar Compact 30kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            vaillant: {
                name: "Vaillant",
                models: {
                    ecotec_plus_825: { name: "ecoTEC Plus 825", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_830: { name: "ecoTEC Plus 830", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_835: { name: "ecoTEC Plus 835", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_838: { name: "ecoTEC Plus 838", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_825: { name: "ecoTEC Exclusive 825", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_830: { name: "ecoTEC Exclusive 830", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_835: { name: "ecoTEC Exclusive 835", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_843: { name: "ecoTEC Exclusive 843", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_pure_825: { name: "ecoTEC Pure 825", dimensions: { width: 360, height: 720, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_pure_830: { name: "ecoTEC Pure 830", dimensions: { width: 360, height: 720, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_pure_835: { name: "ecoTEC Pure 835", dimensions: { width: 360, height: 720, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            ideal: {
                name: "Ideal",
                models: {
                    logic_plus_24: { name: "Logic Plus 24kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_plus_30: { name: "Logic Plus 30kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_plus_35: { name: "Logic Plus 35kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_max_24: { name: "Logic Max 24kW", dimensions: { width: 395, height: 710, depth: 285 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_max_30: { name: "Logic Max 30kW", dimensions: { width: 395, height: 710, depth: 285 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_max_35: { name: "Logic Max 35kW", dimensions: { width: 395, height: 710, depth: 285 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_26: { name: "Vogue Max 26kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_32: { name: "Vogue Max 32kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_40: { name: "Vogue Max 40kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_code_24: { name: "Logic Code 24kW", dimensions: { width: 380, height: 705, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_code_30: { name: "Logic Code 30kW", dimensions: { width: 380, height: 705, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_code_35: { name: "Logic Code 35kW", dimensions: { width: 380, height: 705, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            viessmann: {
                name: "Viessmann",
                models: {
                    vitodens_050_25: { name: "Vitodens 050-W 25kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_050_30: { name: "Vitodens 050-W 30kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_050_35: { name: "Vitodens 050-W 35kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_19: { name: "Vitodens 100-W 19kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_25: { name: "Vitodens 100-W 25kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_30: { name: "Vitodens 100-W 30kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_35: { name: "Vitodens 100-W 35kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_19: { name: "Vitodens 200-W 19kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_26: { name: "Vitodens 200-W 26kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_30: { name: "Vitodens 200-W 30kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_35: { name: "Vitodens 200-W 35kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            }
        },

        // SYSTEM BOILER RULES
        system_boiler: {
            worcester_bosch: {
                name: "Worcester Bosch",
                models: {
                    greenstar_8000_style_system_25: { name: "Greenstar 8000 Style System 25kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_style_system_30: { name: "Greenstar 8000 Style System 30kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_life_system_25: { name: "Greenstar 8000 Life System 25kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_8000_life_system_30: { name: "Greenstar 8000 Life System 30kW", dimensions: { width: 440, height: 700, depth: 340 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_4000_system_18: { name: "Greenstar 4000 System 18kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_4000_system_25: { name: "Greenstar 4000 System 25kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_4000_system_30: { name: "Greenstar 4000 System 30kW", dimensions: { width: 400, height: 720, depth: 330 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_2000_system_18: { name: "Greenstar 2000 System 18kW", dimensions: { width: 390, height: 700, depth: 310 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_2000_system_24: { name: "Greenstar 2000 System 24kW", dimensions: { width: 390, height: 700, depth: 310 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_2000_system_30: { name: "Greenstar 2000 System 30kW", dimensions: { width: 390, height: 700, depth: 310 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            vaillant: {
                name: "Vaillant",
                models: {
                    ecotec_plus_system_418: { name: "ecoTEC Plus System 418", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_system_425: { name: "ecoTEC Plus System 425", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_system_430: { name: "ecoTEC Plus System 430", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_system_435: { name: "ecoTEC Plus System 435", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_system_832: { name: "ecoTEC Exclusive System 832", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_system_835: { name: "ecoTEC Exclusive System 835", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_exclusive_system_843: { name: "ecoTEC Exclusive System 843", dimensions: { width: 440, height: 800, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            ideal: {
                name: "Ideal",
                models: {
                    logic_plus_system_18: { name: "Logic Plus System 18kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_plus_system_24: { name: "Logic Plus System 24kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_plus_system_30: { name: "Logic Plus System 30kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_max_system_24: { name: "Logic Max System 24kW", dimensions: { width: 395, height: 710, depth: 285 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_max_system_30: { name: "Logic Max System 30kW", dimensions: { width: 395, height: 710, depth: 285 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_system_26: { name: "Vogue Max System 26kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_system_32: { name: "Vogue Max System 32kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vogue_max_system_40: { name: "Vogue Max System 40kW", dimensions: { width: 410, height: 730, depth: 295 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 2.5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 150, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            viessmann: {
                name: "Viessmann",
                models: {
                    vitodens_050_system_25: { name: "Vitodens 050-W System 25kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_050_system_30: { name: "Vitodens 050-W System 30kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_050_system_35: { name: "Vitodens 050-W System 35kW", dimensions: { width: 400, height: 700, depth: 300 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_12: { name: "Vitodens 100-W System 12kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_15: { name: "Vitodens 100-W System 15kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_18: { name: "Vitodens 100-W System 18kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_24: { name: "Vitodens 100-W System 24kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_30: { name: "Vitodens 100-W System 30kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_100_system_35: { name: "Vitodens 100-W System 35kW", dimensions: { width: 400, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_system_19: { name: "Vitodens 200-W System 19kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_system_26: { name: "Vitodens 200-W System 26kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_system_30: { name: "Vitodens 200-W System 30kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    vitodens_200_system_35: { name: "Vitodens 200-W System 35kW", dimensions: { width: 450, height: 700, depth: 360 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 5 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 30, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 200, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            }
        },

        // REGULAR BOILER RULES (Heat Only)
        regular_boiler: {
            worcester_bosch: {
                name: "Worcester Bosch",
                models: {
                    greenstar_ri_regular_12: { name: "Greenstar Ri Regular 12kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_ri_regular_15: { name: "Greenstar Ri Regular 15kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_ri_regular_18: { name: "Greenstar Ri Regular 18kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_ri_regular_24: { name: "Greenstar Ri Regular 24kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_ri_regular_27: { name: "Greenstar Ri Regular 27kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_ri_regular_30: { name: "Greenstar Ri Regular 30kW", dimensions: { width: 400, height: 700, depth: 290 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_danesmoor_regular_18_25: { name: "Greenstar Danesmoor Regular 18/25kW", dimensions: { width: 580, height: 860, depth: 630 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    greenstar_danesmoor_regular_25_32: { name: "Greenstar Danesmoor Regular 25/32kW", dimensions: { width: 580, height: 860, depth: 630 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            vaillant: {
                name: "Vaillant",
                models: {
                    ecotec_plus_regular_412: { name: "ecoTEC Plus Regular 412", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_regular_415: { name: "ecoTEC Plus Regular 415", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_regular_418: { name: "ecoTEC Plus Regular 418", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_regular_424: { name: "ecoTEC Plus Regular 424", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_regular_430: { name: "ecoTEC Plus Regular 430", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    ecotec_plus_regular_435: { name: "ecoTEC Plus Regular 435", dimensions: { width: 440, height: 720, depth: 338 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            },
            ideal: {
                name: "Ideal",
                models: {
                    logic_heat_regular_12: { name: "Logic Heat Regular 12kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_heat_regular_15: { name: "Logic Heat Regular 15kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_heat_regular_18: { name: "Logic Heat Regular 18kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_heat_regular_24: { name: "Logic Heat Regular 24kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_heat_regular_30: { name: "Logic Heat Regular 30kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] },
                    logic_heat_regular_35: { name: "Logic Heat Regular 35kW", dimensions: { width: 380, height: 690, depth: 275 }, rules: [{ obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }, { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }, { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }] }
                }
            }
        },

        // RADIATOR RULES
        radiator: {
            general: {
                name: "General Standards",
                models: {
                    standard_single_600x1000: {
                        name: "Standard Single Panel 600x1000mm",
                        dimensions: { width: 1000, height: 600, depth: 55 },
                        rules: [
                            { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                            { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'circulation', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'window', clearances: { above: 50, below: 0, sides: 50 }, zone_type: 'recommended', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'curtain_rail', clearances: { above: 100, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'furniture', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                            { obstacle_type: 'socket', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'safety', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    },
                    standard_double_600x1200: {
                        name: "Standard Double Panel 600x1200mm",
                        dimensions: { width: 1200, height: 600, depth: 110 },
                        rules: [
                            { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                            { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'circulation', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'window', clearances: { above: 50, below: 0, sides: 50 }, zone_type: 'recommended', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'curtain_rail', clearances: { above: 100, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                            { obstacle_type: 'furniture', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                            { obstacle_type: 'socket', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'safety', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                        ]
                    }
                }
            }
        },

        // CYLINDER RULES
        cylinder: {
            general: {
                name: "General Standards",
                models: {
                    standard_150l: {
                        name: "Standard 150L Cylinder",
                        dimensions: { width: 450, height: 1050, depth: 450 },
                        rules: [
                            { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'ceiling', clearances: { above: 450, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 400 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'corner', clearances: { above: 450, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                        ]
                    },
                    standard_250l: {
                        name: "Standard 250L Cylinder",
                        dimensions: { width: 550, height: 1400, depth: 550 },
                        rules: [
                            { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'ceiling', clearances: { above: 450, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 400 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                            { obstacle_type: 'corner', clearances: { above: 450, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                        ]
                    }
                }
            }
        }
    };

    const BOILER_TYPE_KEYS = {
        combi: 'combi_boiler',
        system: 'system_boiler',
        regular: 'regular_boiler'
    };

    function getRuleKeyForState() {
        if (state.equipmentType === 'boiler') {
            return state.boilerType ? BOILER_TYPE_KEYS[state.boilerType] : null;
        }
        return state.equipmentType;
    }

    function getCurrentManufacturers() {
        const ruleKey = getRuleKeyForState();
        return ruleKey ? CLEARANCE_RULES[ruleKey] : null;
    }

    // Obstacle type labels
    const OBSTACLE_LABELS = {
        opening_window: "Opening Window",
        non_opening_window: "Non-Opening Window",
        vent: "Vent / Air Brick",
        door: "Door",
        corner: "Building Corner",
        ground: "Ground Level",
        wall: "Wall",
        ceiling: "Ceiling",
        floor: "Floor",
        window: "Window",
        curtain_rail: "Curtain Rail",
        furniture: "Furniture",
        socket: "Electrical Socket",
        soffit: "Soffit",
        gutter: "Gutter / Downpipe",
        balcony: "Balcony",
        canopy: "Canopy / Overhang",
        pipe: "Pipe",
        duct: "Duct / Vent",
        beam: "Beam / Joist",
        cupboard: "Cupboard / Cabinet",
        skirting_board: "Skirting Board",
        shelf: "Shelf",
        desk: "Desk",
        sofa: "Sofa / Couch",
        tank: "Tank / Water Tank"
    };

    // ============================================
    // PWA & PERSISTENCE FUNCTIONALITY
    // ============================================

    // Register service worker for PWA functionality
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('Service Worker registered:', registration);
            })
            .catch(error => {
                console.log('Service Worker registration failed:', error);
            });
    }

    // Save state to localStorage
    function saveState() {
        try {
            const stateToSave = {
                ...state,
                photo: null, // Don't save the actual image
                photoDataURL: state.photo ? null : null // We'll handle images separately
            };
            localStorage.setItem('clearanceGenieState', JSON.stringify(stateToSave));

            // Save photo separately as data URL if it exists
            if (state.photo) {
                const canvas = document.createElement('canvas');
                canvas.width = state.photo.width;
                canvas.height = state.photo.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(state.photo, 0, 0);
                const photoDataURL = canvas.toDataURL('image/jpeg', 0.8);
                localStorage.setItem('clearanceGeniePhoto', photoDataURL);
            }
        } catch (e) {
            console.error('Error saving state:', e);
        }
    }

    // Restore state from localStorage
    function restoreState() {
        try {
            const savedState = localStorage.getItem('clearanceGenieState');
            const savedPhoto = localStorage.getItem('clearanceGeniePhoto');

            if (savedState) {
                const parsedState = JSON.parse(savedState);

                // Map legacy boiler selections to new boiler type picker
                if (parsedState.equipmentType === 'combi_boiler') {
                    parsedState.equipmentType = 'boiler';
                    parsedState.boilerType = 'combi';
                } else if (parsedState.equipmentType === 'system_boiler') {
                    parsedState.equipmentType = 'boiler';
                    parsedState.boilerType = 'system';
                } else if (parsedState.equipmentType === 'regular_boiler') {
                    parsedState.equipmentType = 'boiler';
                    parsedState.boilerType = 'regular';
                }

                // Restore all state properties except photo
                Object.keys(parsedState).forEach(key => {
                    if (key !== 'photo' && key !== 'photoDataURL') {
                        state[key] = parsedState[key];
                    }
                });

                // Rebuild polygons/bounds for restored obstacles
                state.obstacles = (state.obstacles || []).map(ob => normalizeObstacleGeometry(ob));

                // Restore photo if it exists
                if (savedPhoto) {
                    const img = new Image();
                    img.onload = function() {
                        state.photo = img;
                        // Redraw canvases if needed
                        updateUIAfterRestore();
                    };
                    img.src = savedPhoto;
                } else {
                    updateUIAfterRestore();
                }
            }
        } catch (e) {
            console.error('Error restoring state:', e);
        }
    }

    // ============================================
    // GEOMETRY HELPERS
    // ============================================

    function polygonArea(points) {
        let area = 0;
        for (let i = 0; i < points.length; i++) {
            const current = points[i];
            const next = points[(i + 1) % points.length];
            area += (current.x * next.y) - (next.x * current.y);
        }
        return area / 2;
    }

    function getPolygonBounds(polygon) {
        if (!polygon || polygon.length === 0) return null;
        const xs = polygon.map(p => p.x);
        const ys = polygon.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    function normalizeVector(vec) {
        const length = Math.hypot(vec.x, vec.y) || 1;
        return { x: vec.x / length, y: vec.y / length };
    }

    function lineIntersection(p1, p2, p3, p4) {
        const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
        if (Math.abs(denom) < 1e-6) {
            return p2;
        }
        const det1 = (p1.x * p2.y) - (p1.y * p2.x);
        const det2 = (p3.x * p4.y) - (p3.y * p4.x);
        const x = (det1 * (p3.x - p4.x) - (p1.x - p2.x) * det2) / denom;
        const y = (det1 * (p3.y - p4.y) - (p1.y - p2.y) * det2) / denom;
        return { x, y };
    }

    function offsetPolygon(polygon, distance) {
        if (!polygon || polygon.length < 3) return [];
        if (!distance) return polygon.map(p => ({ ...p }));

        const offsetEdges = [];
        const area = polygonArea(polygon);
        const outward = area >= 0 ? 1 : -1; // Positive area means CCW

        for (let i = 0; i < polygon.length; i++) {
            const current = polygon[i];
            const next = polygon[(i + 1) % polygon.length];
            const edge = { x: next.x - current.x, y: next.y - current.y };
            const unit = normalizeVector(edge);
            const normal = { x: unit.y * outward, y: -unit.x * outward };
            const start = { x: current.x + normal.x * distance, y: current.y + normal.y * distance };
            const end = { x: next.x + normal.x * distance, y: next.y + normal.y * distance };
            offsetEdges.push({ start, end });
        }

        const result = [];
        for (let i = 0; i < offsetEdges.length; i++) {
            const prev = offsetEdges[(i - 1 + offsetEdges.length) % offsetEdges.length];
            const current = offsetEdges[i];
            const intersection = lineIntersection(prev.start, prev.end, current.start, current.end);
            result.push(intersection);
        }

        return result;
    }

    /**
     * Creates a clearance zone boundary with smooth arcs at corners.
     * Returns an object with segments (straight edges) and arcs for rendering.
     * This creates a true radial clearance where every point is exactly 'distance' from the polygon boundary.
     */
    function createClearanceZoneWithArcs(polygon, distance) {
        if (!polygon || polygon.length < 3) return null;
        if (!distance || distance <= 0) return null;

        const area = polygonArea(polygon);
        const outward = area >= 0 ? 1 : -1; // Positive area means CCW, negative CW

        const segments = []; // Array of {start: {x, y}, end: {x, y}}
        const arcs = []; // Array of {center: {x, y}, radius, startAngle, endAngle, counterclockwise}

        for (let i = 0; i < polygon.length; i++) {
            const prevVertex = polygon[(i - 1 + polygon.length) % polygon.length];
            const currentVertex = polygon[i];
            const nextVertex = polygon[(i + 1) % polygon.length];

            // Calculate offset edge for current edge (currentVertex -> nextVertex)
            const edge = { x: nextVertex.x - currentVertex.x, y: nextVertex.y - currentVertex.y };
            const edgeUnit = normalizeVector(edge);
            const edgeNormal = { x: edgeUnit.y * outward, y: -edgeUnit.x * outward };

            const offsetStart = {
                x: currentVertex.x + edgeNormal.x * distance,
                y: currentVertex.y + edgeNormal.y * distance
            };
            const offsetEnd = {
                x: nextVertex.x + edgeNormal.x * distance,
                y: nextVertex.y + edgeNormal.y * distance
            };

            // Calculate angle for arc at currentVertex
            // Previous edge direction
            const prevEdge = { x: currentVertex.x - prevVertex.x, y: currentVertex.y - prevVertex.y };
            const prevEdgeUnit = normalizeVector(prevEdge);

            // Calculate angles for the arc
            // The arc goes from the end of the previous offset edge to the start of current offset edge
            const prevNormal = { x: prevEdgeUnit.y * outward, y: -prevEdgeUnit.x * outward };
            const arcStart = {
                x: currentVertex.x + prevNormal.x * distance,
                y: currentVertex.y + prevNormal.y * distance
            };

            // Calculate start and end angles for the arc
            const startAngle = Math.atan2(arcStart.y - currentVertex.y, arcStart.x - currentVertex.x);
            const endAngle = Math.atan2(offsetStart.y - currentVertex.y, offsetStart.x - currentVertex.x);

            // Determine if we need to go counterclockwise or clockwise
            // For outward offset, we want the arc to go the "short way" around
            let angleDiff = endAngle - startAngle;

            // Normalize angle difference to [-œÄ, œÄ]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            // For outward expansion, we want positive angles (counterclockwise in canvas)
            const useCounterclockwise = outward > 0;

            // Add arc at this vertex
            arcs.push({
                center: { x: currentVertex.x, y: currentVertex.y },
                radius: distance,
                startAngle: startAngle,
                endAngle: endAngle,
                counterclockwise: !useCounterclockwise // Canvas arc direction
            });

            // Add straight segment after this arc
            segments.push({
                start: { x: offsetStart.x, y: offsetStart.y },
                end: { x: offsetEnd.x, y: offsetEnd.y }
            });
        }

        return { segments, arcs };
    }

    /**
     * Draws a clearance zone with smooth arcs at corners.
     * Uses the output from createClearanceZoneWithArcs.
     */
    function drawClearanceZoneWithArcs(ctx, innerPolygon, clearanceDistance, fillStyle, strokeStyle) {
        if (!innerPolygon || innerPolygon.length < 3 || !clearanceDistance) return;

        const clearanceZone = createClearanceZoneWithArcs(innerPolygon, clearanceDistance);
        if (!clearanceZone) return;

        ctx.save();
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';

        // Draw outer boundary (clearance zone boundary)
        ctx.beginPath();

        // Start from first arc
        if (clearanceZone.arcs.length > 0 && clearanceZone.segments.length > 0) {
            const firstArc = clearanceZone.arcs[0];
            const startX = firstArc.center.x + Math.cos(firstArc.startAngle) * firstArc.radius;
            const startY = firstArc.center.y + Math.sin(firstArc.startAngle) * firstArc.radius;
            ctx.moveTo(startX, startY);

            // Draw all arcs and segments
            for (let i = 0; i < clearanceZone.arcs.length; i++) {
                const arc = clearanceZone.arcs[i];
                const segment = clearanceZone.segments[i];

                // Draw arc at vertex
                ctx.arc(arc.center.x, arc.center.y, arc.radius, arc.startAngle, arc.endAngle, arc.counterclockwise);

                // Draw straight segment
                ctx.lineTo(segment.end.x, segment.end.y);
            }
        }
        ctx.closePath();

        // Draw inner boundary (original polygon) in reverse for evenodd fill
        ctx.moveTo(innerPolygon[0].x, innerPolygon[0].y);
        for (let i = innerPolygon.length - 1; i >= 0; i--) {
            ctx.lineTo(innerPolygon[i].x, innerPolygon[i].y);
        }
        ctx.closePath();

        // Fill the ring using evenodd rule
        ctx.fill('evenodd');
        ctx.stroke();
        ctx.restore();
    }

    function tracePolygon(ctx, polygon) {
        if (!polygon || polygon.length === 0) return;
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
            ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.closePath();
    }

    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3) return false;
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            const intersect = ((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 1e-6) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function segmentsIntersect(p1, p2, q1, q2) {
        function cross(a, b, c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }
        const d1 = cross(p1, p2, q1);
        const d2 = cross(p1, p2, q2);
        const d3 = cross(q1, q2, p1);
        const d4 = cross(q1, q2, p2);

        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
            return true;
        }

        const onSegment = (a, b, c) => Math.min(a.x, b.x) <= c.x && c.x <= Math.max(a.x, b.x) &&
            Math.min(a.y, b.y) <= c.y && c.y <= Math.max(a.y, b.y);

        return (d1 === 0 && onSegment(p1, p2, q1)) ||
            (d2 === 0 && onSegment(p1, p2, q2)) ||
            (d3 === 0 && onSegment(q1, q2, p1)) ||
            (d4 === 0 && onSegment(q1, q2, p2));
    }

    function polygonIntersectsRect(polygon, rect) {
        if (!polygon || polygon.length < 3 || !rect) return false;
        const rectPoints = [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.width, y: rect.y },
            { x: rect.x + rect.width, y: rect.y + rect.height },
            { x: rect.x, y: rect.y + rect.height }
        ];

        // Check if any rectangle corner is inside the polygon
        if (rectPoints.some(p => isPointInPolygon(p, polygon))) return true;

        // Check if any polygon vertex is inside the rectangle
        const pointInRect = (p) => p.x >= rect.x && p.x <= rect.x + rect.width && p.y >= rect.y && p.y <= rect.y + rect.height;
        if (polygon.some(pointInRect)) return true;

        // Check edge intersections
        const rectEdges = [
            [rectPoints[0], rectPoints[1]],
            [rectPoints[1], rectPoints[2]],
            [rectPoints[2], rectPoints[3]],
            [rectPoints[3], rectPoints[0]]
        ];

        for (let i = 0; i < polygon.length; i++) {
            const p1 = polygon[i];
            const p2 = polygon[(i + 1) % polygon.length];
            for (const [r1, r2] of rectEdges) {
                if (segmentsIntersect(p1, p2, r1, r2)) return true;
            }
        }

        return false;
    }

    function drawClearanceRing(ctx, innerPolygon, outerPolygon, fillStyle, strokeStyle) {
        if (!innerPolygon || !outerPolygon || innerPolygon.length < 3 || outerPolygon.length < 3) return;
        ctx.save();
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';

        ctx.beginPath();
        ctx.moveTo(outerPolygon[0].x, outerPolygon[0].y);
        for (let i = 1; i < outerPolygon.length; i++) {
            ctx.lineTo(outerPolygon[i].x, outerPolygon[i].y);
        }
        ctx.closePath();

        ctx.moveTo(innerPolygon[0].x, innerPolygon[0].y);
        for (let i = 1; i < innerPolygon.length; i++) {
            ctx.lineTo(innerPolygon[i].x, innerPolygon[i].y);
        }
        ctx.closePath();

        ctx.fill('evenodd');
        ctx.stroke();
        ctx.restore();
    }

    function createPolygonFromBounds(bounds) {
        if (!bounds) return null;
        return [
            { x: bounds.x, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
            { x: bounds.x, y: bounds.y + bounds.height }
        ];
    }

    function createPolygonFromCircle(circle, segments = 32) {
        if (!circle) return null;
        const points = [];
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            points.push({
                x: circle.centerX + Math.cos(angle) * circle.radius,
                y: circle.centerY + Math.sin(angle) * circle.radius
            });
        }
        return points;
    }

    function updateBoundsFromPolygon(obstacle) {
        if (obstacle.polygon && obstacle.polygon.length > 2) {
            obstacle.bounds = getPolygonBounds(obstacle.polygon);
        }
    }

    function normalizeObstacleGeometry(obstacle) {
        if (!obstacle) return obstacle;

        // Build polygon representations for each shape
        if (obstacle.shape === 'rectangle' || !obstacle.shape) {
            if (!obstacle.polygon && obstacle.bounds) {
                obstacle.polygon = createPolygonFromBounds(obstacle.bounds);
            }
        } else if (obstacle.shape === 'polygon') {
            // Polygon shape already has polygon data from AI detection
            // Just ensure bounds are calculated if not present
            if (!obstacle.bounds && obstacle.polygon) {
                updateBoundsFromPolygon(obstacle);
            }
        } else if (obstacle.shape === 'line' && obstacle.line) {
            if (!obstacle.polygon) {
                const thickness = 6;
                const lineVec = { x: obstacle.line.x2 - obstacle.line.x1, y: obstacle.line.y2 - obstacle.line.y1 };
                const unit = normalizeVector(lineVec);
                const normal = { x: -unit.y, y: unit.x };
                obstacle.polygon = [
                    { x: obstacle.line.x1 + normal.x * thickness, y: obstacle.line.y1 + normal.y * thickness },
                    { x: obstacle.line.x2 + normal.x * thickness, y: obstacle.line.y2 + normal.y * thickness },
                    { x: obstacle.line.x2 - normal.x * thickness, y: obstacle.line.y2 - normal.y * thickness },
                    { x: obstacle.line.x1 - normal.x * thickness, y: obstacle.line.y1 - normal.y * thickness }
                ];
            }
        } else if (obstacle.shape === 'circle' && obstacle.circle) {
            if (!obstacle.polygon) {
                obstacle.polygon = createPolygonFromCircle(obstacle.circle, 32);
            }
            obstacle.bounds = obstacle.bounds || {
                x: obstacle.circle.centerX - obstacle.circle.radius,
                y: obstacle.circle.centerY - obstacle.circle.radius,
                width: obstacle.circle.radius * 2,
                height: obstacle.circle.radius * 2
            };
        } else if (obstacle.shape === 'mask' && obstacle.maskStrokes) {
            const allPoints = obstacle.maskStrokes.flatMap(ms => ms.stroke || []);
            if (allPoints.length > 0) {
                const xs = allPoints.map(p => p.x);
                const ys = allPoints.map(p => p.y);
                const bounds = {
                    x: Math.min(...xs),
                    y: Math.min(...ys),
                    width: Math.max(...xs) - Math.min(...xs),
                    height: Math.max(...ys) - Math.min(...ys)
                };
                obstacle.bounds = obstacle.bounds || bounds;
                obstacle.polygon = obstacle.polygon || createPolygonFromBounds(bounds);
            }
        }

        if (!obstacle.bounds && obstacle.polygon) {
            updateBoundsFromPolygon(obstacle);
        }

        return obstacle;
    }

    function getObstaclePolygon(obstacle) {
        if (!obstacle) return null;
        normalizeObstacleGeometry(obstacle);
        return obstacle.polygon || null;
    }

    function getObstacleBounds(obstacle) {
        if (!obstacle) return null;
        if (obstacle.bounds) return obstacle.bounds;
        const polygon = getObstaclePolygon(obstacle);
        return polygon ? getPolygonBounds(polygon) : null;
    }

    // Update UI after restoring state
    function updateUIAfterRestore() {
        if (state.equipmentType) {
            // Highlight selected equipment type
            document.querySelectorAll('.equipment-type-btn').forEach(btn => {
                if (btn.getAttribute('data-equipment-type') === state.equipmentType) {
                    btn.classList.add('active');
                    const info = EQUIPMENT_INFO[state.equipmentType];
                    document.getElementById('equipmentInfo').innerHTML = `
                        <strong>${info.icon} ${info.name}:</strong> ${info.description}
                    `;
                }
            });

            // Show appropriate step based on progress
            if (state.brand && state.model) {
                // User was on results step
                document.getElementById('step0').classList.add('hidden');
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.add('hidden');
                document.getElementById('step3').classList.add('hidden');
                document.getElementById('step4').classList.add('hidden');
                document.getElementById('step5').classList.add('hidden');
                document.getElementById('step6').classList.remove('hidden');
                showResults();
            } else if (state.obstacles && state.obstacles.length > 0) {
                // User was marking obstacles
                document.getElementById('step0').classList.add('hidden');
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.add('hidden');
                document.getElementById('step3').classList.add('hidden');
                document.getElementById('step4').classList.remove('hidden');
            } else if (state.equipment) {
                // User marked equipment position
                document.getElementById('step0').classList.add('hidden');
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.add('hidden');
                document.getElementById('step3').classList.remove('hidden');
            } else if (state.scale.pixelsPerMM > 0) {
                // User calibrated scale
                document.getElementById('step0').classList.add('hidden');
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
            } else if (state.photo) {
                // User uploaded photo
                document.getElementById('step0').classList.add('hidden');
                document.getElementById('step1').classList.remove('hidden');
            }
        }
    }

    // Auto-save on state changes (debounced)
    let saveTimeout;
    function autoSave() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(saveState, 500);
    }

    // Start Over function
    function startOver() {
        if (confirm('Are you sure you want to start over? All progress will be lost.')) {
            // Clear localStorage
            localStorage.removeItem('clearanceGenieState');
            localStorage.removeItem('clearanceGeniePhoto');

            // Reload the page
            window.location.reload();
        }
    }

    // Restore state on page load
    restoreState();

    // ============================================
    // OBJECT EDITING FUNCTIONALITY
    // ============================================

    // Check if a point is inside an object
    function isPointInObject(x, y, obj) {
        if (!obj) return false;

        // Check if it's the equipment point
        if (obj.x !== undefined && obj.y !== undefined) {
            const dist = Math.sqrt((x - obj.x) ** 2 + (y - obj.y) ** 2);
            return dist <= getEquipmentRenderRadius();
        }

        // Check obstacle based on shape
        const polygon = getObstaclePolygon(obj);
        if (polygon && polygon.length >= 3) {
            return isPointInPolygon({ x, y }, polygon);
        }

        if (obj.shape === 'line' && obj.line) {
            const dist = distanceToLineSegment(x, y, obj.line.x1, obj.line.y1, obj.line.x2, obj.line.y2);
            return dist <= 10;
        } else if (obj.shape === 'circle' && obj.circle) {
            const dist = Math.sqrt((x - obj.circle.centerX) ** 2 + (y - obj.circle.centerY) ** 2);
            return Math.abs(dist - obj.circle.radius) <= 10; // Near the circle edge
        } else if (obj.shape === 'mask' && obj.maskStrokes) {
            return obj.maskStrokes.some(maskStroke => isPointNearStroke(x, y, maskStroke));
        }

        return false;
    }

    // Distance from point to line segment
    function distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;

        return Math.sqrt(dx * dx + dy * dy);
    }

    function isPointNearStroke(x, y, maskStroke) {
        if (!maskStroke || !maskStroke.stroke || maskStroke.stroke.length === 0) return false;
        const tolerance = Math.max(10, maskStroke.brushSize);
        return maskStroke.stroke.some(point => {
            const dx = x - point.x;
            const dy = y - point.y;
            return Math.sqrt(dx * dx + dy * dy) <= tolerance;
        });
    }

    function buildMaskStrokesForBounds(bounds) {
        const strokes = [];

        state.paintMasks.forEach(mask => {
            const filtered = mask.stroke.filter(point => (
                point.x >= bounds.x - mask.brushSize &&
                point.x <= bounds.x + bounds.width + mask.brushSize &&
                point.y >= bounds.y - mask.brushSize &&
                point.y <= bounds.y + bounds.height + mask.brushSize
            ));

            if (filtered.length > 1) {
                strokes.push({
                    stroke: filtered.map(p => ({ ...p })),
                    brushSize: mask.brushSize
                });
            }
        });

        // Fallback: create a rectangle stroke so the obstacle remains visible
        if (strokes.length === 0) {
            strokes.push({
                stroke: [
                    { x: bounds.x, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y }
                ],
                brushSize: 8
            });
        }

        return strokes;
    }

    // Find object at position
    function findObjectAtPosition(x, y) {
        // Check equipment first
        if (state.equipment && isPointInObject(x, y, state.equipment)) {
            return { type: 'equipment', index: null };
        }

        // Check obstacles
        for (let i = state.obstacles.length - 1; i >= 0; i--) {
            if (isPointInObject(x, y, state.obstacles[i])) {
                return { type: 'obstacle', index: i };
            }
        }

        return null;
    }

    // Move object by delta
    function moveObject(objectRef, dx, dy) {
        if (objectRef.type === 'equipment') {
            state.equipment.x += dx;
            state.equipment.y += dy;
        } else if (objectRef.type === 'obstacle') {
            const obstacle = state.obstacles[objectRef.index];
            if (obstacle.polygon) {
                obstacle.polygon = obstacle.polygon.map(p => ({ x: p.x + dx, y: p.y + dy }));
                updateBoundsFromPolygon(obstacle);
            } else if (obstacle.bounds) {
                obstacle.bounds.x += dx;
                obstacle.bounds.y += dy;
            }
            if (obstacle.line) {
                obstacle.line.x1 += dx;
                obstacle.line.y1 += dy;
                obstacle.line.x2 += dx;
                obstacle.line.y2 += dy;
            }
            if (obstacle.circle) {
                obstacle.circle.centerX += dx;
                obstacle.circle.centerY += dy;
            }
            if (obstacle.maskStrokes) {
                obstacle.maskStrokes.forEach(maskStroke => {
                    maskStroke.stroke = maskStroke.stroke.map(point => ({
                        x: point.x + dx,
                        y: point.y + dy
                    }));
                });
            }
        }
    }

    // Arrow key controls
    document.addEventListener('keydown', function(e) {
        if (!state.selectedObject) return;

        const step = e.shiftKey ? 10 : 1; // Shift for larger steps
        let handled = false;

        switch(e.key) {
            case 'ArrowUp':
                moveObject(state.selectedObject, 0, -step);
                handled = true;
                break;
            case 'ArrowDown':
                moveObject(state.selectedObject, 0, step);
                handled = true;
                break;
            case 'ArrowLeft':
                moveObject(state.selectedObject, -step, 0);
                handled = true;
                break;
            case 'ArrowRight':
                moveObject(state.selectedObject, step, 0);
                handled = true;
                break;
            case 'Escape':
                state.selectedObject = null;
                hideObjectEditor();
                handled = true;
                break;
        }

        if (handled) {
            e.preventDefault();
            redrawCurrentCanvas();
            autoSave();
        }
    });

    // Show object editor UI
    function showObjectEditor(objectRef) {
        let editorHTML = '';

        if (objectRef.type === 'equipment') {
            let sizeEditorHTML = '';

            // Add size selector for cylinders
            if (state.equipmentType === 'cylinder') {
                sizeEditorHTML = `
                    <div class="size-editor">
                        <label for="cylinderSizeSelect">Cylinder Size:</label>
                        <select id="cylinderSizeSelect" onchange="updateCylinderSize(this.value)">
                            <option value="90L" ${state.cylinderSize === '90L' ? 'selected' : ''}>90 Liters</option>
                            <option value="120L" ${state.cylinderSize === '120L' ? 'selected' : ''}>120 Liters</option>
                            <option value="150L" ${state.cylinderSize === '150L' ? 'selected' : ''}>150 Liters</option>
                            <option value="180L" ${state.cylinderSize === '180L' ? 'selected' : ''}>180 Liters</option>
                            <option value="210L" ${state.cylinderSize === '210L' ? 'selected' : ''}>210 Liters</option>
                            <option value="250L" ${state.cylinderSize === '250L' ? 'selected' : ''}>250 Liters</option>
                            <option value="300L" ${state.cylinderSize === '300L' ? 'selected' : ''}>300 Liters</option>
                        </select>
                    </div>
                `;
            }

            // Add size selector for radiators
            if (state.equipmentType === 'radiator') {
                const sizeOptions = RADIATOR_SIZES.map(size => {
                    const label = size.replace('x', '√ó');
                    const selected = state.radiatorSize === size ? 'selected' : '';
                    return `<option value="${size}" ${selected}>${label} mm</option>`;
                }).join('');
                const makeOptions = RADIATOR_MAKES.map(make => {
                    const selected = state.radiatorMake === make ? 'selected' : '';
                    return `<option value="${make}" ${selected}>${make}</option>`;
                }).join('');
                const typeOptions = RADIATOR_TYPES.map(type => {
                    const selected = state.radiatorType === type.value ? 'selected' : '';
                    return `<option value="${type.value}" ${selected}>${type.label}</option>`;
                }).join('');
                sizeEditorHTML = `
                    <div class="size-editor">
                        <label for="radiatorMakeSelect">Radiator Make:</label>
                        <select id="radiatorMakeSelect" onchange="updateRadiatorMake(this.value)">${makeOptions}</select>
                        <label for="radiatorTypeSelect">Radiator Type:</label>
                        <select id="radiatorTypeSelect" onchange="updateRadiatorType(this.value)">${typeOptions}</select>
                        <label for="radiatorSizeSelect">Radiator Size (W√óH mm):</label>
                        <select id="radiatorSizeSelect" onchange="updateRadiatorSize(this.value)">${sizeOptions}</select>
                        <p style="margin-top: 6px; font-size: 12px; color: #555;">Based on November 2025 price book. Not all sizes are available for every make or type; Stelrad has the broadest coverage.</p>
                    </div>
                `;
            }

            editorHTML = `
                <div class="object-editor" id="objectEditor">
                    <h3>Edit Equipment Position</h3>
                    <div class="drag-hint">
                        üëÜ Tap and drag on the canvas to move, or use arrow keys for precise positioning (Shift for larger steps)
                    </div>
                    <div class="arrow-controls">
                        <button class="arrow-btn" style="grid-column: 2;" onclick="moveSelectedObject(0, -5)">‚Üë</button>
                        <button class="arrow-btn" onclick="moveSelectedObject(-5, 0)">‚Üê</button>
                        <button class="arrow-btn" onclick="deselectObject()">‚äó</button>
                        <button class="arrow-btn" onclick="moveSelectedObject(5, 0)">‚Üí</button>
                        <button class="arrow-btn" style="grid-column: 2;" onclick="moveSelectedObject(0, 5)">‚Üì</button>
                    </div>
                    ${sizeEditorHTML}
                </div>
            `;
        } else if (objectRef.type === 'obstacle') {
            const obstacle = state.obstacles[objectRef.index];
            const typeLabel = OBSTACLE_LABELS[obstacle.type] || obstacle.type;
            editorHTML = `
                <div class="object-editor" id="objectEditor">
                    <h3>Edit ${typeLabel}</h3>
                    <div class="drag-hint">
                        üëÜ Tap and drag on the canvas to move, or use arrow keys for precise positioning (Shift for larger steps)
                    </div>
                    <div class="arrow-controls">
                        <button class="arrow-btn" style="grid-column: 2;" onclick="moveSelectedObject(0, -5)">‚Üë</button>
                        <button class="arrow-btn" onclick="moveSelectedObject(-5, 0)">‚Üê</button>
                        <button class="arrow-btn" onclick="deselectObject()">‚äó</button>
                        <button class="arrow-btn" onclick="moveSelectedObject(5, 0)">‚Üí</button>
                        <button class="arrow-btn" style="grid-column: 2;" onclick="moveSelectedObject(0, 5)">‚Üì</button>
                    </div>
                    <button onclick="deleteSelectedObject()" style="background: #e74c3c; margin-top: 10px;">Delete ${typeLabel}</button>
                </div>
            `;
        }

        // Insert editor before the appropriate step
        const existingEditor = document.getElementById('objectEditor');
        if (existingEditor) existingEditor.remove();

        const step4 = document.getElementById('step4');
        if (step4 && !step4.classList.contains('hidden')) {
            step4.insertAdjacentHTML('afterbegin', editorHTML);
        }
    }

    function hideObjectEditor() {
        const editor = document.getElementById('objectEditor');
        if (editor) editor.remove();
    }

    function moveSelectedObject(dx, dy) {
        if (state.selectedObject) {
            moveObject(state.selectedObject, dx, dy);
            redrawCurrentCanvas();
            autoSave();
        }
    }

    function deselectObject() {
        state.selectedObject = null;
        hideObjectEditor();
        redrawCurrentCanvas();
    }

    function deleteSelectedObject() {
        if (state.selectedObject && state.selectedObject.type === 'obstacle') {
            if (confirm('Delete this obstacle?')) {
                state.obstacles.splice(state.selectedObject.index, 1);
                state.selectedObject = null;
                hideObjectEditor();
                updateObstacleList();
                redrawCurrentCanvas();
                autoSave();
            }
        }
    }

    function redrawCurrentCanvas() {
        // Find which canvas is currently visible and redraw it
        const canvas3 = document.getElementById('photoCanvas3');
        const canvas4 = document.getElementById('photoCanvas4');

        if (canvas3 && !document.getElementById('step4').classList.contains('hidden')) {
            const ctx = canvas3.getContext('2d');
            drawPhotoWithObstacles(ctx);
        } else if (canvas4 && !document.getElementById('step6').classList.contains('hidden')) {
            showResults(); // This redraws the results canvas
        }
    }

    // Update cylinder size
    function updateCylinderSize(size) {
        state.cylinderSize = size;
        autoSave();
    }

    // Update radiator size
    function updateRadiatorSize(size) {
        state.radiatorSize = size;
        autoSave();
    }

    // Update radiator make
    function updateRadiatorMake(make) {
        state.radiatorMake = make;
        autoSave();
    }

    // Update radiator type
    function updateRadiatorType(type) {
        state.radiatorType = type;
        autoSave();
    }

    // Show model editor in results
    function showModelEditorInResults() {
        const editorSection = document.getElementById('modelEditorSection');
        const brandSelect = document.getElementById('brandSelectResults');
        const modelSelect = document.getElementById('modelSelectResults');
        const boilerTypeGroup = document.getElementById('boilerTypeResultsGroup');

        if (state.equipmentType === 'boiler') {
            boilerTypeGroup.style.display = 'block';
            document.getElementById('boilerTypeResults').value = state.boilerType || '';
        } else {
            boilerTypeGroup.style.display = 'none';
        }

        // Populate brand options
        const brands = getCurrentManufacturers();
        brandSelect.innerHTML = '';
        if (brands) {
            for (const [brandKey, brandData] of Object.entries(brands)) {
                const option = document.createElement('option');
                option.value = brandKey;
                option.textContent = brandData.name;
                option.selected = state.brand === brandKey;
                brandSelect.appendChild(option);
            }
        }

        // Populate model options for current brand
        updateModelOptionsInResults();

        // Show the editor
        editorSection.style.display = 'block';
    }

    function updateModelOptionsInResults() {
        const modelSelect = document.getElementById('modelSelectResults');
        const brandSelect = document.getElementById('brandSelectResults');
        const selectedBrand = brandSelect.value;

        modelSelect.innerHTML = '';
        const manufacturers = getCurrentManufacturers();
        const models = manufacturers?.[selectedBrand]?.models;
        if (models) {
            const modelEntries = Object.entries(models);
            const hasExistingSelection = state.model && models[state.model];

            for (const [modelKey, modelData] of modelEntries) {
                const option = document.createElement('option');
                option.value = modelKey;
                option.textContent = modelData.name;
                option.selected = state.model === modelKey;
                modelSelect.appendChild(option);
            }

            if (!hasExistingSelection && modelEntries.length > 0) {
                state.model = modelEntries[0][0];
                modelSelect.value = state.model;
            }
        }
    }

    function updateBrandSelection() {
        const brandSelect = document.getElementById('brandSelectResults');
        state.brand = brandSelect.value;
        updateModelOptionsInResults();

        // Auto-select first model
        const modelSelect = document.getElementById('modelSelectResults');
        state.model = modelSelect.value;

        // Redraw results
        showResults();
        autoSave();
    }

    function updateModelSelection() {
        const modelSelect = document.getElementById('modelSelectResults');
        state.model = modelSelect.value;

        // Redraw results
        showResults();
        autoSave();
    }

    function updateBoilerTypeSelectionInResults() {
        const selectedType = document.getElementById('boilerTypeResults').value;
        state.boilerType = selectedType || null;
        state.brand = null;
        state.model = null;

        // Rebuild brand/model options based on new type
        const brandSelect = document.getElementById('brandSelectResults');
        brandSelect.innerHTML = '';
        const manufacturers = getCurrentManufacturers();
        if (manufacturers) {
            const brandEntries = Object.entries(manufacturers);
            for (const [brandKey, brandData] of brandEntries) {
                const option = document.createElement('option');
                option.value = brandKey;
                option.textContent = brandData.name;
                brandSelect.appendChild(option);
            }
            if (brandEntries.length > 0) {
                state.brand = brandEntries[0][0];
                brandSelect.value = state.brand;
            }
        }

        updateModelOptionsInResults();
        showResults();
        autoSave();
    }

    function hideModelEditor() {
        document.getElementById('modelEditorSection').style.display = 'none';
    }

    // Step 0: Equipment Type Selection
    function selectEquipmentType(type, clickedButton) {
        state.equipmentType = type;

        if (type !== 'boiler') {
            state.boilerType = null;
        }
        state.brand = null;
        state.model = null;

        // Update active button
        document.querySelectorAll('.equipment-type-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        if (clickedButton) {
            clickedButton.classList.add('active');
        }

        // Update info box
        const info = EQUIPMENT_INFO[type];
        document.getElementById('equipmentInfo').innerHTML = `
            <strong>${info.icon} ${info.name}:</strong> ${info.description}
        `;

        // Save state
        autoSave();

        // Show next step button
        setTimeout(() => {
            document.getElementById('step0').classList.add('hidden');
            document.getElementById('step1').classList.remove('hidden');
        }, 500);
    }

    // Attach event listeners to equipment type buttons
    document.querySelectorAll('.equipment-type-btn').forEach(btn => {
        // Handle both click and touch events
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const type = this.getAttribute('data-equipment-type');
            selectEquipmentType(type, this);
        });

        // Also handle touchend for better mobile support
        btn.addEventListener('touchend', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const type = this.getAttribute('data-equipment-type');
            selectEquipmentType(type, this);
        });
    });

    // Utility: Get canvas coordinates from touch/click event
    function getCanvasCoordinates(canvas, event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // Step 1: Photo Upload (handles both camera and file upload)
    function handlePhotoUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                state.photo = img;
                state.photoWidth = img.width;
                state.photoHeight = img.height;

                autoSave();

                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
                setupScaleCanvas();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('photoCameraInput').addEventListener('change', handlePhotoUpload);
    document.getElementById('photoUploadInput').addEventListener('change', handlePhotoUpload);

    // Step 2: Scale Calibration
    function setupScaleCanvas() {
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        drawPhotoAndPoints(ctx);

        // Add magnifying glass on hover/touch (no click handlers - only button marks positions)
        canvas.addEventListener('mousemove', handleMagnifyMove);
        canvas.addEventListener('mouseenter', showMagnifier);
        canvas.addEventListener('mouseleave', hideMagnifier);
        canvas.addEventListener('touchmove', handleMagnifyTouch);
        canvas.addEventListener('touchstart', showMagnifierTouch);
        // Note: No touchend handler - magnifier stays visible for button click

        // Add button click/touch handlers for marking positions
        // Support both touch and click events for better mobile reliability
        const markBtn = document.getElementById('markPositionBtn');
        let touchHandled = false;

        markBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            touchHandled = true;
            handleMarkPositionClick(e);
            // Reset flag after a short delay to allow click event filtering
            setTimeout(() => { touchHandled = false; }, 300);
        });

        markBtn.addEventListener('click', (e) => {
            // Prevent double-firing on devices that emit both touch and click
            if (touchHandled) {
                e.preventDefault();
                return;
            }
            handleMarkPositionClick(e);
        });

        // Add zoom slider handler
        const zoomSlider = document.getElementById('zoomSlider');
        zoomSlider.addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = e.target.value;
        });

        // Add magnifying glass control handlers
        document.getElementById('magnifyEnabled').addEventListener('change', (e) => {
            state.magnifyEnabled = e.target.checked;
            if (!state.magnifyEnabled) {
                hideMagnifier();
            }
        });

        document.querySelectorAll('input[name="magnifyHand"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.magnifyHandedness = e.target.value;
            });
        });
    }

    function showMagnifier() {
        if (!state.magnifyEnabled) return;
        document.getElementById('magnifyingGlass').style.display = 'block';
        document.getElementById('zoomSliderContainer').style.display = 'block';
    }

    function hideMagnifier() {
        document.getElementById('magnifyingGlass').style.display = 'none';
        document.getElementById('zoomSliderContainer').style.display = 'none';
    }

    function showMagnifierTouch(e) {
        // Don't prevent default here - let touchmove handle it
        showMagnifier();
    }

    function handleMagnifyMove(e) {
        if (!state.magnifyEnabled) return;

        const canvas = document.getElementById('photoCanvas');
        const magnifier = document.getElementById('magnifyingGlass');
        const magnifyCanvas = document.getElementById('magnifyCanvas');
        const magnifyCtx = magnifyCanvas.getContext('2d');
        const zoomSliderContainer = document.getElementById('zoomSliderContainer');

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Position magnifier near cursor (offset based on handedness to avoid blocking view)
        const offsetX = state.magnifyHandedness === 'left' ? -170 : 20; // Left: move to left, Right: move to right
        const magnifierLeft = e.clientX - rect.left + offsetX;
        const magnifierTop = e.clientY - rect.top - 80;
        magnifier.style.left = magnifierLeft + 'px';
        magnifier.style.top = magnifierTop + 'px';

        // Position zoom slider below magnifier
        zoomSliderContainer.style.left = magnifierLeft + 'px';
        zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

        // Get canvas coordinates
        const canvasX = (x * canvas.width) / rect.width;
        const canvasY = (y * canvas.height) / rect.height;

        // Store current canvas position for button click handler
        state.currentMagnifierPosition = { canvasX, canvasY };

        // Draw magnified portion (use zoom slider value)
        const zoom = parseFloat(document.getElementById('zoomSlider').value);
        const magRadius = 75; // Half of magnifier size
        const sourceSize = magRadius / zoom;

        magnifyCtx.clearRect(0, 0, 150, 150);
        magnifyCtx.drawImage(
            state.photo,
            Math.max(0, canvasX - sourceSize),
            Math.max(0, canvasY - sourceSize),
            sourceSize * 2,
            sourceSize * 2,
            0, 0, 150, 150
        );
    }

    function handleMagnifyTouch(e) {
        e.preventDefault();
        if (!state.magnifyEnabled) return;

        if (e.touches.length > 0) {
            const canvas = document.getElementById('photoCanvas');
            const magnifier = document.getElementById('magnifyingGlass');
            const magnifyCanvas = document.getElementById('magnifyCanvas');
            const magnifyCtx = magnifyCanvas.getContext('2d');
            const zoomSliderContainer = document.getElementById('zoomSliderContainer');

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Show magnifier
            magnifier.style.display = 'block';
            zoomSliderContainer.style.display = 'block';

            // Position magnifier above/beside touch point based on handedness
            const offsetX = state.magnifyHandedness === 'left' ? -170 : 20;
            const magnifierLeft = touch.clientX - rect.left + offsetX;
            const magnifierTop = touch.clientY - rect.top - 180;
            magnifier.style.left = magnifierLeft + 'px';
            magnifier.style.top = magnifierTop + 'px';

            // Position zoom slider below magnifier (but above touch point)
            zoomSliderContainer.style.left = magnifierLeft + 'px';
            zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

            // Get canvas coordinates
            const canvasX = (x * canvas.width) / rect.width;
            const canvasY = (y * canvas.height) / rect.height;

            // Store current canvas position for button click handler
            state.currentMagnifierPosition = { canvasX, canvasY };

            // Draw magnified portion (use zoom slider value)
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            const magRadius = 75;
            const sourceSize = magRadius / zoom;

            magnifyCtx.clearRect(0, 0, 150, 150);
            magnifyCtx.drawImage(
                state.photo,
                Math.max(0, canvasX - sourceSize),
                Math.max(0, canvasY - sourceSize),
                sourceSize * 2,
                sourceSize * 2,
                0, 0, 150, 150
            );
        }
    }

    // Mark position button click handler (triggered when user clicks the center button)
    function handleMarkPositionClick(e) {
        e.stopPropagation(); // Prevent event bubbling

        if (!state.currentMagnifierPosition) {
            return; // No position stored yet
        }

        const coords = {
            x: state.currentMagnifierPosition.canvasX,
            y: state.currentMagnifierPosition.canvasY
        };

        handleScalePoint(coords);

        // Keep magnifier visible for marking the second point
        // User can reposition by touching/moving on the canvas again
    }

    // Set calibration mode (2-point or 4-point)
    function setCalibrationMode(mode) {
        state.scale.calibrationMode = mode;

        // Reset all points
        state.scale.point1 = null;
        state.scale.point2 = null;
        state.scale.point3 = null;
        state.scale.point4 = null;
        state.scale.perspectiveWarning = false;

        // Update UI
        if (mode === 'two-point') {
            document.getElementById('twoPointModeBtn').style.background = '#3498db';
            document.getElementById('fourPointModeBtn').style.background = '#95a5a6';
            document.getElementById('twoPointInstructions').style.display = 'block';
            document.getElementById('fourPointInstructions').style.display = 'none';
            document.getElementById('perspectiveWarningDiv').style.display = 'none';
            document.getElementById('knownDistance').parentElement.parentElement.style.display = 'block';
        } else {
            document.getElementById('twoPointModeBtn').style.background = '#95a5a6';
            document.getElementById('fourPointModeBtn').style.background = '#3498db';
            document.getElementById('twoPointInstructions').style.display = 'none';
            document.getElementById('fourPointInstructions').style.display = 'block';
            document.getElementById('knownDistance').parentElement.parentElement.style.display = 'none';
        }

        // Reset UI states
        resetCalibrationUI();

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    function resetCalibrationUI() {
        // 2-point mode
        document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
        document.getElementById('point1Status').style.color = '#e74c3c';
        document.getElementById('undoPoint1Btn').style.display = 'none';
        document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
        document.getElementById('point2Status').style.color = '#95a5a6';
        document.getElementById('undoPoint2Btn').style.display = 'none';

        // 4-point mode
        document.getElementById('point1Status4pt').textContent = 'Not set';
        document.getElementById('point1Status4pt').style.color = '#e74c3c';
        document.getElementById('undoPoint1Btn4pt').style.display = 'none';
        document.getElementById('point2Status4pt').textContent = 'Waiting...';
        document.getElementById('point2Status4pt').style.color = '#95a5a6';
        document.getElementById('undoPoint2Btn4pt').style.display = 'none';
        document.getElementById('point3Status4pt').textContent = 'Waiting...';
        document.getElementById('point3Status4pt').style.color = '#95a5a6';
        document.getElementById('undoPoint3Btn4pt').style.display = 'none';
        document.getElementById('point4Status4pt').textContent = 'Waiting...';
        document.getElementById('point4Status4pt').style.color = '#95a5a6';
        document.getElementById('undoPoint4Btn4pt').style.display = 'none';

        document.getElementById('confirmScaleBtn').disabled = true;
    }

    function handleScalePoint(coords) {
        // Show the manual calibration guide when user starts clicking button
        const guide = document.getElementById('manualCalibrationGuide');
        guide.style.display = 'block';

        if (state.scale.calibrationMode === 'two-point') {
            // 2-POINT MODE
            if (!state.scale.point1) {
                state.scale.point1 = coords;
                document.getElementById('point1Status').textContent = '‚úì Set';
                document.getElementById('point1Status').style.color = '#2e7d32';
                document.getElementById('undoPoint1Btn').style.display = 'inline-block';
                document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
                document.getElementById('point2Status').style.color = '#e74c3c';
            } else if (!state.scale.point2) {
                state.scale.point2 = coords;
                document.getElementById('confirmScaleBtn').disabled = false;
                document.getElementById('point2Status').textContent = '‚úì Set';
                document.getElementById('point2Status').style.color = '#2e7d32';
                document.getElementById('undoPoint2Btn').style.display = 'inline-block';
            }
        } else {
            // 4-POINT MODE (corners of credit card)
            if (!state.scale.point1) {
                state.scale.point1 = coords;
                document.getElementById('point1Status4pt').textContent = '‚úì Set';
                document.getElementById('point1Status4pt').style.color = '#2e7d32';
                document.getElementById('undoPoint1Btn4pt').style.display = 'inline-block';
                document.getElementById('point2Status4pt').textContent = 'Mark top-right corner';
                document.getElementById('point2Status4pt').style.color = '#e74c3c';
            } else if (!state.scale.point2) {
                state.scale.point2 = coords;
                document.getElementById('point2Status4pt').textContent = '‚úì Set';
                document.getElementById('point2Status4pt').style.color = '#2e7d32';
                document.getElementById('undoPoint2Btn4pt').style.display = 'inline-block';
                document.getElementById('point3Status4pt').textContent = 'Mark bottom-right corner';
                document.getElementById('point3Status4pt').style.color = '#e74c3c';
            } else if (!state.scale.point3) {
                state.scale.point3 = coords;
                document.getElementById('point3Status4pt').textContent = '‚úì Set';
                document.getElementById('point3Status4pt').style.color = '#2e7d32';
                document.getElementById('undoPoint3Btn4pt').style.display = 'inline-block';
                document.getElementById('point4Status4pt').textContent = 'Mark bottom-left corner';
                document.getElementById('point4Status4pt').style.color = '#e74c3c';
            } else if (!state.scale.point4) {
                state.scale.point4 = coords;
                document.getElementById('point4Status4pt').textContent = '‚úì Set';
                document.getElementById('point4Status4pt').style.color = '#2e7d32';
                document.getElementById('undoPoint4Btn4pt').style.display = 'inline-block';

                // Calculate scale from 4 corners
                calculate4PointScale();
            }
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    // Undo point function
    function undoPoint(pointNumber) {
        if (state.scale.calibrationMode === 'two-point') {
            if (pointNumber === 1) {
                state.scale.point1 = null;
                state.scale.point2 = null;
                document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
                document.getElementById('point1Status').style.color = '#e74c3c';
                document.getElementById('undoPoint1Btn').style.display = 'none';
                document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
                document.getElementById('point2Status').style.color = '#95a5a6';
                document.getElementById('undoPoint2Btn').style.display = 'none';
                document.getElementById('confirmScaleBtn').disabled = true;
            } else if (pointNumber === 2) {
                state.scale.point2 = null;
                document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
                document.getElementById('point2Status').style.color = '#e74c3c';
                document.getElementById('undoPoint2Btn').style.display = 'none';
                document.getElementById('confirmScaleBtn').disabled = true;
            }
        } else {
            // 4-point mode
            if (pointNumber === 1) {
                state.scale.point1 = null;
                state.scale.point2 = null;
                state.scale.point3 = null;
                state.scale.point4 = null;
                resetCalibrationUI();
                document.getElementById('perspectiveWarningDiv').style.display = 'none';
            } else if (pointNumber === 2) {
                state.scale.point2 = null;
                state.scale.point3 = null;
                state.scale.point4 = null;
                document.getElementById('point2Status4pt').textContent = 'Mark top-right corner';
                document.getElementById('point2Status4pt').style.color = '#e74c3c';
                document.getElementById('undoPoint2Btn4pt').style.display = 'none';
                document.getElementById('point3Status4pt').textContent = 'Waiting...';
                document.getElementById('point3Status4pt').style.color = '#95a5a6';
                document.getElementById('undoPoint3Btn4pt').style.display = 'none';
                document.getElementById('point4Status4pt').textContent = 'Waiting...';
                document.getElementById('point4Status4pt').style.color = '#95a5a6';
                document.getElementById('undoPoint4Btn4pt').style.display = 'none';
                document.getElementById('perspectiveWarningDiv').style.display = 'none';
            } else if (pointNumber === 3) {
                state.scale.point3 = null;
                state.scale.point4 = null;
                document.getElementById('point3Status4pt').textContent = 'Mark bottom-right corner';
                document.getElementById('point3Status4pt').style.color = '#e74c3c';
                document.getElementById('undoPoint3Btn4pt').style.display = 'none';
                document.getElementById('point4Status4pt').textContent = 'Waiting...';
                document.getElementById('point4Status4pt').style.color = '#95a5a6';
                document.getElementById('undoPoint4Btn4pt').style.display = 'none';
                document.getElementById('perspectiveWarningDiv').style.display = 'none';
            } else if (pointNumber === 4) {
                state.scale.point4 = null;
                document.getElementById('point4Status4pt').textContent = 'Mark bottom-left corner';
                document.getElementById('point4Status4pt').style.color = '#e74c3c';
                document.getElementById('undoPoint4Btn4pt').style.display = 'none';
                document.getElementById('perspectiveWarningDiv').style.display = 'none';
            }
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    // Calculate scale from 4 corners of credit card (85.6mm x 54mm)
    function calculate4PointScale() {
        const p1 = state.scale.point1; // Top-left
        const p2 = state.scale.point2; // Top-right
        const p3 = state.scale.point3; // Bottom-right
        const p4 = state.scale.point4; // Bottom-left

        // Calculate distances
        const topWidthPx = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        const bottomWidthPx = Math.sqrt(Math.pow(p3.x - p4.x, 2) + Math.pow(p3.y - p4.y, 2));
        const leftHeightPx = Math.sqrt(Math.pow(p4.x - p1.x, 2) + Math.pow(p4.y - p1.y, 2));
        const rightHeightPx = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));

        // Credit card dimensions
        const cardWidthMM = 85.6;
        const cardHeightMM = 54;

        // Calculate scale from each measurement
        const scaleFromTopWidth = topWidthPx / cardWidthMM;
        const scaleFromBottomWidth = bottomWidthPx / cardWidthMM;
        const scaleFromLeftHeight = leftHeightPx / cardHeightMM;
        const scaleFromRightHeight = rightHeightPx / cardHeightMM;

        // Calculate average scale
        const avgScale = (scaleFromTopWidth + scaleFromBottomWidth + scaleFromLeftHeight + scaleFromRightHeight) / 4;

        // Calculate variation (to detect perspective distortion)
        const scales = [scaleFromTopWidth, scaleFromBottomWidth, scaleFromLeftHeight, scaleFromRightHeight];
        const maxScale = Math.max(...scales);
        const minScale = Math.min(...scales);
        const variation = ((maxScale - minScale) / avgScale) * 100;

        // Set the scale
        state.scale.pixelsPerMM = avgScale;
        state.scale.distanceMM = cardWidthMM; // For reference

        // Show warning if significant perspective distortion (>10% variation)
        if (variation > 10) {
            state.scale.perspectiveWarning = true;
            document.getElementById('perspectiveWarningDiv').style.display = 'block';
            document.getElementById('scaleVariation').textContent = variation.toFixed(1);
        } else {
            state.scale.perspectiveWarning = false;
            document.getElementById('perspectiveWarningDiv').style.display = 'none';
        }

        autoSave();

        // Auto-advance to next step
        setTimeout(() => {
            hideMagnifier();
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.remove('hidden');

            const info = EQUIPMENT_INFO[state.equipmentType];
            document.getElementById('equipmentLabel').textContent = info.name;
            document.getElementById('equipmentLabel2').textContent = info.name;
            document.getElementById('step3Instructions').textContent = info.markingInstruction;

            setupEquipmentCanvas();
        }, state.scale.perspectiveWarning ? 3000 : 1500); // Give more time to read warning if present
    }

    function drawPhotoAndPoints(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);

        // Draw lasso if in lasso mode
        if (state.lassoPoints.length > 0) {
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 6;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(state.lassoPoints[0].x, state.lassoPoints[0].y);
            for (let i = 1; i < state.lassoPoints.length; i++) {
                ctx.lineTo(state.lassoPoints[i].x, state.lassoPoints[i].y);
            }
            if (state.lassoComplete) {
                ctx.closePath();
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Fill semi-transparent if complete
            if (state.lassoComplete) {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fill();
            }
        }

        // Draw calibration points based on mode
        if (state.scale.calibrationMode === 'two-point') {
            // 2-POINT MODE: Draw two points and a line
            if (state.scale.point1) {
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(state.scale.point1.x, state.scale.point1.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5;
                ctx.stroke();
            }

            if (state.scale.point2) {
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(state.scale.point2.x, state.scale.point2.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(state.scale.point1.x, state.scale.point1.y);
                ctx.lineTo(state.scale.point2.x, state.scale.point2.y);
                ctx.stroke();
            }
        } else {
            // 4-POINT MODE: Draw all 4 corners and card outline
            const points = [state.scale.point1, state.scale.point2, state.scale.point3, state.scale.point4];
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff']; // Red, Green, Blue, Magenta
            const labels = ['TL', 'TR', 'BR', 'BL']; // Top-Left, Top-Right, Bottom-Right, Bottom-Left

            points.forEach((point, index) => {
                if (point) {
                    // Draw point circle
                    ctx.fillStyle = colors[index];
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 5;
                    ctx.stroke();

                    // Draw label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(labels[index], point.x, point.y);
                }
            });

            // Draw card outline if all 4 points are set
            if (state.scale.point1 && state.scale.point2 && state.scale.point3 && state.scale.point4) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(state.scale.point1.x, state.scale.point1.y);
                ctx.lineTo(state.scale.point2.x, state.scale.point2.y);
                ctx.lineTo(state.scale.point3.x, state.scale.point3.y);
                ctx.lineTo(state.scale.point4.x, state.scale.point4.y);
                ctx.closePath();
                ctx.stroke();

                // Fill with semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                ctx.fill();
            }
        }
    }

    document.getElementById('resetScaleBtn').addEventListener('click', () => {
        state.scale.point1 = null;
        state.scale.point2 = null;
        state.scale.point3 = null;
        state.scale.point4 = null;
        state.scale.perspectiveWarning = false;
        document.getElementById('confirmScaleBtn').disabled = true;

        // Hide magnifier when resetting
        hideMagnifier();

        // Reset lasso
        state.lassoMode = false;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Reset the guide status
        document.getElementById('manualCalibrationGuide').style.display = 'none';
        resetCalibrationUI();
        document.getElementById('perspectiveWarningDiv').style.display = 'none';

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    });

    // Lasso Tool Functionality
    document.getElementById('startLassoBtn').addEventListener('click', () => {
        state.lassoMode = true;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Hide magnifier during lasso
        hideMagnifier();

        // Update UI
        document.getElementById('startLassoBtn').style.display = 'none';
        document.getElementById('cancelLassoBtn').style.display = 'inline-block';
        document.getElementById('lassoStatus').style.display = 'block';
        document.getElementById('lassoStatus').style.background = '#e3f2fd';
        document.getElementById('lassoStatus').style.color = '#1976d2';
        document.getElementById('lassoStatus').textContent = '‚úèÔ∏è Draw around the card or brick, then release to finish';

        // Enable lasso drawing on canvas
        const canvas = document.getElementById('photoCanvas');
        canvas.style.cursor = 'crosshair';
    });

    document.getElementById('cancelLassoBtn').addEventListener('click', () => {
        state.lassoMode = false;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Reset UI
        document.getElementById('startLassoBtn').style.display = 'inline-block';
        document.getElementById('cancelLassoBtn').style.display = 'none';
        document.getElementById('detectInLassoBtn').style.display = 'none';
        document.getElementById('lassoStatus').style.display = 'none';

        const canvas = document.getElementById('photoCanvas');
        canvas.style.cursor = 'default';
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    });

    // Add lasso drawing to canvas
    function setupLassoDrawing() {
        const canvas = document.getElementById('photoCanvas');

        let isDrawing = false;

        canvas.addEventListener('mousedown', (e) => {
            if (!state.lassoMode) return;
            isDrawing = true;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.lassoMode || !isDrawing) return;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);
        });

        canvas.addEventListener('mouseup', () => {
            if (!state.lassoMode || !isDrawing) return;
            isDrawing = false;
            state.lassoComplete = true;
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);

            // Show detect button
            document.getElementById('detectInLassoBtn').style.display = 'inline-block';
            document.getElementById('lassoStatus').textContent = '‚úÖ Lasso complete! Click "Detect Card" to find edges with AI';
            document.getElementById('lassoStatus').style.background = '#e8f5e9';
            document.getElementById('lassoStatus').style.color = '#2e7d32';
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!state.lassoMode) return;
            e.preventDefault();
            isDrawing = true;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!state.lassoMode || !isDrawing) return;
            e.preventDefault();
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);
        });

        canvas.addEventListener('touchend', () => {
            if (!state.lassoMode || !isDrawing) return;
            isDrawing = false;
            state.lassoComplete = true;
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);

            // Show detect button
            document.getElementById('detectInLassoBtn').style.display = 'inline-block';
            document.getElementById('lassoStatus').textContent = '‚úÖ Lasso complete! Click "Detect Card" to find edges with AI';
            document.getElementById('lassoStatus').style.background = '#e8f5e9';
            document.getElementById('lassoStatus').style.color = '#2e7d32';
        });
    }

    // Call setup after canvas is ready
    setTimeout(() => {
        const canvas = document.getElementById('photoCanvas');
        if (canvas) {
            setupLassoDrawing();
        }
    }, 100);

    // Detect Card in Lasso Region using AI
    document.getElementById('detectInLassoBtn').addEventListener('click', async () => {
        const statusDiv = document.getElementById('lassoStatus');
        const btn = document.getElementById('detectInLassoBtn');

        // Show loading status
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Analyzing selected region with AI...';
        btn.disabled = true;

        try {
            // Calculate bounding box from lasso points
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.lassoPoints.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });

            // Add padding (20%) to bounding box
            const padding = 0.2;
            const width = maxX - minX;
            const height = maxY - minY;
            const paddedMinX = Math.max(0, minX - width * padding);
            const paddedMinY = Math.max(0, minY - height * padding);
            const paddedMaxX = Math.min(state.photoWidth, maxX + width * padding);
            const paddedMaxY = Math.min(state.photoHeight, maxY + height * padding);
            const paddedWidth = paddedMaxX - paddedMinX;
            const paddedHeight = paddedMaxY - paddedMinY;

            // Crop image to lasso region
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = paddedWidth;
            cropCanvas.height = paddedHeight;
            cropCtx.drawImage(
                state.photo,
                paddedMinX, paddedMinY, paddedWidth, paddedHeight,
                0, 0, paddedWidth, paddedHeight
            );

            // Convert cropped image to base64
            const croppedImageBase64 = cropCanvas.toDataURL('image/jpeg', 0.8);

            // Get user's AI message if provided
            const aiMessageInput = document.getElementById('aiMessageInput');
            const aiMessage = aiMessageInput ? aiMessageInput.value.trim() : '';

            // Call AI Worker with cropped image and crop metadata
            let response;
            try {
                response = await fetch('https://clearance.martinbibb.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: croppedImageBase64,
                        equipmentType: state.equipmentType,
                        detectObjects: [],
                        cardColorHint: 'blue',
                        cropMetadata: {
                            originX: paddedMinX,
                            originY: paddedMinY,
                            width: paddedWidth,
                            height: paddedHeight,
                            fullImageWidth: state.photoWidth,
                            fullImageHeight: state.photoHeight
                        },
                        useHybridDetection: true, // Flag to tell AI this is a user-hinted crop
                        userMessage: aiMessage // User's optional context
                    }),
                    signal: AbortSignal.timeout(30000)
                });
            } catch (fetchError) {
                if (fetchError.name === 'TimeoutError') {
                    throw new Error('Request timed out. Try drawing a smaller lasso around just the card.');
                } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('Load failed')) {
                    throw new Error('Cannot connect to AI service. Check your internet connection.');
                }
                throw new Error(`Network error: ${fetchError.message}`);
            }

            if (!response.ok) {
                let errorMessage = `API returned error status ${response.status}`;
                try {
                    const errorData = await response.json();
                    if (errorData.error) {
                        errorMessage = errorData.error;
                    }
                } catch (e) {}
                throw new Error(errorMessage);
            }

            const result = await response.json();

            // Check what was detected in the cropped region
            if (result.calibration && result.calibration.creditCardDetected) {
                // CREDIT CARD DETECTED in crop
                const cardBounds = result.calibration.creditCardBounds.bounds;

                // Scale factor: API returns coordinates based on 1000x1000 reference of CROPPED image
                const scaleX = paddedWidth / 1000;
                const scaleY = paddedHeight / 1000;

                // Scale card bounds to cropped image dimensions
                const cardWidthPx = cardBounds.width * scaleX;
                const cardHeightPx = cardBounds.height * scaleY;

                // Determine which dimension is width (should be larger for credit card)
                const actualCardWidthPx = Math.max(cardWidthPx, cardHeightPx);

                // Calculate pixels per mm based on 85mm credit card width
                state.scale.pixelsPerMM = actualCardWidthPx / 85;
                state.scale.distanceMM = 85; // Credit card width

                // Reset lasso UI
                state.lassoMode = false;
                state.lassoPoints = [];
                state.lassoComplete = false;
                document.getElementById('startLassoBtn').style.display = 'inline-block';
                document.getElementById('cancelLassoBtn').style.display = 'none';
                document.getElementById('detectInLassoBtn').style.display = 'none';

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                const aiService = result.aiServiceUsed === 'claude' ? 'ü§ñ Claude' : 'ü§ñ OpenAI';
                const aiServiceBadge = `<span style="background: ${result.aiServiceUsed === 'claude' ? '#f3e5f5' : '#e3f2fd'}; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">${aiService}</span>`;
                statusDiv.innerHTML = `‚úÖ <strong>üîµ Blue card detected in lasso!</strong> ${aiServiceBadge}<br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.creditCardBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: 85mm blue card width<br>` +
                    `<br>‚è≥ Advancing to next step...`;

                // Clear canvas lasso and redraw
                const canvas = document.getElementById('photoCanvas');
                const ctx = canvas.getContext('2d');
                drawPhotoAndPoints(ctx);

                // Auto-advance to next step after 2 seconds
                setTimeout(() => {
                    try {
                        // Hide magnifier when moving to next step
                        hideMagnifier();

                        document.getElementById('step2').classList.add('hidden');
                        document.getElementById('step3').classList.remove('hidden');

                        // Update step 3 labels
                        const info = EQUIPMENT_INFO[state.equipmentType];
                        document.getElementById('equipmentLabel').textContent = info.name;
                        document.getElementById('equipmentLabel2').textContent = info.name;
                        document.getElementById('step3Instructions').textContent = info.markingInstruction;

                        setupEquipmentCanvas();
                    } catch (error) {
                        console.error('Error advancing to step 3:', error);
                        alert('Error advancing to next step. Please refresh and try again.');
                    }
                }, 2000);

            } else if (result.calibration && result.calibration.brickDetected) {
                // BRICK DETECTED (FALLBACK) in cropped region
                const brickBounds = result.calibration.brickBounds.bounds;
                const orientation = result.calibration.brickBounds.orientation;

                // Scale factor: API returns coordinates based on 1000x1000 reference of CROPPED image
                const scaleX = paddedWidth / 1000;
                const scaleY = paddedHeight / 1000;

                // Scale brick bounds to cropped image dimensions
                const brickWidthPx = brickBounds.width * scaleX;
                const brickHeightPx = brickBounds.height * scaleY;

                // Standard UK brick: 215mm x 102.5mm x 65mm
                let referenceMM;
                let actualSizePx;
                let brickDimension;

                if (orientation === 'horizontal') {
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 215;
                    brickDimension = 'length (215mm)';
                } else {
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 102.5;
                    brickDimension = 'width (102.5mm)';
                }

                // Calculate pixels per mm based on brick
                state.scale.pixelsPerMM = actualSizePx / referenceMM;
                state.scale.distanceMM = referenceMM;

                // Reset lasso UI
                state.lassoMode = false;
                state.lassoPoints = [];
                state.lassoComplete = false;
                document.getElementById('startLassoBtn').style.display = 'inline-block';
                document.getElementById('cancelLassoBtn').style.display = 'none';
                document.getElementById('detectInLassoBtn').style.display = 'none';

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>Brick detected in lasso!</strong><br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.brickBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: Standard UK brick ${brickDimension}<br>` +
                    `<br>‚è≥ Advancing to next step...`;

                // Clear canvas lasso and redraw
                const canvas2 = document.getElementById('photoCanvas');
                const ctx2 = canvas2.getContext('2d');
                drawPhotoAndPoints(ctx2);

                // Auto-advance to next step
                setTimeout(() => {
                    try {
                        hideMagnifier();
                        document.getElementById('step2').classList.add('hidden');
                        document.getElementById('step3').classList.remove('hidden');

                        const info = EQUIPMENT_INFO[state.equipmentType];
                        document.getElementById('equipmentLabel').textContent = info.name;
                        document.getElementById('equipmentLabel2').textContent = info.name;
                        document.getElementById('step3Instructions').textContent = info.markingInstruction;

                        setupEquipmentCanvas();
                    } catch (error) {
                        console.error('Error advancing to step 3:', error);
                        alert('Error advancing to next step. Please refresh and try again.');
                    }
                }, 2000);

            } else {
                // NOTHING DETECTED in lasso region
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.innerHTML = '‚ö†Ô∏è <strong>No card/brick found in lasso region</strong><br><br>' +
                    '<strong>üí° Try again:</strong><br>' +
                    '‚Ä¢ Draw lasso closer around the card/brick<br>' +
                    '‚Ä¢ Make sure the card is fully visible in the lasso<br>' +
                    '‚Ä¢ Ensure good lighting without glare<br>' +
                    '‚Ä¢ üîµ Blue cards work best!<br><br>' +
                    '<strong>Or use Manual Calibration below instead</strong>';
                btn.disabled = false;

                // Show the manual calibration guide
                setTimeout(() => {
                    const canvas = document.getElementById('photoCanvas');
                    canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 500);
            }

        } catch (error) {
            console.error('Auto-detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';

            // Provide specific guidance based on error type
            let guidance = '';
            if (error.message.includes('connect') || error.message.includes('unavailable')) {
                guidance = `<strong>üîå Connection Issue</strong><br>` +
                    `‚Ä¢ Check your internet connection<br>` +
                    `‚Ä¢ The AI service may be temporarily down<br>` +
                    `‚Ä¢ Try refreshing the page and uploading again<br><br>`;
            } else if (error.message.includes('timeout') || error.message.includes('too large')) {
                guidance = `<strong>‚è±Ô∏è Timeout or Large Image</strong><br>` +
                    `‚Ä¢ Try taking a photo at lower resolution<br>` +
                    `‚Ä¢ Compress the image before uploading<br>` +
                    `‚Ä¢ Ensure your internet connection is stable<br><br>`;
            } else if (error.message.includes('API key') || error.message.includes('401') || error.message.includes('403')) {
                guidance = `<strong>üîë Service Configuration Issue</strong><br>` +
                    `‚Ä¢ The AI service may not be properly configured<br>` +
                    `‚Ä¢ Contact support if this persists<br><br>`;
            } else {
                guidance = `<strong>‚ö†Ô∏è Unexpected Error</strong><br>` +
                    `Technical details: ${error.message}<br><br>`;
            }

            statusDiv.innerHTML = `‚ùå <strong>AI Detection Failed</strong><br><br>` +
                guidance +
                `üìù <strong>Solution: Use Manual Calibration below</strong><br>` +
                `1. <strong>Tap two points</strong> on a üîµ blue card (85mm, best) or brick (215mm)<br>` +
                `2. <strong>Enter the distance</strong> in the field below<br>` +
                `3. <strong>Click "Confirm Scale"</strong> to continue`;
            btn.disabled = false;
        }
    });

    document.getElementById('confirmScaleBtn').addEventListener('click', () => {
        const distanceMM = parseFloat(document.getElementById('knownDistance').value);
        if (!distanceMM || distanceMM <= 0) {
            alert('Please enter a valid distance');
            return;
        }

        const pixelDistance = Math.sqrt(
            Math.pow(state.scale.point2.x - state.scale.point1.x, 2) +
            Math.pow(state.scale.point2.y - state.scale.point1.y, 2)
        );

        state.scale.distanceMM = distanceMM;
        state.scale.pixelsPerMM = pixelDistance / distanceMM;

        // Hide magnifier when moving to next step
        hideMagnifier();

        document.getElementById('step2').classList.add('hidden');
        document.getElementById('step3').classList.remove('hidden');

        // Update step 3 labels
        const info = EQUIPMENT_INFO[state.equipmentType];
        document.getElementById('equipmentLabel').textContent = info.name;
        document.getElementById('equipmentLabel2').textContent = info.name;
        document.getElementById('step3Instructions').textContent = info.markingInstruction;

        setupEquipmentCanvas();
    });

    // Step 3: Mark Equipment
    function setupEquipmentCanvas() {
        const canvas = document.getElementById('photoCanvas2');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        drawPhotoWithEquipment(ctx);

        canvas.addEventListener('click', handleEquipmentClick);
        canvas.addEventListener('mousedown', startEquipmentDrag);
        canvas.addEventListener('mousemove', handleEquipmentDragMove);
        canvas.addEventListener('mouseup', endEquipmentDrag);
        canvas.addEventListener('mouseleave', endEquipmentDrag);
        canvas.addEventListener('touchstart', handleEquipmentTouchStart);
        canvas.addEventListener('touchmove', handleEquipmentTouchMove);
        canvas.addEventListener('touchend', endEquipmentDrag);
    }

    let equipmentDrag = { active: false, offsetX: 0, offsetY: 0 };

    function handleEquipmentClick(e) {
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = coords;
        autoSave();
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function handleEquipmentTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);

        // If equipment already placed and touch is near it, start drag
        if (state.equipment) {
            const dist = Math.sqrt((coords.x - state.equipment.x) ** 2 + (coords.y - state.equipment.y) ** 2);
            if (dist <= getEquipmentRenderRadius()) {
                equipmentDrag = {
                    active: true,
                    offsetX: coords.x - state.equipment.x,
                    offsetY: coords.y - state.equipment.y
                };
                return;
            }
        }

        state.equipment = coords;
        autoSave();
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function handleEquipmentTouchMove(e) {
        if (!equipmentDrag.active) return;
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = {
            x: coords.x - equipmentDrag.offsetX,
            y: coords.y - equipmentDrag.offsetY
        };
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
        document.getElementById('confirmEquipmentBtn').disabled = false;
    }

    function startEquipmentDrag(e) {
        if (!state.equipment) return;
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        const dist = Math.sqrt((coords.x - state.equipment.x) ** 2 + (coords.y - state.equipment.y) ** 2);
        if (dist <= getEquipmentRenderRadius()) {
            equipmentDrag = {
                active: true,
                offsetX: coords.x - state.equipment.x,
                offsetY: coords.y - state.equipment.y
            };
        }
    }

    function handleEquipmentDragMove(e) {
        if (!equipmentDrag.active) return;
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = {
            x: coords.x - equipmentDrag.offsetX,
            y: coords.y - equipmentDrag.offsetY
        };
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
        document.getElementById('confirmEquipmentBtn').disabled = false;
    }

    function endEquipmentDrag() {
        if (equipmentDrag.active) {
            equipmentDrag.active = false;
            autoSave();
        }
    }

    function drawPhotoWithEquipment(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);

        if (state.equipment) {
            const radius = getEquipmentRenderRadius();
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = Math.max(4, radius * 0.2);
            ctx.stroke();
        }
    }

    function getEquipmentRenderRadius() {
        if (state.equipmentType === 'flue' && state.scale.pixelsPerMM) {
            return (100 / 2) * state.scale.pixelsPerMM; // Render flue at 100mm diameter
        }
        return 15;
    }

    // Arrow key controls for equipment positioning
    document.addEventListener('keydown', (e) => {
        // Only handle arrow keys when on Step 3 (equipment positioning) and equipment has been placed
        const step3 = document.getElementById('step3');
        if (step3.classList.contains('hidden') || !state.equipment) {
            return;
        }

        const moveAmount = e.shiftKey ? 10 : 1; // Hold Shift for faster movement
        let moved = false;

        switch(e.key) {
            case 'ArrowUp':
                state.equipment.y = Math.max(0, state.equipment.y - moveAmount);
                moved = true;
                break;
            case 'ArrowDown':
                state.equipment.y = Math.min(state.photoHeight, state.equipment.y + moveAmount);
                moved = true;
                break;
            case 'ArrowLeft':
                state.equipment.x = Math.max(0, state.equipment.x - moveAmount);
                moved = true;
                break;
            case 'ArrowRight':
                state.equipment.x = Math.min(state.photoWidth, state.equipment.x + moveAmount);
                moved = true;
                break;
        }

        if (moved) {
            e.preventDefault(); // Prevent page scrolling
            const canvas = document.getElementById('photoCanvas2');
            const ctx = canvas.getContext('2d');
            drawPhotoWithEquipment(ctx);
            document.getElementById('confirmEquipmentBtn').disabled = false;
        }
    });

    document.getElementById('confirmEquipmentBtn').addEventListener('click', () => {
        document.getElementById('step3').classList.add('hidden');
        document.getElementById('step4').classList.remove('hidden');

        // Populate obstacle types
        const info = EQUIPMENT_INFO[state.equipmentType];
        const select = document.getElementById('obstacleType');
        select.innerHTML = '';
        info.obstacles.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = OBSTACLE_LABELS[type];
            select.appendChild(option);
        });

        setupObstacleCanvas();
    });

    // Auto-Detect Obstacles using AI
    document.getElementById('autoDetectObstaclesBtn').addEventListener('click', async () => {
        const statusDiv = document.getElementById('autoDetectObstaclesStatus');
        const btn = document.getElementById('autoDetectObstaclesBtn');

        // Show loading status
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Detecting obstacles with AI...';
        btn.disabled = true;

        try {
            // Convert image to base64
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = state.photoWidth;
            canvas.height = state.photoHeight;
            ctx.drawImage(state.photo, 0, 0);
            const imageBase64 = canvas.toDataURL('image/jpeg', 0.8);

            // Get obstacle types for this equipment
            const info = EQUIPMENT_INFO[state.equipmentType];
            const detectObjects = info.obstacles; // e.g., ['opening_window', 'door', 'wall']

            // Get user's AI message if provided
            const aiMessageInput = document.getElementById('aiMessageInput');
            const aiMessage = aiMessageInput ? aiMessageInput.value.trim() : '';

            // Call AI Worker for object detection
            const response = await fetch('https://clearance.martinbibb.workers.dev', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    image: imageBase64,
                    equipmentType: state.equipmentType,
                    detectObjects: detectObjects, // Request AI to detect these obstacles
                    cardColorHint: 'blue',
                    preciseBoundaries: true, // Request exact pixel-perfect boundary detection
                    prompt: 'Detect the exact boundaries and edges of objects. Return precise bounding boxes that tightly fit each object with pixel-level accuracy. Identify the true edges of doors, windows, soffits, walls, and other obstacles without including surrounding surfaces such as brickwork or trim.',
                    userMessage: aiMessage // User's optional context
                }),
                signal: AbortSignal.timeout(60000) // 60 second timeout for obstacle detection
            });

            if (!response.ok) {
                throw new Error(`API returned error status ${response.status}`);
            }

            const result = await response.json();

            // Check if obstacles were detected
            if (result.objects && result.objects.length > 0) {
                // Scale factor: API returns coordinates based on 1000x1000 reference
                const scaleX = state.photoWidth / 1000;
                const scaleY = state.photoHeight / 1000;

                // Add detected obstacles to state
                result.objects.forEach(obstacle => {
                    const mappedObstacle = normalizeObstacleGeometry({
                        type: obstacle.type,
                        shape: 'rectangle',
                        bounds: {
                            x: obstacle.bounds.x * scaleX,
                            y: obstacle.bounds.y * scaleY,
                            width: obstacle.bounds.width * scaleX,
                            height: obstacle.bounds.height * scaleY
                        }
                    });
                    state.obstacles.push(mappedObstacle);
                });

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                const aiService = result.aiServiceUsed === 'claude' ? 'ü§ñ Claude' : 'ü§ñ OpenAI';
                statusDiv.innerHTML = `‚úÖ <strong>Detected ${result.objects.length} obstacle(s)!</strong> <span style="background: ${result.aiServiceUsed === 'claude' ? '#f3e5f5' : '#e3f2fd'}; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${aiService}</span><br>` +
                    `<small>${result.objects.map(o => OBSTACLE_LABELS[o.type]).join(', ')}</small><br>` +
                    `You can add more obstacles manually if needed.`;

                // Update obstacle list and canvas
                updateObstacleList();
                const canvas3 = document.getElementById('photoCanvas3');
                const ctx3 = canvas3.getContext('2d');
                drawPhotoWithObstacles(ctx3);
            } else {
                // No obstacles detected
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.innerHTML = '‚ö†Ô∏è <strong>No obstacles detected</strong><br>' +
                    'Use manual marking below to draw rectangles around obstacles.';
            }

            btn.disabled = false;

        } catch (error) {
            console.error('Auto-detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';
            statusDiv.innerHTML = `‚ùå <strong>AI Detection Failed</strong><br>` +
                `${error.message}<br><br>` +
                `<strong>Solution: Use Manual Marking below</strong>`;
            btn.disabled = false;
        }
    });

    function getClearanceRequirementText(obstacleType) {
        if (!state.brand || !state.model) {
            return null;
        }

        const brandData = getCurrentManufacturers()?.[state.brand];
        const modelData = brandData?.models?.[state.model];

        if (!modelData || !Array.isArray(modelData.rules)) {
            return null;
        }

        const rule = modelData.rules.find(r => r.obstacle_type === obstacleType);
        if (!rule || !rule.clearances) {
            return null;
        }

        const { above, below, sides } = rule.clearances;
        const parts = [];
        if (above) parts.push(`Above ${above}mm`);
        if (below) parts.push(`Below ${below}mm`);
        if (sides) parts.push(`Side ${sides}mm`);

        return parts.length > 0 ? parts.join(' ‚Ä¢ ') : null;
    }

    // Detect obstacle within lasso selection
    async function detectObstacleInLasso() {
        const statusDiv = document.getElementById('obstacleLassoStatus');
        const detectBtn = document.getElementById('detectInObstacleLassoBtn');
        const selectedType = document.getElementById('obstacleType').value;

        if (!selectedType) {
            alert('Please select an obstacle type from the dropdown below before detecting.');
            return;
        }

        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Detecting obstacle with AI...';
        detectBtn.disabled = true;

        try {
            // Calculate bounding box of lasso
            const minX = Math.min(...state.lassoPoints.map(p => p.x));
            const minY = Math.min(...state.lassoPoints.map(p => p.y));
            const maxX = Math.max(...state.lassoPoints.map(p => p.x));
            const maxY = Math.max(...state.lassoPoints.map(p => p.y));
            const cropWidth = maxX - minX;
            const cropHeight = maxY - minY;

            // Create cropped canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;

            // Draw cropped region from original photo
            tempCtx.drawImage(state.photo, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            const imageBase64 = tempCanvas.toDataURL('image/jpeg', 0.8);

            // Get user's AI message if provided
            const aiMessageInput = document.getElementById('aiMessageInput');
            const aiMessage = aiMessageInput ? aiMessageInput.value.trim() : '';

            // Call AI Worker
            const response = await fetch('https://clearance.martinbibb.workers.dev', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    image: imageBase64,
                    equipmentType: state.equipmentType,
                    detectObjects: [selectedType],
                    cropMetadata: {
                        originX: minX,
                        originY: minY,
                        width: cropWidth,
                        height: cropHeight,
                        fullImageWidth: state.photoWidth,
                        fullImageHeight: state.photoHeight
                    },
                    useHybridDetection: true,
                    preciseBoundaries: true,
                    prompt: `Detect the ${OBSTACLE_LABELS[selectedType]} in this image. Find its exact boundaries with pixel-perfect accuracy (hug the real item only, e.g., the window opening without surrounding brickwork).`,
                    userMessage: aiMessage // User's optional context
                }),
                signal: AbortSignal.timeout(60000)
            });

            if (!response.ok) {
                throw new Error(`API returned error status ${response.status}`);
            }

            const result = await response.json();

            if (result.objects && result.objects.length > 0) {
                // Scale and translate obstacle coordinates
                const scaleX = cropWidth / 1000;
                const scaleY = cropHeight / 1000;

                const obstacle = result.objects[0]; // Take first detected obstacle
                const mappedBounds = {
                    x: (obstacle.bounds.x * scaleX) + minX,
                    y: (obstacle.bounds.y * scaleY) + minY,
                    width: obstacle.bounds.width * scaleX,
                    height: obstacle.bounds.height * scaleY
                };

                // Check if AI provided detailed polygon boundary
                let obstacleData = {
                    type: selectedType,
                    shape: 'rectangle',
                    bounds: mappedBounds
                };

                if (obstacle.polygon && obstacle.polygon.length >= 3) {
                    // AI provided detailed polygon - use it instead of rectangle
                    const mappedPolygon = obstacle.polygon.map(pt => ({
                        x: (pt.x * scaleX) + minX,
                        y: (pt.y * scaleY) + minY
                    }));
                    obstacleData.polygon = mappedPolygon;
                    obstacleData.shape = 'polygon';
                }

                state.obstacles.push(normalizeObstacleGeometry(obstacleData));

                // Highlight the exact AI-mapped position in green
                state.recentDetection = {
                    bounds: mappedBounds,
                    type: selectedType,
                    timestamp: Date.now()
                };

                // Success! Reset lasso
                state.lassoMode = false;
                state.lassoPoints = [];
                state.lassoComplete = false;

                // Update UI
                document.getElementById('startObstacleLassoBtn').style.display = 'inline-block';
                document.getElementById('clearObstacleLassoBtn').style.display = 'none';
                document.getElementById('detectInObstacleLassoBtn').style.display = 'none';

                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                const aiService = result.aiServiceUsed === 'claude' ? 'ü§ñ Claude' : 'ü§ñ OpenAI';
                const aiServiceBadge = `<span style="background: ${result.aiServiceUsed === 'claude' ? '#f3e5f5' : '#e3f2fd'}; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">${aiService}</span>`;
                const clearanceText = getClearanceRequirementText(selectedType);
                const clearanceLine = clearanceText ? `<br><strong>Clearance requirement:</strong> ${clearanceText}` : '<br><small>Select make/model to see clearance requirements.</small>';
                statusDiv.innerHTML = `‚úÖ <strong>${OBSTACLE_LABELS[selectedType]} detected!</strong> ${aiServiceBadge}${clearanceLine}<br><small>Draw another lasso or use other methods to add more obstacles.</small>`;

                // Update list and canvas
                updateObstacleList();
                const canvas = document.getElementById('photoCanvas3');
                const ctx = canvas.getContext('2d');
                drawPhotoWithObstacles(ctx);

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 2000);

            } else {
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.textContent = '‚ö†Ô∏è No obstacle detected in lasso area. Try drawing a tighter lasso or use manual tools.';
            }

            detectBtn.disabled = false;

        } catch (error) {
            console.error('Lasso detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';
            statusDiv.textContent = `‚ùå Detection failed: ${error.message}. Try again or use manual tools.`;
            detectBtn.disabled = false;
        }
    }

    // Tool selection handlers
    function setDrawingTool(tool) {
        state.drawingTool = tool;

        // Update button styles
        document.getElementById('rectangleToolBtn').classList.remove('active');
        document.getElementById('lineToolBtn').classList.remove('active');
        document.getElementById('circleToolBtn').classList.remove('active');
        document.getElementById('paintToolBtn').classList.remove('active');

        const instructions = document.getElementById('toolInstructions');
        const paintControls = document.getElementById('paintToolControls');

        // Hide paint controls by default
        paintControls.style.display = 'none';

        if (tool === 'rectangle') {
            document.getElementById('rectangleToolBtn').classList.add('active');
            instructions.innerHTML = '<strong>üìê Rectangle Tool:</strong> Tap two corners to draw a rectangle around the obstacle';
            instructions.style.display = 'block';
        } else if (tool === 'line') {
            document.getElementById('lineToolBtn').classList.add('active');
            instructions.innerHTML = '<strong>üìè Line Tool:</strong> Tap two points to draw a line (obstacle extends perpendicular from line)';
            instructions.style.display = 'block';
        } else if (tool === 'circle') {
            document.getElementById('circleToolBtn').classList.add('active');
            instructions.innerHTML = '<strong>‚≠ï Circle Tool:</strong> Tap center then drag to set radius of circular obstacle';
            instructions.style.display = 'block';
        } else if (tool === 'paint') {
            document.getElementById('paintToolBtn').classList.add('active');
            instructions.style.display = 'none';
            paintControls.style.display = 'block';
        }
    }

    // Step 4: Mark Obstacles
    function setupObstacleCanvas() {
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        drawPhotoWithObstacles(ctx);

        // Obstacle Lasso Tool Handlers
        document.getElementById('startObstacleLassoBtn').addEventListener('click', () => {
            state.lassoMode = true;
            state.lassoPoints = [];
            state.lassoComplete = false;
            hideMagnifier();

            document.getElementById('startObstacleLassoBtn').style.display = 'none';
            document.getElementById('clearObstacleLassoBtn').style.display = 'inline-block';
            document.getElementById('obstacleLassoStatus').style.display = 'block';
            document.getElementById('obstacleLassoStatus').style.background = '#e3f2fd';
            document.getElementById('obstacleLassoStatus').style.color = '#1976d2';
            document.getElementById('obstacleLassoStatus').textContent = '‚úèÔ∏è Draw around the obstacle, then release to finish';

            canvas.style.cursor = 'crosshair';
        });

        document.getElementById('clearObstacleLassoBtn').addEventListener('click', () => {
            state.lassoMode = false;
            state.lassoPoints = [];
            state.lassoComplete = false;

            document.getElementById('startObstacleLassoBtn').style.display = 'inline-block';
            document.getElementById('clearObstacleLassoBtn').style.display = 'none';
            document.getElementById('detectInObstacleLassoBtn').style.display = 'none';
            document.getElementById('obstacleLassoStatus').style.display = 'none';

            canvas.style.cursor = 'default';
            drawPhotoWithObstacles(ctx);
        });

        document.getElementById('detectInObstacleLassoBtn').addEventListener('click', async () => {
            await detectObstacleInLasso();
        });

        // Tool button handlers
        document.getElementById('rectangleToolBtn').addEventListener('click', () => setDrawingTool('rectangle'));
        document.getElementById('lineToolBtn').addEventListener('click', () => setDrawingTool('line'));
        document.getElementById('circleToolBtn').addEventListener('click', () => setDrawingTool('circle'));
        document.getElementById('paintToolBtn').addEventListener('click', () => setDrawingTool('paint'));

        // Paint tool controls
        document.getElementById('brushSizeSlider').addEventListener('input', (e) => {
            state.paintBrushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = e.target.value;
        });

        document.getElementById('clearPaintMaskBtn').addEventListener('click', () => {
            state.paintMasks = [];
            drawPhotoWithObstacles(ctx);
        });

        document.getElementById('confirmPaintMaskBtn').addEventListener('click', () => {
            confirmPaintMaskWithAI();
        });

        // Initialize with rectangle tool (but lasso is recommended)
        setDrawingTool('rectangle');

        canvas.addEventListener('mousedown', handleObstacleMouseDown);
        canvas.addEventListener('mousemove', handleObstacleMouseMove);
        canvas.addEventListener('mouseup', handleObstacleMouseUp);

        canvas.addEventListener('touchstart', handleObstacleTouchStart);
        canvas.addEventListener('touchmove', handleObstacleTouchMove);
        canvas.addEventListener('touchend', handleObstacleTouchEnd);
    }

    function handleObstacleMouseDown(e) {
        const canvas = document.getElementById('photoCanvas3');
        const coords = getCanvasCoordinates(canvas, e);

        // Handle lasso mode
        if (state.lassoMode) {
            state.lassoPoints.push(coords);
            return;
        }

        // Check if clicked on an existing object for editing/dragging
        const clickedObject = findObjectAtPosition(coords.x, coords.y);
        if (clickedObject) {
            state.selectedObject = clickedObject;
            state.dragOffset = {
                x: coords.x,
                y: coords.y
            };
            showObjectEditor(clickedObject);
            return;
        }

        // Deselect if clicking on empty space
        if (state.selectedObject) {
            state.selectedObject = null;
            hideObjectEditor();
        }

        if (state.drawingTool === 'paint') {
            state.isPainting = true;
            state.currentPaintStroke = [coords];
        } else {
            state.currentObstacleStart = coords;
        }
    }

    function handleObstacleMouseMove(e) {
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);

        // Handle object dragging
        if (state.selectedObject && state.dragOffset) {
            const dx = current.x - state.dragOffset.x;
            const dy = current.y - state.dragOffset.y;
            moveObject(state.selectedObject, dx, dy);
            state.dragOffset = current;
            drawPhotoWithObstacles(ctx);
            return;
        }

        // Handle lasso mode
        if (state.lassoMode && state.lassoPoints.length > 0) {
            state.lassoPoints.push(current);
            drawPhotoWithObstacles(ctx);
            return;
        }

        if (state.drawingTool === 'paint' && state.isPainting) {
            // Add point to current stroke
            state.currentPaintStroke.push(current);

            // Redraw everything
            drawPhotoWithObstacles(ctx);

            // Draw current stroke
            drawPaintStroke(ctx, state.currentPaintStroke, state.paintBrushSize);
            return;
        }

        if (!state.currentObstacleStart) return;

        drawPhotoWithObstacles(ctx);

        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 6;
        ctx.setLineDash([5, 5]);

        if (state.drawingTool === 'rectangle') {
            // Draw preview rectangle
            ctx.strokeRect(
                state.currentObstacleStart.x,
                state.currentObstacleStart.y,
                current.x - state.currentObstacleStart.x,
                current.y - state.currentObstacleStart.y
            );
        } else if (state.drawingTool === 'line') {
            // Draw preview line
            ctx.beginPath();
            ctx.moveTo(state.currentObstacleStart.x, state.currentObstacleStart.y);
            ctx.lineTo(current.x, current.y);
            ctx.stroke();
        } else if (state.drawingTool === 'circle') {
            // Draw preview circle
            const radius = Math.sqrt(
                Math.pow(current.x - state.currentObstacleStart.x, 2) +
                Math.pow(current.y - state.currentObstacleStart.y, 2)
            );
            ctx.beginPath();
            ctx.arc(state.currentObstacleStart.x, state.currentObstacleStart.y, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.setLineDash([]);
    }

    function handleObstacleMouseUp(e) {
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');

        // Handle object dragging end
        if (state.dragOffset) {
            state.dragOffset = null;
            autoSave();
            return;
        }

        // Handle lasso mode
        if (state.lassoMode && state.lassoPoints.length > 0) {
            state.lassoComplete = true;
            drawPhotoWithObstacles(ctx);

            // Show detect button
            document.getElementById('detectInObstacleLassoBtn').style.display = 'inline-block';
            document.getElementById('obstacleLassoStatus').textContent = '‚úÖ Lasso complete! Select obstacle type below, then click "Detect Obstacle with AI"';
            document.getElementById('obstacleLassoStatus').style.background = '#e8f5e9';
            document.getElementById('obstacleLassoStatus').style.color = '#2e7d32';
            return;
        }

        if (state.drawingTool === 'paint' && state.isPainting) {
            state.isPainting = false;
            if (state.currentPaintStroke && state.currentPaintStroke.length > 1) {
                state.paintMasks.push({
                    stroke: state.currentPaintStroke,
                    brushSize: state.paintBrushSize
                });
            }
            state.currentPaintStroke = null;
            drawPhotoWithObstacles(canvas.getContext('2d'));
            return;
        }

        if (!state.currentObstacleStart) return;
        const current = getCanvasCoordinates(canvas, e);

        const obstacleType = document.getElementById('obstacleType').value;

        const obstacle = {
            type: obstacleType,
            shape: state.drawingTool
        };

        if (state.drawingTool === 'rectangle') {
            obstacle.bounds = {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            };
        } else if (state.drawingTool === 'line') {
            obstacle.line = {
                x1: state.currentObstacleStart.x,
                y1: state.currentObstacleStart.y,
                x2: current.x,
                y2: current.y
            };
            // For clearance calculation, create bounding box
            obstacle.bounds = {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            };
        } else if (state.drawingTool === 'circle') {
            const radius = Math.sqrt(
                Math.pow(current.x - state.currentObstacleStart.x, 2) +
                Math.pow(current.y - state.currentObstacleStart.y, 2)
            );
            obstacle.circle = {
                centerX: state.currentObstacleStart.x,
                centerY: state.currentObstacleStart.y,
                radius: radius
            };
            // For clearance calculation, create bounding box
            obstacle.bounds = {
                x: state.currentObstacleStart.x - radius,
                y: state.currentObstacleStart.y - radius,
                width: radius * 2,
                height: radius * 2
            };
        }

        state.obstacles.push(normalizeObstacleGeometry(obstacle));
        autoSave();

        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function drawPaintStroke(ctx, stroke, brushSize, colors = {}) {
        if (!stroke || stroke.length < 2) return;

        const {
            strokeStyle = 'rgba(255, 255, 0, 0.7)',
            fillStyle = 'rgba(255, 255, 0, 0.3)'
        } = colors;

        ctx.save();
        ctx.strokeStyle = strokeStyle;
        ctx.fillStyle = fillStyle;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        ctx.moveTo(stroke[0].x, stroke[0].y);
        for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i].x, stroke[i].y);
        }
        ctx.stroke();

        // Draw circles at each point for better coverage
        stroke.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.restore();
    }

    function handleObstacleTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas3');
        const coords = getCanvasCoordinates(canvas, e);

        // Handle lasso mode
        if (state.lassoMode) {
            state.lassoPoints.push(coords);
            return;
        }

        // Check if touched an existing object for editing/dragging
        const touchedObject = findObjectAtPosition(coords.x, coords.y);
        if (touchedObject) {
            state.selectedObject = touchedObject;
            state.dragOffset = {
                x: coords.x,
                y: coords.y
            };
            showObjectEditor(touchedObject);
            return;
        }

        // Deselect if touching empty space
        if (state.selectedObject) {
            state.selectedObject = null;
            hideObjectEditor();
        }

        if (state.drawingTool === 'paint') {
            state.isPainting = true;
            state.currentPaintStroke = [coords];
        } else {
            state.currentObstacleStart = coords;
        }
    }

    function handleObstacleTouchMove(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);

        // Handle object dragging
        if (state.selectedObject && state.dragOffset) {
            const dx = current.x - state.dragOffset.x;
            const dy = current.y - state.dragOffset.y;
            moveObject(state.selectedObject, dx, dy);
            state.dragOffset = current;
            drawPhotoWithObstacles(ctx);
            return;
        }

        // Handle lasso mode
        if (state.lassoMode && state.lassoPoints.length > 0) {
            state.lassoPoints.push(current);
            drawPhotoWithObstacles(ctx);
            return;
        }

        if (state.drawingTool === 'paint' && state.isPainting) {
            state.currentPaintStroke.push(current);
            drawPhotoWithObstacles(ctx);
            drawPaintStroke(ctx, state.currentPaintStroke, state.paintBrushSize);
            return;
        }

        if (!state.currentObstacleStart) return;

        drawPhotoWithObstacles(ctx);

        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 6;
        ctx.setLineDash([5, 5]);

        if (state.drawingTool === 'rectangle') {
            ctx.strokeRect(
                state.currentObstacleStart.x,
                state.currentObstacleStart.y,
                current.x - state.currentObstacleStart.x,
                current.y - state.currentObstacleStart.y
            );
        } else if (state.drawingTool === 'line') {
            ctx.beginPath();
            ctx.moveTo(state.currentObstacleStart.x, state.currentObstacleStart.y);
            ctx.lineTo(current.x, current.y);
            ctx.stroke();
        } else if (state.drawingTool === 'circle') {
            const radius = Math.sqrt(
                Math.pow(current.x - state.currentObstacleStart.x, 2) +
                Math.pow(current.y - state.currentObstacleStart.y, 2)
            );
            ctx.beginPath();
            ctx.arc(state.currentObstacleStart.x, state.currentObstacleStart.y, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.setLineDash([]);
    }

    function handleObstacleTouchEnd(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');

        // Handle object dragging end
        if (state.dragOffset) {
            state.dragOffset = null;
            autoSave();
            return;
        }

        // Handle lasso mode
        if (state.lassoMode && state.lassoPoints.length > 0) {
            state.lassoComplete = true;
            drawPhotoWithObstacles(ctx);
            document.getElementById('detectInObstacleLassoBtn').style.display = 'inline-block';
            document.getElementById('obstacleLassoStatus').textContent = '‚úÖ Lasso complete! Select obstacle type below, then click "Detect Obstacle with AI"';
            document.getElementById('obstacleLassoStatus').style.background = '#e8f5e9';
            document.getElementById('obstacleLassoStatus').style.color = '#2e7d32';
            return;
        }

        if (state.drawingTool === 'paint' && state.isPainting) {
            state.isPainting = false;
            if (state.currentPaintStroke && state.currentPaintStroke.length > 1) {
                state.paintMasks.push({
                    stroke: state.currentPaintStroke,
                    brushSize: state.paintBrushSize
                });
            }
            state.currentPaintStroke = null;
            drawPhotoWithObstacles(ctx);
            return;
        }

        if (!state.currentObstacleStart) return;
        const touch = e.changedTouches[0];
        const current = getCanvasCoordinates(canvas, { clientX: touch.clientX, clientY: touch.clientY });

        const obstacleType = document.getElementById('obstacleType').value;

        const obstacle = {
            type: obstacleType,
            shape: state.drawingTool
        };

        if (state.drawingTool === 'rectangle') {
            obstacle.bounds = {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            };
        } else if (state.drawingTool === 'line') {
            obstacle.line = {
                x1: state.currentObstacleStart.x,
                y1: state.currentObstacleStart.y,
                x2: current.x,
                y2: current.y
            };
            obstacle.bounds = {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            };
        } else if (state.drawingTool === 'circle') {
            const radius = Math.sqrt(
                Math.pow(current.x - state.currentObstacleStart.x, 2) +
                Math.pow(current.y - state.currentObstacleStart.y, 2)
            );
            obstacle.circle = {
                centerX: state.currentObstacleStart.x,
                centerY: state.currentObstacleStart.y,
                radius: radius
            };
            obstacle.bounds = {
                x: state.currentObstacleStart.x - radius,
                y: state.currentObstacleStart.y - radius,
                width: radius * 2,
                height: radius * 2
            };
        }

        state.obstacles.push(normalizeObstacleGeometry(obstacle));
        autoSave();

        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function drawPhotoWithObstacles(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);

        if (state.equipment) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, 15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Count obstacles by type to create labels like "Wall 1", "Wall 2", "Window 1", etc.
        const typeCounts = {};
        state.obstacles.forEach(obstacle => {
            typeCounts[obstacle.type] = (typeCounts[obstacle.type] || 0) + 1;
        });

        // Reset counts for drawing
        const currentTypeCounts = {};

        state.obstacles.forEach((obstacle, index) => {
            const polygon = getObstaclePolygon(obstacle);
            const bounds = getObstacleBounds(obstacle);
            const isSelected = state.selectedObject?.type === 'obstacle' && state.selectedObject.index === index;

            ctx.save();
            ctx.strokeStyle = isSelected ? '#4caf50' : '#00ff00';
            ctx.lineWidth = isSelected ? 6 : 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            if (polygon && polygon.length >= 3) {
                tracePolygon(ctx, polygon);
                ctx.stroke();
            } else if (obstacle.shape === 'line' && obstacle.line) {
                ctx.beginPath();
                ctx.moveTo(obstacle.line.x1, obstacle.line.y1);
                ctx.lineTo(obstacle.line.x2, obstacle.line.y2);
                ctx.stroke();
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(obstacle.line.x1, obstacle.line.y1, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(obstacle.line.x2, obstacle.line.y2, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (obstacle.shape === 'circle' && obstacle.circle) {
                ctx.beginPath();
                ctx.arc(obstacle.circle.centerX, obstacle.circle.centerY, obstacle.circle.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(obstacle.circle.centerX, obstacle.circle.centerY, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (obstacle.shape === 'mask' && obstacle.maskStrokes) {
                obstacle.maskStrokes.forEach(maskStroke => {
                    drawPaintStroke(ctx, maskStroke.stroke, maskStroke.brushSize, {
                        strokeStyle: 'rgba(0, 255, 0, 0.7)',
                        fillStyle: 'rgba(0, 255, 0, 0.2)'
                    });
                });
            }
            ctx.restore();

            // Draw label with type and number (e.g., "Wall 1", "Window 2")
            currentTypeCounts[obstacle.type] = (currentTypeCounts[obstacle.type] || 0) + 1;
            const typeLabel = OBSTACLE_LABELS[obstacle.type] || obstacle.type;
            const labelText = typeCounts[obstacle.type] > 1 ?
                `${typeLabel} ${currentTypeCounts[obstacle.type]}` :
                typeLabel;

            if (!bounds) return;

            // Draw label background for better visibility
            ctx.font = 'bold 16px Arial';
            const textMetrics = ctx.measureText(labelText);
            const textWidth = textMetrics.width;
            const textHeight = 16;
            const labelX = bounds.x + 5;
            const labelY = bounds.y + 5;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(labelX - 2, labelY - textHeight, textWidth + 4, textHeight + 4);

            ctx.fillStyle = '#00ff00';
            ctx.fillText(labelText, labelX, labelY);
        });

        // Draw paint masks
        state.paintMasks.forEach(mask => {
            drawPaintStroke(ctx, mask.stroke, mask.brushSize);
        });

        // Briefly highlight the most recent AI-mapped obstacle
        if (state.recentDetection && Date.now() - state.recentDetection.timestamp < 4000) {
            const { x, y, width, height } = state.recentDetection.bounds;
            ctx.save();
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#00ff00';
            ctx.setLineDash([12, 6]);
            ctx.strokeRect(x, y, width, height);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.12)';
            ctx.fillRect(x, y, width, height);
            ctx.restore();
        }

        // Draw lasso
        if (state.lassoMode && state.lassoPoints.length > 0) {
            ctx.strokeStyle = state.lassoComplete ? '#00ff00' : '#ffff00';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(state.lassoPoints[0].x, state.lassoPoints[0].y);
            for (let i = 1; i < state.lassoPoints.length; i++) {
                ctx.lineTo(state.lassoPoints[i].x, state.lassoPoints[i].y);
            }

            if (state.lassoComplete && state.lassoPoints.length > 2) {
                ctx.closePath();
            }

            ctx.stroke();
        }
    }

    function updateObstacleList() {
        const list = document.getElementById('obstacleList');
        list.innerHTML = '<h3 style="margin: 10px 0;">Marked Obstacles:</h3>';

        // Count obstacles by type to create labels like "Wall 1", "Wall 2", etc.
        const typeCounts = {};
        state.obstacles.forEach(obstacle => {
            typeCounts[obstacle.type] = (typeCounts[obstacle.type] || 0) + 1;
        });

        const currentTypeCounts = {};

        state.obstacles.forEach((obstacle, index) => {
            const shapeIcon = obstacle.shape === 'line' ? 'üìè' : obstacle.shape === 'circle' ? '‚≠ï' : 'üìê';
            currentTypeCounts[obstacle.type] = (currentTypeCounts[obstacle.type] || 0) + 1;
            const typeLabel = OBSTACLE_LABELS[obstacle.type] || obstacle.type;
            const labelText = typeCounts[obstacle.type] > 1 ?
                `${typeLabel} ${currentTypeCounts[obstacle.type]}` :
                typeLabel;

            const item = document.createElement('div');
            item.className = 'obstacle-item';
            item.innerHTML = `
                <span>${labelText} ${shapeIcon}</span>
                <button onclick="removeObstacle(${index})">Remove</button>
            `;
            list.appendChild(item);
        });
    }

    window.removeObstacle = function(index) {
        state.obstacles.splice(index, 1);
        updateObstacleList();
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        drawPhotoWithObstacles(ctx);
    };

    document.getElementById('nextToRulesBtn').addEventListener('click', () => {
        if (state.obstacles.length === 0) {
            alert('Please mark at least one obstacle');
            return;
        }

        document.getElementById('step4').classList.add('hidden');
        document.getElementById('step5').classList.remove('hidden');

        const boilerTypeGroup = document.getElementById('boilerTypeGroup');
        if (state.equipmentType === 'boiler') {
            boilerTypeGroup.style.display = 'block';
            document.getElementById('boilerType').value = state.boilerType || '';
        } else {
            boilerTypeGroup.style.display = 'none';
            state.boilerType = null;
        }

        populateManufacturerOptions();

        // Show model select group
        document.getElementById('modelSelectGroup').style.display = 'block';
    });

    function populateManufacturerOptions() {
        const brandSelect = document.getElementById('brand');
        brandSelect.innerHTML = '<option value="">-- Select Manufacturer --</option>';
        const manufacturers = getCurrentManufacturers();
        brandSelect.disabled = !manufacturers;
        document.getElementById('generateBtn').disabled = true;

        if (!manufacturers) {
            return;
        }

        Object.keys(manufacturers).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = manufacturers[key].name;
            option.selected = state.brand === key;
            brandSelect.appendChild(option);
        });
    }

    document.getElementById('boilerType').addEventListener('change', (e) => {
        state.boilerType = e.target.value || null;
        state.brand = null;
        state.model = null;
        document.getElementById('generateBtn').disabled = true;
        populateManufacturerOptions();
        autoSave();
    });

    // Brand change handler - populate models
    document.getElementById('brand').addEventListener('change', (e) => {
        const brandKey = e.target.value;
        const modelSelect = document.getElementById('model');
        modelSelect.innerHTML = '<option value="">-- Select Model --</option>';

        if (!brandKey) {
            document.getElementById('generateBtn').disabled = true;
            return;
        }

        const manufacturers = getCurrentManufacturers();
        const models = manufacturers?.[brandKey]?.models;
        if (models) {
            Object.keys(models).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = models[key].name;
                modelSelect.appendChild(option);
            });
        }

        // Disable generate button until model is selected
        document.getElementById('generateBtn').disabled = true;
    });

    // Model change handler - enable generate button
    document.getElementById('model').addEventListener('change', (e) => {
        const modelKey = e.target.value;
        document.getElementById('generateBtn').disabled = !modelKey;
    });

    // Step 5: Generate Clearance Overlay
    document.getElementById('generateBtn').addEventListener('click', () => {
        if (state.equipmentType === 'boiler' && !state.boilerType) {
            alert('Please choose a boiler type.');
            return;
        }
        state.brand = document.getElementById('brand').value;
        state.model = document.getElementById('model').value;

        if (!state.model) {
            alert('Please select a model');
            return;
        }

        autoSave();

        document.getElementById('step5').classList.add('hidden');
        document.getElementById('step6').classList.remove('hidden');

        generateClearanceOverlay();
    });

    // Draw rounded rectangle (rectangle with 90¬∞ arc corners)
    function drawRoundedRect(ctx, x, y, width, height, radius, fill = true, stroke = true) {
        // Ensure radius doesn't exceed half of width or height
        const maxRadius = Math.min(width, height) / 2;
        const r = Math.min(radius, maxRadius);

        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.arc(x + width - r, y + r, r, Math.PI * 1.5, Math.PI * 2); // Top-right corner
        ctx.lineTo(x + width, y + height - r);
        ctx.arc(x + width - r, y + height - r, r, 0, Math.PI * 0.5); // Bottom-right corner
        ctx.lineTo(x + r, y + height);
        ctx.arc(x + r, y + height - r, r, Math.PI * 0.5, Math.PI); // Bottom-left corner
        ctx.lineTo(x, y + r);
        ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5); // Top-left corner
        ctx.closePath();

        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }

    // Check if point is inside rounded rectangle clearance zone
    function isPointInRoundedRect(px, py, x, y, width, height, radius) {
        const maxRadius = Math.min(width, height) / 2;
        const r = Math.min(radius, maxRadius);

        // Check if point is within the overall bounding box
        if (px < x || px > x + width || py < y || py > y + height) {
            return false;
        }

        // Check corner regions
        // Top-left corner
        if (px < x + r && py < y + r) {
            const dx = px - (x + r);
            const dy = py - (y + r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Top-right corner
        if (px > x + width - r && py < y + r) {
            const dx = px - (x + width - r);
            const dy = py - (y + r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Bottom-left corner
        if (px < x + r && py > y + height - r) {
            const dx = px - (x + r);
            const dy = py - (y + height - r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Bottom-right corner
        if (px > x + width - r && py > y + height - r) {
            const dx = px - (x + width - r);
            const dy = py - (y + height - r);
            return (dx * dx + dy * dy) <= (r * r);
        }

        // Point is in main rectangular region
        return true;
    }

    function generateClearanceOverlay() {
        const canvas = document.getElementById('photoCanvas4');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        ctx.drawImage(state.photo, 0, 0);

        // Get model data with dimensions and rules
        const manufacturers = getCurrentManufacturers();
        const modelData = manufacturers?.[state.brand]?.models?.[state.model];
        if (!modelData) {
            console.error('Missing model data for clearance overlay');
            return;
        }
        const rules = modelData.rules;
        const dimensions = modelData.dimensions;

        // Convert equipment dimensions from mm to pixels
        const equipmentWidthPx = dimensions.width * state.scale.pixelsPerMM;
        const equipmentHeightPx = dimensions.height * state.scale.pixelsPerMM;

        // Calculate equipment rectangle (centered on marked point)
        const equipmentRect = {
            x: state.equipment.x - equipmentWidthPx / 2,
            y: state.equipment.y - equipmentHeightPx / 2,
            width: equipmentWidthPx,
            height: equipmentHeightPx
        };

        const violations = [];

        state.obstacles.forEach((obstacle, index) => {
            const rule = rules.find(r => r.obstacle_type === obstacle.type);
            if (!rule) return;

            const clearancePx = {
                above: rule.clearances.above * state.scale.pixelsPerMM,
                below: rule.clearances.below * state.scale.pixelsPerMM,
                sides: rule.clearances.sides * state.scale.pixelsPerMM
            };

            const clearanceDistance = Math.max(clearancePx.above, clearancePx.below, clearancePx.sides);
            const isSelected = state.selectedObject?.type === 'obstacle' && state.selectedObject.index === index;

            let equipmentIntersects = false;

            if (obstacle.shape === 'circle' && obstacle.circle) {
                const clearanceRadius = obstacle.circle.radius + clearanceDistance;

                // Draw clearance ring (band between inner and outer circles)
                ctx.save();
                ctx.fillStyle = rule.color;
                ctx.strokeStyle = rule.stroke;
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';

                // Draw outer clearance circle
                ctx.beginPath();
                ctx.arc(obstacle.circle.centerX, obstacle.circle.centerY, clearanceRadius, 0, Math.PI * 2);

                // Draw inner obstacle circle (counter-clockwise for evenodd fill)
                ctx.arc(obstacle.circle.centerX, obstacle.circle.centerY, obstacle.circle.radius, 0, Math.PI * 2, true);

                // Fill the ring using evenodd rule
                ctx.fill('evenodd');
                ctx.stroke();
                ctx.restore();

                // Draw original circle outline on top
                ctx.save();
                ctx.strokeStyle = isSelected ? '#4caf50' : '#00ff00';
                ctx.lineWidth = isSelected ? 5 : 3;
                ctx.beginPath();
                ctx.arc(obstacle.circle.centerX, obstacle.circle.centerY, obstacle.circle.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                // Check if equipment rectangle intersects with circular clearance zone
                // Check each corner of equipment rectangle against circle
                const corners = [
                    { x: equipmentRect.x, y: equipmentRect.y },
                    { x: equipmentRect.x + equipmentRect.width, y: equipmentRect.y },
                    { x: equipmentRect.x, y: equipmentRect.y + equipmentRect.height },
                    { x: equipmentRect.x + equipmentRect.width, y: equipmentRect.y + equipmentRect.height }
                ];

                // Also check if circle center is inside rectangle
                const circleInRect = (
                    obstacle.circle.centerX >= equipmentRect.x &&
                    obstacle.circle.centerX <= equipmentRect.x + equipmentRect.width &&
                    obstacle.circle.centerY >= equipmentRect.y &&
                    obstacle.circle.centerY <= equipmentRect.y + equipmentRect.height
                );

                // Check if any corner is inside the clearance circle
                const cornerInCircle = corners.some(corner => {
                    const dx = corner.x - obstacle.circle.centerX;
                    const dy = corner.y - obstacle.circle.centerY;
                    return (dx * dx + dy * dy) <= (clearanceRadius * clearanceRadius);
                });

                equipmentIntersects = circleInRect || cornerInCircle;
            } else {
                const polygon = getObstaclePolygon(obstacle);
                if (!polygon || polygon.length < 3) return;

                // Draw original polygon outline
                ctx.save();
                ctx.strokeStyle = isSelected ? '#4caf50' : '#00ff00';
                ctx.lineWidth = isSelected ? 5 : 3;
                ctx.lineJoin = 'round';
                tracePolygon(ctx, polygon);
                ctx.stroke();
                ctx.restore();

                // Draw clearance zone with smooth arcs at corners
                drawClearanceZoneWithArcs(ctx, polygon, clearanceDistance, rule.color, rule.stroke);

                // Check if equipment rectangle intersects with clearance zone
                // Create the clearance zone and check intersection
                const clearancePolygon = offsetPolygon(polygon, clearanceDistance);
                equipmentIntersects = polygonIntersectsRect(clearancePolygon, equipmentRect);
            }

            if (equipmentIntersects) {
                violations.push({ obstacle, rule });
            }
        });

        // Draw equipment with actual size and service clearances
        // First draw service clearance zones for the equipment itself
        const serviceColor = 'rgba(0, 255, 255, 0.2)'; // Cyan for service clearances
        ctx.fillStyle = serviceColor;
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 5;
        ctx.setLineDash([5, 5]);

        // Draw service clearance envelope around equipment
        rules.forEach(rule => {
            if (rule.zone_type === 'service') {
                const servicePx = {
                    above: rule.clearances.above * state.scale.pixelsPerMM,
                    below: rule.clearances.below * state.scale.pixelsPerMM,
                    sides: rule.clearances.sides * state.scale.pixelsPerMM
                };

                const serviceX = equipmentRect.x - servicePx.sides;
                const serviceY = equipmentRect.y - servicePx.above;
                const serviceWidth = equipmentRect.width + (2 * servicePx.sides);
                const serviceHeight = equipmentRect.height + servicePx.above + servicePx.below;

                ctx.strokeRect(serviceX, serviceY, serviceWidth, serviceHeight);
            }
        });

        ctx.setLineDash([]);

        // Draw equipment rectangle with actual dimensions
        ctx.fillStyle = violations.length > 0 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.5)';
        ctx.strokeStyle = violations.length > 0 ? '#ff0000' : '#00ff00';
        ctx.lineWidth = 8;
        ctx.fillRect(equipmentRect.x, equipmentRect.y, equipmentRect.width, equipmentRect.height);
        ctx.strokeRect(equipmentRect.x, equipmentRect.y, equipmentRect.width, equipmentRect.height);

        // Draw center point marker
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(state.equipment.x, state.equipment.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 5;
        ctx.stroke();

        // Draw dimension labels
        ctx.fillStyle = '#000';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${dimensions.width}mm √ó ${dimensions.height}mm`, equipmentRect.x + equipmentRect.width / 2, equipmentRect.y - 10);

        displayComplianceResult(violations);
    }

    function displayComplianceResult(violations) {
        const resultDiv = document.getElementById('complianceResult');
        
        if (violations.length === 0) {
            resultDiv.className = 'compliance-result compliance-pass';
            resultDiv.innerHTML = `‚úÖ COMPLIANT<br>${EQUIPMENT_INFO[state.equipmentType].name} position meets all clearance requirements.`;
        } else {
            resultDiv.className = 'compliance-result compliance-fail';
            let html = '‚ùå NON-COMPLIANT<br><ul class="violation-list">';
            violations.forEach(v => {
                const typeLabel = OBSTACLE_LABELS[v.obstacle.type];
                html += `<li>Too close to ${typeLabel} (requires ${Math.max(v.rule.clearances.above, v.rule.clearances.sides, v.rule.clearances.below)}mm clearance)</li>`;
            });
            html += '</ul>';
            resultDiv.innerHTML = html;
        }
    }

    document.getElementById('downloadBtn').addEventListener('click', () => {
        const canvas = document.getElementById('photoCanvas4');
        const link = document.createElement('a');
        link.download = `clearance-check-${state.equipmentType}-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
    });

    // AI Paint Mask Confirmation
    async function confirmPaintMaskWithAI() {
        if (state.paintMasks.length === 0) {
            alert('No painted areas to confirm. Please paint an area first.');
            return;
        }

        const btn = document.getElementById('confirmPaintMaskBtn');
        btn.disabled = true;
        btn.textContent = 'üîÑ Analyzing...';

        try {
            // Create a temporary canvas to extract the masked region from the original photo
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // Calculate bounding box for all paint strokes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.paintMasks.forEach(mask => {
                mask.stroke.forEach(point => {
                    const padding = mask.brushSize;
                    minX = Math.min(minX, point.x - padding);
                    minY = Math.min(minY, point.y - padding);
                    maxX = Math.max(maxX, point.x + padding);
                    maxY = Math.max(maxY, point.y + padding);
                });
            });

            // Add some extra padding
            const padding = 20;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(state.photoWidth, maxX + padding);
            maxY = Math.min(state.photoHeight, maxY + padding);

            const cropWidth = maxX - minX;
            const cropHeight = maxY - minY;

            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;

            // Draw the cropped region from the ORIGINAL PHOTO (not the canvas with drawings)
            tempCtx.drawImage(state.photo, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            // Convert to base64
            const imageBase64 = tempCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];

            // Get user's AI message if provided
            const aiMessageInput = document.getElementById('aiMessageInput');
            const aiMessage = aiMessageInput ? aiMessageInput.value.trim() : '';

            // Send to AI for confirmation
            const response = await fetch('https://clearance.martinbibb.workers.dev', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    image: imageBase64,
                    equipmentType: state.equipmentType,
                    detectObjects: EQUIPMENT_INFO[state.equipmentType].obstacles,
                    cropMetadata: {
                        originX: minX,
                        originY: minY,
                        width: cropWidth,
                        height: cropHeight,
                        fullImageWidth: state.photoWidth,
                        fullImageHeight: state.photoHeight
                    },
                    useHybridDetection: true,
                    preciseBoundaries: true,
                    prompt: `Identify and locate the exact position and dimensions of objects in this painted/masked region. Return bounds for detected objects with pixel-level accuracy.`,
                    userMessage: aiMessage // User's optional context
                })
            });

            if (!response.ok) {
                throw new Error(`API returned error status ${response.status}`);
            }

            const result = await response.json();

            // Check for obstacles in response (API returns 'objects' not 'obstacles')
            if (result.objects && result.objects.length > 0) {
                // Scale factor: API returns coordinates based on 1000x1000 reference
                const scaleX = cropWidth / 1000;
                const scaleY = cropHeight / 1000;

                // Add detected objects as obstacles
                result.objects.forEach(detection => {
                    const mappedBounds = {
                        x: (detection.bounds.x * scaleX) + minX,
                        y: (detection.bounds.y * scaleY) + minY,
                        width: detection.bounds.width * scaleX,
                        height: detection.bounds.height * scaleY
                    };

                    const maskStrokes = buildMaskStrokesForBounds(mappedBounds);

                    const obstacle = normalizeObstacleGeometry({
                        type: detection.type,
                        shape: maskStrokes.length ? 'mask' : 'rectangle',
                        bounds: mappedBounds,
                        maskStrokes: maskStrokes.length ? maskStrokes : undefined,
                        aiConfirmed: true
                    });
                    state.obstacles.push(obstacle);
                });

                // Clear paint masks after confirmation
                state.paintMasks = [];
                updateObstacleList();
                const ctx = document.getElementById('photoCanvas3').getContext('2d');
                drawPhotoWithObstacles(ctx);

                const aiService = result.aiServiceUsed === 'claude' ? 'Claude' : 'OpenAI';
                alert(`‚úÖ AI confirmed ${result.objects.length} object(s) in the painted region! (${aiService})`);
            } else {
                alert('‚ùå AI could not detect any objects in the painted region. Try painting more clearly or use manual tools.');
            }

        } catch (error) {
            console.error('AI confirmation error:', error);
            alert(`‚ùå Error confirming with AI: ${error.message}\n\nPlease try again or use manual marking tools.`);
        } finally {
            btn.disabled = false;
            btn.textContent = 'ü§ñ Confirm Masked Area with AI';
        }
    }

    document.getElementById('startOverBtn').addEventListener('click', () => {
        location.reload();
    });

    // Force reset button - properly resets state without page reload
    document.getElementById('forceResetBtn').addEventListener('click', () => {
        if (confirm('This will clear all data and start fresh. Are you sure?')) {
            resetApplication();
        }
    });

    function resetApplication() {
        // Reset state to initial values
        state.equipmentType = null;
        state.photo = null;
        state.photoWidth = 0;
        state.photoHeight = 0;
        state.scale = {
            point1: null,
            point2: null,
            point3: null,
            point4: null,
            calibrationMode: 'two-point',
            distanceMM: 85,
            pixelsPerMM: 0,
            perspectiveWarning: false
        };
        state.equipment = null;
        state.obstacles = [];
        state.brand = null;
        state.model = null;
        state.currentObstacleStart = null;
        state.currentMagnifierPosition = null;
        state.lassoMode = false;
        state.lassoPoints = [];
        state.lassoComplete = false;
        state.drawingTool = 'rectangle';
        state.paintMasks = [];
        state.isPainting = false;
        state.currentPaintStroke = null;

        // Clear all canvases
        ['photoCanvas', 'photoCanvas2', 'photoCanvas3', 'photoCanvas4', 'magnifyCanvas'].forEach(id => {
            const canvas = document.getElementById(id);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        // Reset all form inputs
        document.getElementById('brand').innerHTML = '';
        document.getElementById('obstacleType').innerHTML = '';
        document.getElementById('knownDistance').value = '85';

        // Clear obstacle list
        document.getElementById('obstacleList').innerHTML = '';

        // Hide all steps except step 0
        document.querySelectorAll('.step').forEach(step => step.classList.add('hidden'));
        document.getElementById('step0').classList.remove('hidden');

        // Clear equipment type selection
        document.querySelectorAll('.equipment-type-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        // Reset info box
        document.getElementById('equipmentInfo').innerHTML = 'Select the type of equipment you\'re checking clearances for.';
    }
</script>

</body>
</html>
