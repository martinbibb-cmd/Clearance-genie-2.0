<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie - Service & Installation Clearance Checker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f5f5f5;
        color: #333;
        overflow-x: hidden;
    }

    .container {
        max-width: 100%;
        margin: 0 auto;
        padding: 10px;
    }

    h1 {
        font-size: 24px;
        margin: 20px 0;
        text-align: center;
        color: #2c3e50;
    }

    .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 14px;
        margin-bottom: 20px;
    }

    .step {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .step h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #34495e;
        display: flex;
        align-items: center;
    }

    .step-number {
        background: #3498db;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        font-weight: bold;
    }

    .hidden {
        display: none !important;
    }

    button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        font-weight: 600;
    }

    button:active {
        background: #2980b9;
    }

    button:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }

    button.secondary {
        background: #95a5a6;
    }

    button.danger {
        background: #e74c3c;
    }

    input[type="file"] {
        display: none;
    }

    .file-upload-btn {
        display: block;
        text-align: center;
        padding: 40px;
        border: 2px dashed #3498db;
        border-radius: 8px;
        cursor: pointer;
        background: #ecf0f1;
    }

    .file-upload-btn:hover {
        background: #d5dbdb;
    }

    #photoCanvas,
    #photoCanvas2,
    #photoCanvas3,
    #photoCanvas4 {
        width: 100%;
        max-width: 100%;
        border: 2px solid #3498db;
        border-radius: 8px;
        margin: 10px 0;
        display: block;
        touch-action: none;
    }

    .input-group {
        margin: 15px 0;
    }

    .input-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #555;
    }

    .input-group input,
    .input-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
    }

    .instructions {
        background: #e8f4f8;
        padding: 12px;
        border-radius: 6px;
        margin: 10px 0;
        font-size: 14px;
        line-height: 1.5;
    }

    .equipment-type-selector {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
    }

    .equipment-type-btn {
        padding: 40px 20px;
        border: 3px solid #ddd;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s;
    }

    .equipment-type-btn:hover {
        border-color: #3498db;
    }

    .equipment-type-btn.active {
        border-color: #3498db;
        background: #e8f4f8;
    }

    .equipment-type-btn .icon {
        font-size: 40px;
        margin-bottom: 10px;
    }

    .equipment-type-btn .label {
        font-weight: 600;
        color: #2c3e50;
    }

    .obstacle-list {
        margin: 15px 0;
    }

    .obstacle-item {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 6px;
        margin: 8px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .obstacle-item button {
        width: auto;
        padding: 6px 12px;
        margin: 0;
        font-size: 14px;
    }

    .compliance-result {
        padding: 20px;
        border-radius: 8px;
        margin: 15px 0;
        font-weight: 600;
        text-align: center;
    }

    .compliance-pass {
        background: #d4edda;
        color: #155724;
        border: 2px solid #c3e6cb;
    }

    .compliance-fail {
        background: #f8d7da;
        color: #721c24;
        border: 2px solid #f5c6cb;
    }

    .violation-list {
        list-style: none;
        margin-top: 10px;
        text-align: left;
    }

    .violation-list li {
        padding: 8px;
        margin: 5px 0;
        background: rgba(255,255,255,0.5);
        border-radius: 4px;
    }

    .legend {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        flex-wrap: wrap;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin: 5px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 8px;
    }

    .info-box {
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 6px;
        padding: 12px;
        margin: 10px 0;
        font-size: 14px;
    }

    .info-box strong {
        color: #856404;
    }

    @media (max-width: 600px) {
        .container {
            padding: 5px;
        }
        
        h1 {
            font-size: 20px;
            margin: 10px 0;
        }
        
        .step {
            padding: 15px;
            margin: 10px 0;
        }

        .equipment-type-selector {
            grid-template-columns: 1fr;
        }
    }

    /* Magnifying glass mark position button - Enhanced for mobile touch */
    #markPositionBtn:hover {
        background: rgba(52, 152, 219, 1);
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    }

    #markPositionBtn:active {
        background: rgba(41, 128, 185, 1);
        transform: translate(-50%, -50%) scale(0.95);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    /* Ensure button is accessible on touch devices */
    #markPositionBtn {
        min-width: 56px;
        min-height: 56px;
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>
        <div class="subtitle">Service & Installation Clearance Checker</div>

```
    <!-- Step 0: Select Equipment Type -->
    <div class="step" id="step0">
        <h2><span class="step-number">0</span> Select Equipment Type</h2>
        <div class="equipment-type-selector">
            <div class="equipment-type-btn" onclick="selectEquipmentType('flue')">
                <div class="icon">üå¨Ô∏è</div>
                <div class="label">Flue Terminal</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('boiler')">
                <div class="icon">üî•</div>
                <div class="label">Boiler</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('radiator')">
                <div class="icon">‚ô®Ô∏è</div>
                <div class="label">Radiator</div>
            </div>
            <div class="equipment-type-btn" onclick="selectEquipmentType('cylinder')">
                <div class="icon">üõ¢Ô∏è</div>
                <div class="label">Cylinder</div>
            </div>
        </div>
        <div class="info-box" id="equipmentInfo">
            Select the type of equipment you're checking clearances for.
        </div>
    </div>

    <!-- Step 1: Upload Photo -->
    <div class="step hidden" id="step1">
        <h2><span class="step-number">1</span> Add Photo</h2>
        <div class="instructions">
            Choose how you want to add a photo:
        </div>
        <label for="photoCameraInput" class="file-upload-btn" style="margin-bottom: 10px;">
            üì∏ Take Photo with Camera
        </label>
        <input type="file" id="photoCameraInput" accept="image/*" capture="environment">
        <label for="photoUploadInput" class="file-upload-btn">
            üìÅ Upload Existing Photo
        </label>
        <input type="file" id="photoUploadInput" accept="image/*">
    </div>

    <!-- Step 2: Set Scale -->
    <div class="step hidden" id="step2">
        <h2><span class="step-number">2</span> Set Scale</h2>

        <!-- AI Detection with Lasso Section -->
        <div class="instructions">
            <strong>ü§ñ Option 1: AI-Assisted Detection (Recommended)</strong><br>
            <strong>Step 1:</strong> Draw a rough lasso around your reference object (üîµ blue card or brick)<br>
            <strong>Step 2:</strong> AI will find exact edges within that area
            <ul style="margin: 5px 0 5px 20px;">
                <li><strong>üîµ Blue credit/debit card</strong> (85.6mm √ó 54mm) - Best accuracy</li>
                <li><strong>Standard UK brick</strong> (215mm √ó 102.5mm) - Good for outdoor photos</li>
            </ul>
        </div>
        <div class="instructions" style="background: #e3f2fd; border-left: 4px solid #2196f3;">
            üí° <strong>How it works:</strong> You roughly circle the card, AI refines the exact edges. Much more reliable than auto-detect!
        </div>
        <button id="startLassoBtn" style="margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            ‚úèÔ∏è Draw Lasso Around Card/Brick
        </button>
        <button id="detectInLassoBtn" style="margin-bottom: 20px; display: none; background: #2e7d32;">
            ü§ñ Detect Card in Selected Area
        </button>
        <button id="cancelLassoBtn" style="margin-bottom: 20px; display: none; background: #e74c3c;">
            ‚úñ Cancel Lasso
        </button>
        <div id="lassoStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Manual Calibration Section -->
        <div class="instructions" style="background: #fff9e6; border-left: 4px solid #ff9800; margin-top: 20px;">
            <strong>üìè Option 2: Manual Calibration</strong><br>
            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px; font-family: monospace; text-align: center;">
                <strong>Example: Measuring credit card width</strong><br>
                <div style="margin: 10px 0; font-size: 18px;">
                    üìç<span style="color: #2e7d32;">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>üìç<br>
                    <span style="font-size: 12px;">üëÜ Point 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85mm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point 2 üëÜ</span>
                </div>
            </div>
            <strong style="color: #e65100;">Step 1:</strong> Move mouse/finger over the photo to see magnifying glass<br>
            <strong style="color: #e65100;">Step 2:</strong> Click the üìç button in the center of the magnifying glass to mark TWO points<br>
            <strong style="color: #e65100;">Step 3:</strong> Enter the distance between those points (85mm for card width)<br>
            <span style="font-size: 0.9em;">üîµ <strong>Blue card recommended for best results</strong> | Standard card: <strong>Width = 85mm</strong> | Height = 54mm</span>
        </div>
        <div id="manualCalibrationGuide" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 14px; display: none;">
            <strong>üìå Point 1:</strong> <span id="point1Status" style="color: #e74c3c;">Not set - Click the üìç button in magnifying glass</span>
            <button id="undoPoint1Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(1)">‚Ü∂ Undo</button><br>
            <strong>üìå Point 2:</strong> <span id="point2Status" style="color: #95a5a6;">Waiting for Point 1...</span>
            <button id="undoPoint2Btn" style="display: none; padding: 3px 10px; font-size: 12px; margin-left: 10px; background: #e74c3c;" onclick="undoPoint(2)">‚Ü∂ Undo</button>
            <br>
            <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px;">
                üîç <strong>Magnifying glass active</strong> - Move your mouse/finger over the photo to position the magnifying glass, then release. The magnifier stays visible so you can adjust the zoom slider and click the üìç button to mark the exact position.
            </div>
        </div>
        <div style="position: relative; margin: 10px 0;">
            <canvas id="photoCanvas"></canvas>
            <!-- Magnifying Glass -->
            <div id="magnifyingGlass" style="display: none; position: absolute; width: 150px; height: 150px; border: 3px solid #3498db; border-radius: 50%; pointer-events: none; box-shadow: 0 0 15px rgba(0,0,0,0.5); overflow: visible; z-index: 1000; background: white;">
                <canvas id="magnifyCanvas" width="150" height="150"></canvas>
                <div style="position: absolute; top: 50%; left: 50%; width: 2px; height: 20px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <div style="position: absolute; top: 50%; left: 50%; width: 20px; height: 2px; background: #e74c3c; transform: translate(-50%, -50%); pointer-events: none;"></div>
                <!-- Center button for marking positions - Optimized for mobile touch -->
                <button id="markPositionBtn" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 56px; height: 56px; border-radius: 50%; background: rgba(52, 152, 219, 0.9); border: 3px solid white; color: white; font-size: 24px; cursor: pointer; pointer-events: auto; box-shadow: 0 3px 12px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; padding: 0; font-weight: bold; z-index: 1001; touch-action: manipulation; -webkit-tap-highlight-color: rgba(52, 152, 219, 0.3); transition: all 0.15s ease;">üìç</button>
            </div>
            <!-- Zoom Slider -->
            <div id="zoomSliderContainer" style="display: none; position: absolute; background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 999; pointer-events: auto;">
                <label style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 5px; color: #333;">Zoom Level</label>
                <input type="range" id="zoomSlider" min="2" max="8" step="0.5" value="3" style="width: 150px; cursor: pointer;">
                <div style="text-align: center; font-size: 12px; color: #666; margin-top: 3px;"><span id="zoomValue">3</span>x</div>
            </div>
        </div>
        <div class="input-group">
            <label for="knownDistance"><strong>Distance between the two points you tapped:</strong></label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="number" id="knownDistance" placeholder="85" value="85" min="1" style="flex: 1;">
                <span style="font-weight: bold; color: #666;">millimeters (mm)</span>
            </div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                Examples: üîµ Blue card width = 85mm (best), Height = 54mm, Phone width ‚âà 70-80mm
            </div>
        </div>
        <button id="confirmScaleBtn" disabled>‚úì Confirm Scale</button>
        <button class="secondary" id="resetScaleBtn">‚Üª Reset Points & Try Again</button>
    </div>

    <!-- Step 3: Mark Equipment -->
    <div class="step hidden" id="step3">
        <h2><span class="step-number">3</span> Mark <span id="equipmentLabel">Equipment</span> Position</h2>
        <div class="instructions">
            <strong>üìç Find your <span id="equipmentLabel2" style="color: #e74c3c; font-size: 1.1em;">Equipment</span> in the photo below</strong>
        </div>
        <div class="instructions" id="step3Instructions" style="background: #fff3cd; border-left: 4px solid #ffc107;">
            Tap the center of the equipment on the photo.
        </div>
        <canvas id="photoCanvas2"></canvas>
        <button id="confirmEquipmentBtn" disabled>Confirm Position</button>
    </div>

    <!-- Step 4: Mark Obstacles -->
    <div class="step hidden" id="step4">
        <h2><span class="step-number">4</span> Mark Clearance Obstacles</h2>

        <!-- AI Detection Section -->
        <div class="instructions">
            <strong>ü§ñ Option 1: Automatic Detection (Recommended)</strong><br>
            Let AI detect obstacles in your photo automatically.
        </div>
        <div class="instructions" style="background: #e3f2fd; border-left: 4px solid #2196f3;">
            üí° <strong>For best results:</strong> Ensure good lighting and clear visibility of windows, doors, walls, and other obstacles.
        </div>
        <button id="autoDetectObstaclesBtn" style="margin-bottom: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            ü§ñ Auto-Detect Obstacles (AI)
        </button>
        <div id="autoDetectObstaclesStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

        <!-- Manual Marking Section -->
        <div class="instructions" style="background: #fff9e6; border-left: 4px solid #ff9800; margin-top: 20px;" id="step4Instructions">
            <strong>üìè Option 2: Manual Marking</strong><br>
            Draw rectangles around walls, windows, doors, and other obstacles.
        </div>

        <canvas id="photoCanvas3"></canvas>
        <div class="input-group">
            <label for="obstacleType">Obstacle Type:</label>
            <select id="obstacleType">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <div class="obstacle-list" id="obstacleList"></div>
        <button id="nextToRulesBtn">Continue to Clearance Check</button>
    </div>

    <!-- Step 5: Select Brand & Generate -->
    <div class="step hidden" id="step5">
        <h2><span class="step-number">5</span> Select Manufacturer & Check</h2>
        <div class="input-group" id="brandSelectGroup">
            <label for="brand">Manufacturer:</label>
            <select id="brand">
                <!-- Will be populated based on equipment type -->
            </select>
        </div>
        <button id="generateBtn">Generate Clearance Overlay</button>
    </div>

    <!-- Step 6: Results -->
    <div class="step hidden" id="step6">
        <h2><span class="step-number">6</span> Results</h2>
        <canvas id="photoCanvas4"></canvas>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,0,0,0.3);"></div>
                <span>Prohibited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255,165,0,0.3);"></div>
                <span>Warning</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0,255,0,0.3);"></div>
                <span>Service Access</span>
            </div>
        </div>
        
        <div id="complianceResult"></div>
        
        <button id="downloadBtn">Download Annotated Photo</button>
        <button class="secondary" id="startOverBtn">Start Over</button>
    </div>
</div>

<script>
    // Application state
    const state = {
        equipmentType: null,
        photo: null,
        photoWidth: 0,
        photoHeight: 0,
        scale: {
            point1: null,
            point2: null,
            distanceMM: 85,
            pixelsPerMM: 0
        },
        equipment: null,
        obstacles: [],
        brand: null,
        currentObstacleStart: null,
        currentMagnifierPosition: null,
        lassoMode: false,
        lassoPoints: [],
        lassoComplete: false
    };

    // Equipment type configurations
    const EQUIPMENT_INFO = {
        flue: {
            name: "Flue Terminal",
            icon: "üå¨Ô∏è",
            description: "Check clearances around boiler flue terminals to windows, doors, vents, and building features.",
            markingInstruction: "Tap the center of the flue terminal.",
            obstacles: ['opening_window', 'non_opening_window', 'vent', 'door', 'corner', 'ground']
        },
        boiler: {
            name: "Boiler",
            icon: "üî•",
            description: "Check service clearances around the boiler for maintenance access and ventilation.",
            markingInstruction: "Tap the center of the boiler.",
            obstacles: ['wall', 'ceiling', 'floor', 'corner', 'door', 'window']
        },
        radiator: {
            name: "Radiator",
            icon: "‚ô®Ô∏è",
            description: "Check clearances around radiators for air circulation, curtains, and furniture.",
            markingInstruction: "Tap the center of the radiator.",
            obstacles: ['wall', 'floor', 'window', 'curtain_rail', 'furniture', 'socket']
        },
        cylinder: {
            name: "Cylinder",
            icon: "üõ¢Ô∏è",
            description: "Check service clearances around hot water cylinders for maintenance and safety valve access.",
            markingInstruction: "Tap the center of the cylinder.",
            obstacles: ['wall', 'ceiling', 'floor', 'door', 'corner']
        }
    };

    // Comprehensive clearance rules database
    const CLEARANCE_RULES = {
        // FLUE RULES
        flue: {
            worcester_bosch: {
                name: "Worcester Bosch",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'door', clearances: { above: 300, below: 0, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ground', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            },
            vaillant: {
                name: "Vaillant",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'vent', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            },
            ideal: {
                name: "Ideal",
                rules: [
                    { obstacle_type: 'opening_window', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'non_opening_window', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // BOILER RULES
        boiler: {
            worcester_bosch: {
                name: "Worcester Bosch",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'corner', clearances: { above: 300, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 500 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            },
            vaillant: {
                name: "Vaillant",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'ceiling', clearances: { above: 300, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            },
            ideal: {
                name: "Ideal",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // RADIATOR RULES
        radiator: {
            general: {
                name: "General Standards",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 50 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 150, sides: 0 }, zone_type: 'circulation', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'window', clearances: { above: 50, below: 0, sides: 50 }, zone_type: 'recommended', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'curtain_rail', clearances: { above: 100, below: 0, sides: 50 }, zone_type: 'prohibited', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' },
                    { obstacle_type: 'furniture', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'circulation', color: 'rgba(255, 165, 0, 0.3)', stroke: '#ffa500' },
                    { obstacle_type: 'socket', clearances: { above: 150, below: 150, sides: 150 }, zone_type: 'safety', color: 'rgba(255, 0, 0, 0.3)', stroke: '#ff0000' }
                ]
            }
        },
        
        // CYLINDER RULES
        cylinder: {
            general: {
                name: "General Standards",
                rules: [
                    { obstacle_type: 'wall', clearances: { above: 0, below: 0, sides: 150 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'ceiling', clearances: { above: 450, below: 0, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'floor', clearances: { above: 0, below: 300, sides: 0 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'door', clearances: { above: 0, below: 0, sides: 400 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' },
                    { obstacle_type: 'corner', clearances: { above: 450, below: 300, sides: 300 }, zone_type: 'service', color: 'rgba(0, 255, 0, 0.3)', stroke: '#00ff00' }
                ]
            }
        }
    };

    // Obstacle type labels
    const OBSTACLE_LABELS = {
        opening_window: "Opening Window",
        non_opening_window: "Non-Opening Window",
        vent: "Vent / Air Brick",
        door: "Door",
        corner: "Building Corner",
        ground: "Ground Level",
        wall: "Wall",
        ceiling: "Ceiling",
        floor: "Floor",
        window: "Window",
        curtain_rail: "Curtain Rail",
        furniture: "Furniture",
        socket: "Electrical Socket"
    };

    // Step 0: Equipment Type Selection
    window.selectEquipmentType = function(type) {
        state.equipmentType = type;
        
        // Update active button
        document.querySelectorAll('.equipment-type-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.closest('.equipment-type-btn').classList.add('active');
        
        // Update info box
        const info = EQUIPMENT_INFO[type];
        document.getElementById('equipmentInfo').innerHTML = `
            <strong>${info.icon} ${info.name}:</strong> ${info.description}
        `;
        
        // Show next step button
        setTimeout(() => {
            document.getElementById('step0').classList.add('hidden');
            document.getElementById('step1').classList.remove('hidden');
        }, 500);
    };

    // Utility: Get canvas coordinates from touch/click event
    function getCanvasCoordinates(canvas, event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // Step 1: Photo Upload (handles both camera and file upload)
    function handlePhotoUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                state.photo = img;
                state.photoWidth = img.width;
                state.photoHeight = img.height;

                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
                setupScaleCanvas();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('photoCameraInput').addEventListener('change', handlePhotoUpload);
    document.getElementById('photoUploadInput').addEventListener('change', handlePhotoUpload);

    // Step 2: Scale Calibration
    function setupScaleCanvas() {
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        drawPhotoAndPoints(ctx);

        // Add magnifying glass on hover/touch (no click handlers - only button marks positions)
        canvas.addEventListener('mousemove', handleMagnifyMove);
        canvas.addEventListener('mouseenter', showMagnifier);
        canvas.addEventListener('mouseleave', hideMagnifier);
        canvas.addEventListener('touchmove', handleMagnifyTouch);
        canvas.addEventListener('touchstart', showMagnifierTouch);
        // Note: No touchend handler - magnifier stays visible for button click

        // Add button click/touch handlers for marking positions
        // Support both touch and click events for better mobile reliability
        const markBtn = document.getElementById('markPositionBtn');
        let touchHandled = false;

        markBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            touchHandled = true;
            handleMarkPositionClick(e);
            // Reset flag after a short delay to allow click event filtering
            setTimeout(() => { touchHandled = false; }, 300);
        });

        markBtn.addEventListener('click', (e) => {
            // Prevent double-firing on devices that emit both touch and click
            if (touchHandled) {
                e.preventDefault();
                return;
            }
            handleMarkPositionClick(e);
        });

        // Add zoom slider handler
        const zoomSlider = document.getElementById('zoomSlider');
        zoomSlider.addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = e.target.value;
        });
    }

    function showMagnifier() {
        document.getElementById('magnifyingGlass').style.display = 'block';
        document.getElementById('zoomSliderContainer').style.display = 'block';
    }

    function hideMagnifier() {
        document.getElementById('magnifyingGlass').style.display = 'none';
        document.getElementById('zoomSliderContainer').style.display = 'none';
    }

    function showMagnifierTouch(e) {
        // Don't prevent default here - let touchmove handle it
        showMagnifier();
    }

    function handleMagnifyMove(e) {
        const canvas = document.getElementById('photoCanvas');
        const magnifier = document.getElementById('magnifyingGlass');
        const magnifyCanvas = document.getElementById('magnifyCanvas');
        const magnifyCtx = magnifyCanvas.getContext('2d');
        const zoomSliderContainer = document.getElementById('zoomSliderContainer');

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Position magnifier near cursor (offset to avoid blocking view)
        const magnifierLeft = e.clientX - rect.left + 20;
        const magnifierTop = e.clientY - rect.top - 80;
        magnifier.style.left = magnifierLeft + 'px';
        magnifier.style.top = magnifierTop + 'px';

        // Position zoom slider below magnifier
        zoomSliderContainer.style.left = magnifierLeft + 'px';
        zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

        // Get canvas coordinates
        const canvasX = (x * canvas.width) / rect.width;
        const canvasY = (y * canvas.height) / rect.height;

        // Store current canvas position for button click handler
        state.currentMagnifierPosition = { canvasX, canvasY };

        // Draw magnified portion (use zoom slider value)
        const zoom = parseFloat(document.getElementById('zoomSlider').value);
        const magRadius = 75; // Half of magnifier size
        const sourceSize = magRadius / zoom;

        magnifyCtx.clearRect(0, 0, 150, 150);
        magnifyCtx.drawImage(
            state.photo,
            Math.max(0, canvasX - sourceSize),
            Math.max(0, canvasY - sourceSize),
            sourceSize * 2,
            sourceSize * 2,
            0, 0, 150, 150
        );
    }

    function handleMagnifyTouch(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            const canvas = document.getElementById('photoCanvas');
            const magnifier = document.getElementById('magnifyingGlass');
            const magnifyCanvas = document.getElementById('magnifyCanvas');
            const magnifyCtx = magnifyCanvas.getContext('2d');
            const zoomSliderContainer = document.getElementById('zoomSliderContainer');

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Show magnifier
            magnifier.style.display = 'block';
            zoomSliderContainer.style.display = 'block';

            // Position magnifier above touch point
            const magnifierLeft = touch.clientX - rect.left + 20;
            const magnifierTop = touch.clientY - rect.top - 180;
            magnifier.style.left = magnifierLeft + 'px';
            magnifier.style.top = magnifierTop + 'px';

            // Position zoom slider below magnifier (but above touch point)
            zoomSliderContainer.style.left = magnifierLeft + 'px';
            zoomSliderContainer.style.top = (magnifierTop + 160) + 'px';

            // Get canvas coordinates
            const canvasX = (x * canvas.width) / rect.width;
            const canvasY = (y * canvas.height) / rect.height;

            // Store current canvas position for button click handler
            state.currentMagnifierPosition = { canvasX, canvasY };

            // Draw magnified portion (use zoom slider value)
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            const magRadius = 75;
            const sourceSize = magRadius / zoom;

            magnifyCtx.clearRect(0, 0, 150, 150);
            magnifyCtx.drawImage(
                state.photo,
                Math.max(0, canvasX - sourceSize),
                Math.max(0, canvasY - sourceSize),
                sourceSize * 2,
                sourceSize * 2,
                0, 0, 150, 150
            );
        }
    }

    // Mark position button click handler (triggered when user clicks the center button)
    function handleMarkPositionClick(e) {
        e.stopPropagation(); // Prevent event bubbling

        if (!state.currentMagnifierPosition) {
            return; // No position stored yet
        }

        const coords = {
            x: state.currentMagnifierPosition.canvasX,
            y: state.currentMagnifierPosition.canvasY
        };

        handleScalePoint(coords);

        // Keep magnifier visible for marking the second point
        // User can reposition by touching/moving on the canvas again
    }

    function handleScalePoint(coords) {
        // Show the manual calibration guide when user starts clicking button
        const guide = document.getElementById('manualCalibrationGuide');
        guide.style.display = 'block';

        if (!state.scale.point1) {
            state.scale.point1 = coords;
            // Update status
            document.getElementById('point1Status').textContent = '‚úì Set';
            document.getElementById('point1Status').style.color = '#2e7d32';
            document.getElementById('undoPoint1Btn').style.display = 'inline-block';
            document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
            document.getElementById('point2Status').style.color = '#e74c3c';
        } else if (!state.scale.point2) {
            state.scale.point2 = coords;
            document.getElementById('confirmScaleBtn').disabled = false;
            // Update status
            document.getElementById('point2Status').textContent = '‚úì Set';
            document.getElementById('point2Status').style.color = '#2e7d32';
            document.getElementById('undoPoint2Btn').style.display = 'inline-block';
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    // Undo point function
    function undoPoint(pointNumber) {
        if (pointNumber === 1) {
            state.scale.point1 = null;
            state.scale.point2 = null; // Also reset point 2 if undoing point 1
            document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
            document.getElementById('point1Status').style.color = '#e74c3c';
            document.getElementById('undoPoint1Btn').style.display = 'none';
            document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
            document.getElementById('point2Status').style.color = '#95a5a6';
            document.getElementById('undoPoint2Btn').style.display = 'none';
            document.getElementById('confirmScaleBtn').disabled = true;
        } else if (pointNumber === 2) {
            state.scale.point2 = null;
            document.getElementById('point2Status').textContent = 'Click the üìç button for second point';
            document.getElementById('point2Status').style.color = '#e74c3c';
            document.getElementById('undoPoint2Btn').style.display = 'none';
            document.getElementById('confirmScaleBtn').disabled = true;
        }

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    }

    function drawPhotoAndPoints(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);

        // Draw lasso if in lasso mode
        if (state.lassoPoints.length > 0) {
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(state.lassoPoints[0].x, state.lassoPoints[0].y);
            for (let i = 1; i < state.lassoPoints.length; i++) {
                ctx.lineTo(state.lassoPoints[i].x, state.lassoPoints[i].y);
            }
            if (state.lassoComplete) {
                ctx.closePath();
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Fill semi-transparent if complete
            if (state.lassoComplete) {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fill();
            }
        }

        if (state.scale.point1) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(state.scale.point1.x, state.scale.point1.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        if (state.scale.point2) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(state.scale.point2.x, state.scale.point2.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(state.scale.point1.x, state.scale.point1.y);
            ctx.lineTo(state.scale.point2.x, state.scale.point2.y);
            ctx.stroke();
        }
    }

    document.getElementById('resetScaleBtn').addEventListener('click', () => {
        state.scale.point1 = null;
        state.scale.point2 = null;
        document.getElementById('confirmScaleBtn').disabled = true;

        // Hide magnifier when resetting
        hideMagnifier();

        // Reset lasso
        state.lassoMode = false;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Reset the guide status
        document.getElementById('manualCalibrationGuide').style.display = 'none';
        document.getElementById('point1Status').textContent = 'Not set - Click the üìç button in magnifying glass';
        document.getElementById('point1Status').style.color = '#e74c3c';
        document.getElementById('undoPoint1Btn').style.display = 'none';
        document.getElementById('point2Status').textContent = 'Waiting for Point 1...';
        document.getElementById('point2Status').style.color = '#95a5a6';
        document.getElementById('undoPoint2Btn').style.display = 'none';

        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    });

    // Lasso Tool Functionality
    document.getElementById('startLassoBtn').addEventListener('click', () => {
        state.lassoMode = true;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Hide magnifier during lasso
        hideMagnifier();

        // Update UI
        document.getElementById('startLassoBtn').style.display = 'none';
        document.getElementById('cancelLassoBtn').style.display = 'inline-block';
        document.getElementById('lassoStatus').style.display = 'block';
        document.getElementById('lassoStatus').style.background = '#e3f2fd';
        document.getElementById('lassoStatus').style.color = '#1976d2';
        document.getElementById('lassoStatus').textContent = '‚úèÔ∏è Draw around the card or brick, then release to finish';

        // Enable lasso drawing on canvas
        const canvas = document.getElementById('photoCanvas');
        canvas.style.cursor = 'crosshair';
    });

    document.getElementById('cancelLassoBtn').addEventListener('click', () => {
        state.lassoMode = false;
        state.lassoPoints = [];
        state.lassoComplete = false;

        // Reset UI
        document.getElementById('startLassoBtn').style.display = 'inline-block';
        document.getElementById('cancelLassoBtn').style.display = 'none';
        document.getElementById('detectInLassoBtn').style.display = 'none';
        document.getElementById('lassoStatus').style.display = 'none';

        const canvas = document.getElementById('photoCanvas');
        canvas.style.cursor = 'default';
        const ctx = canvas.getContext('2d');
        drawPhotoAndPoints(ctx);
    });

    // Add lasso drawing to canvas
    function setupLassoDrawing() {
        const canvas = document.getElementById('photoCanvas');

        let isDrawing = false;

        canvas.addEventListener('mousedown', (e) => {
            if (!state.lassoMode) return;
            isDrawing = true;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.lassoMode || !isDrawing) return;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);
        });

        canvas.addEventListener('mouseup', () => {
            if (!state.lassoMode || !isDrawing) return;
            isDrawing = false;
            state.lassoComplete = true;
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);

            // Show detect button
            document.getElementById('detectInLassoBtn').style.display = 'inline-block';
            document.getElementById('lassoStatus').textContent = '‚úÖ Lasso complete! Click "Detect Card" to find edges with AI';
            document.getElementById('lassoStatus').style.background = '#e8f5e9';
            document.getElementById('lassoStatus').style.color = '#2e7d32';
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!state.lassoMode) return;
            e.preventDefault();
            isDrawing = true;
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!state.lassoMode || !isDrawing) return;
            e.preventDefault();
            const coords = getCanvasCoordinates(canvas, e);
            state.lassoPoints.push(coords);
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);
        });

        canvas.addEventListener('touchend', () => {
            if (!state.lassoMode || !isDrawing) return;
            isDrawing = false;
            state.lassoComplete = true;
            const ctx = canvas.getContext('2d');
            drawPhotoAndPoints(ctx);

            // Show detect button
            document.getElementById('detectInLassoBtn').style.display = 'inline-block';
            document.getElementById('lassoStatus').textContent = '‚úÖ Lasso complete! Click "Detect Card" to find edges with AI';
            document.getElementById('lassoStatus').style.background = '#e8f5e9';
            document.getElementById('lassoStatus').style.color = '#2e7d32';
        });
    }

    // Call setup after canvas is ready
    setTimeout(() => {
        const canvas = document.getElementById('photoCanvas');
        if (canvas) {
            setupLassoDrawing();
        }
    }, 100);

    // Detect Card in Lasso Region using AI
    document.getElementById('detectInLassoBtn').addEventListener('click', async () => {
        const statusDiv = document.getElementById('lassoStatus');
        const btn = document.getElementById('detectInLassoBtn');

        // Show loading status
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Analyzing selected region with AI...';
        btn.disabled = true;

        try {
            // Calculate bounding box from lasso points
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.lassoPoints.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });

            // Add padding (20%) to bounding box
            const padding = 0.2;
            const width = maxX - minX;
            const height = maxY - minY;
            const paddedMinX = Math.max(0, minX - width * padding);
            const paddedMinY = Math.max(0, minY - height * padding);
            const paddedMaxX = Math.min(state.photoWidth, maxX + width * padding);
            const paddedMaxY = Math.min(state.photoHeight, maxY + height * padding);
            const paddedWidth = paddedMaxX - paddedMinX;
            const paddedHeight = paddedMaxY - paddedMinY;

            // Crop image to lasso region
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = paddedWidth;
            cropCanvas.height = paddedHeight;
            cropCtx.drawImage(
                state.photo,
                paddedMinX, paddedMinY, paddedWidth, paddedHeight,
                0, 0, paddedWidth, paddedHeight
            );

            // Convert cropped image to base64
            const croppedImageBase64 = cropCanvas.toDataURL('image/jpeg', 0.8);

            // Call AI Worker with cropped image and crop metadata
            let response;
            try {
                response = await fetch('https://clearance.martinbibb.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: croppedImageBase64,
                        equipmentType: state.equipmentType,
                        detectObjects: [],
                        cardColorHint: 'blue',
                        cropMetadata: {
                            originX: paddedMinX,
                            originY: paddedMinY,
                            width: paddedWidth,
                            height: paddedHeight,
                            fullImageWidth: state.photoWidth,
                            fullImageHeight: state.photoHeight
                        },
                        useHybridDetection: true // Flag to tell AI this is a user-hinted crop
                    }),
                    signal: AbortSignal.timeout(30000)
                });
            } catch (fetchError) {
                if (fetchError.name === 'TimeoutError') {
                    throw new Error('Request timed out. Try drawing a smaller lasso around just the card.');
                } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('Load failed')) {
                    throw new Error('Cannot connect to AI service. Check your internet connection.');
                }
                throw new Error(`Network error: ${fetchError.message}`);
            }

            if (!response.ok) {
                let errorMessage = `API returned error status ${response.status}`;
                try {
                    const errorData = await response.json();
                    if (errorData.error) {
                        errorMessage = errorData.error;
                    }
                } catch (e) {}
                throw new Error(errorMessage);
            }

            const result = await response.json();

            // Check what was detected in the cropped region
            if (result.calibration && result.calibration.creditCardDetected) {
                // CREDIT CARD DETECTED in crop
                const cardBounds = result.calibration.creditCardBounds.bounds;

                // Scale factor: API returns coordinates based on 1000x1000 reference of CROPPED image
                const scaleX = paddedWidth / 1000;
                const scaleY = paddedHeight / 1000;

                // Scale card bounds to cropped image dimensions
                const cardWidthPx = cardBounds.width * scaleX;
                const cardHeightPx = cardBounds.height * scaleY;

                // Determine which dimension is width (should be larger for credit card)
                const actualCardWidthPx = Math.max(cardWidthPx, cardHeightPx);

                // Calculate pixels per mm based on 85mm credit card width
                state.scale.pixelsPerMM = actualCardWidthPx / 85;
                state.scale.distanceMM = 85; // Credit card width

                // Reset lasso UI
                state.lassoMode = false;
                state.lassoPoints = [];
                state.lassoComplete = false;
                document.getElementById('startLassoBtn').style.display = 'inline-block';
                document.getElementById('cancelLassoBtn').style.display = 'none';
                document.getElementById('detectInLassoBtn').style.display = 'none';

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>üîµ Blue card detected in lasso!</strong><br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.creditCardBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: 85mm blue card width`;

                // Auto-advance to next step after 1.5 seconds
                setTimeout(() => {
                    // Hide magnifier when moving to next step
                    hideMagnifier();

                    document.getElementById('step2').classList.add('hidden');
                    document.getElementById('step3').classList.remove('hidden');

                    // Update step 3 labels
                    const info = EQUIPMENT_INFO[state.equipmentType];
                    document.getElementById('equipmentLabel').textContent = info.name;
                    document.getElementById('equipmentLabel2').textContent = info.name;
                    document.getElementById('step3Instructions').textContent = info.markingInstruction;

                    setupEquipmentCanvas();
                }, 1500);

            } else if (result.calibration && result.calibration.brickDetected) {
                // BRICK DETECTED (FALLBACK) in cropped region
                const brickBounds = result.calibration.brickBounds.bounds;
                const orientation = result.calibration.brickBounds.orientation;

                // Scale factor: API returns coordinates based on 1000x1000 reference of CROPPED image
                const scaleX = paddedWidth / 1000;
                const scaleY = paddedHeight / 1000;

                // Scale brick bounds to cropped image dimensions
                const brickWidthPx = brickBounds.width * scaleX;
                const brickHeightPx = brickBounds.height * scaleY;

                // Standard UK brick: 215mm x 102.5mm x 65mm
                let referenceMM;
                let actualSizePx;
                let brickDimension;

                if (orientation === 'horizontal') {
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 215;
                    brickDimension = 'length (215mm)';
                } else {
                    actualSizePx = Math.max(brickWidthPx, brickHeightPx);
                    referenceMM = 102.5;
                    brickDimension = 'width (102.5mm)';
                }

                // Calculate pixels per mm based on brick
                state.scale.pixelsPerMM = actualSizePx / referenceMM;
                state.scale.distanceMM = referenceMM;

                // Reset lasso UI
                state.lassoMode = false;
                state.lassoPoints = [];
                state.lassoComplete = false;
                document.getElementById('startLassoBtn').style.display = 'inline-block';
                document.getElementById('cancelLassoBtn').style.display = 'none';
                document.getElementById('detectInLassoBtn').style.display = 'none';

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>Brick detected in lasso!</strong><br>` +
                    `Calibration: ${state.scale.pixelsPerMM.toFixed(2)} pixels/mm<br>` +
                    `Confidence: ${(result.calibration.brickBounds.confidence * 100).toFixed(0)}%<br>` +
                    `Reference: Standard UK brick ${brickDimension}`;

                // Auto-advance to next step
                setTimeout(() => {
                    hideMagnifier();
                    document.getElementById('step2').classList.add('hidden');
                    document.getElementById('step3').classList.remove('hidden');

                    const info = EQUIPMENT_INFO[state.equipmentType];
                    document.getElementById('equipmentLabel').textContent = info.name;
                    document.getElementById('equipmentLabel2').textContent = info.name;
                    document.getElementById('step3Instructions').textContent = info.markingInstruction;

                    setupEquipmentCanvas();
                }, 2000);

            } else {
                // NOTHING DETECTED in lasso region
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.innerHTML = '‚ö†Ô∏è <strong>No card/brick found in lasso region</strong><br><br>' +
                    '<strong>üí° Try again:</strong><br>' +
                    '‚Ä¢ Draw lasso closer around the card/brick<br>' +
                    '‚Ä¢ Make sure the card is fully visible in the lasso<br>' +
                    '‚Ä¢ Ensure good lighting without glare<br>' +
                    '‚Ä¢ üîµ Blue cards work best!<br><br>' +
                    '<strong>Or use Manual Calibration below instead</strong>';
                btn.disabled = false;

                // Show the manual calibration guide
                setTimeout(() => {
                    const canvas = document.getElementById('photoCanvas');
                    canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 500);
            }

        } catch (error) {
            console.error('Auto-detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';

            // Provide specific guidance based on error type
            let guidance = '';
            if (error.message.includes('connect') || error.message.includes('unavailable')) {
                guidance = `<strong>üîå Connection Issue</strong><br>` +
                    `‚Ä¢ Check your internet connection<br>` +
                    `‚Ä¢ The AI service may be temporarily down<br>` +
                    `‚Ä¢ Try refreshing the page and uploading again<br><br>`;
            } else if (error.message.includes('timeout') || error.message.includes('too large')) {
                guidance = `<strong>‚è±Ô∏è Timeout or Large Image</strong><br>` +
                    `‚Ä¢ Try taking a photo at lower resolution<br>` +
                    `‚Ä¢ Compress the image before uploading<br>` +
                    `‚Ä¢ Ensure your internet connection is stable<br><br>`;
            } else if (error.message.includes('API key') || error.message.includes('401') || error.message.includes('403')) {
                guidance = `<strong>üîë Service Configuration Issue</strong><br>` +
                    `‚Ä¢ The AI service may not be properly configured<br>` +
                    `‚Ä¢ Contact support if this persists<br><br>`;
            } else {
                guidance = `<strong>‚ö†Ô∏è Unexpected Error</strong><br>` +
                    `Technical details: ${error.message}<br><br>`;
            }

            statusDiv.innerHTML = `‚ùå <strong>AI Detection Failed</strong><br><br>` +
                guidance +
                `üìù <strong>Solution: Use Manual Calibration below</strong><br>` +
                `1. <strong>Tap two points</strong> on a üîµ blue card (85mm, best) or brick (215mm)<br>` +
                `2. <strong>Enter the distance</strong> in the field below<br>` +
                `3. <strong>Click "Confirm Scale"</strong> to continue`;
            btn.disabled = false;
        }
    });

    document.getElementById('confirmScaleBtn').addEventListener('click', () => {
        const distanceMM = parseFloat(document.getElementById('knownDistance').value);
        if (!distanceMM || distanceMM <= 0) {
            alert('Please enter a valid distance');
            return;
        }

        const pixelDistance = Math.sqrt(
            Math.pow(state.scale.point2.x - state.scale.point1.x, 2) +
            Math.pow(state.scale.point2.y - state.scale.point1.y, 2)
        );

        state.scale.distanceMM = distanceMM;
        state.scale.pixelsPerMM = pixelDistance / distanceMM;

        // Hide magnifier when moving to next step
        hideMagnifier();

        document.getElementById('step2').classList.add('hidden');
        document.getElementById('step3').classList.remove('hidden');

        // Update step 3 labels
        const info = EQUIPMENT_INFO[state.equipmentType];
        document.getElementById('equipmentLabel').textContent = info.name;
        document.getElementById('equipmentLabel2').textContent = info.name;
        document.getElementById('step3Instructions').textContent = info.markingInstruction;

        setupEquipmentCanvas();
    });

    // Step 3: Mark Equipment
    function setupEquipmentCanvas() {
        const canvas = document.getElementById('photoCanvas2');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        drawPhotoWithEquipment(ctx);
        
        canvas.addEventListener('click', handleEquipmentClick);
        canvas.addEventListener('touchstart', handleEquipmentTouchStart);
    }

    function handleEquipmentClick(e) {
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = coords;
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function handleEquipmentTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas2');
        const coords = getCanvasCoordinates(canvas, e);
        state.equipment = coords;
        document.getElementById('confirmEquipmentBtn').disabled = false;
        const ctx = canvas.getContext('2d');
        drawPhotoWithEquipment(ctx);
    }

    function drawPhotoWithEquipment(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);
        
        if (state.equipment) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

    document.getElementById('confirmEquipmentBtn').addEventListener('click', () => {
        document.getElementById('step3').classList.add('hidden');
        document.getElementById('step4').classList.remove('hidden');

        // Populate obstacle types
        const info = EQUIPMENT_INFO[state.equipmentType];
        const select = document.getElementById('obstacleType');
        select.innerHTML = '';
        info.obstacles.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = OBSTACLE_LABELS[type];
            select.appendChild(option);
        });

        setupObstacleCanvas();
    });

    // Auto-Detect Obstacles using AI
    document.getElementById('autoDetectObstaclesBtn').addEventListener('click', async () => {
        const statusDiv = document.getElementById('autoDetectObstaclesStatus');
        const btn = document.getElementById('autoDetectObstaclesBtn');

        // Show loading status
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.color = '#1976d2';
        statusDiv.textContent = 'üîç Detecting obstacles with AI...';
        btn.disabled = true;

        try {
            // Convert image to base64
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = state.photoWidth;
            canvas.height = state.photoHeight;
            ctx.drawImage(state.photo, 0, 0);
            const imageBase64 = canvas.toDataURL('image/jpeg', 0.8);

            // Get obstacle types for this equipment
            const info = EQUIPMENT_INFO[state.equipmentType];
            const detectObjects = info.obstacles; // e.g., ['opening_window', 'door', 'wall']

            // Call AI Worker for object detection
            const response = await fetch('https://clearance.martinbibb.workers.dev', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    image: imageBase64,
                    equipmentType: state.equipmentType,
                    detectObjects: detectObjects, // Request AI to detect these obstacles
                    cardColorHint: 'blue'
                }),
                signal: AbortSignal.timeout(60000) // 60 second timeout for obstacle detection
            });

            if (!response.ok) {
                throw new Error(`API returned error status ${response.status}`);
            }

            const result = await response.json();

            // Check if obstacles were detected
            if (result.obstacles && result.obstacles.length > 0) {
                // Scale factor: API returns coordinates based on 1000x1000 reference
                const scaleX = state.photoWidth / 1000;
                const scaleY = state.photoHeight / 1000;

                // Add detected obstacles to state
                result.obstacles.forEach(obstacle => {
                    state.obstacles.push({
                        type: obstacle.type,
                        bounds: {
                            x: obstacle.bounds.x * scaleX,
                            y: obstacle.bounds.y * scaleY,
                            width: obstacle.bounds.width * scaleX,
                            height: obstacle.bounds.height * scaleY
                        }
                    });
                });

                // Show success message
                statusDiv.style.background = '#e8f5e9';
                statusDiv.style.color = '#2e7d32';
                statusDiv.innerHTML = `‚úÖ <strong>Detected ${result.obstacles.length} obstacle(s)!</strong><br>` +
                    `<small>${result.obstacles.map(o => OBSTACLE_LABELS[o.type]).join(', ')}</small><br>` +
                    `You can add more obstacles manually if needed.`;

                // Update obstacle list and canvas
                updateObstacleList();
                const canvas3 = document.getElementById('photoCanvas3');
                const ctx3 = canvas3.getContext('2d');
                drawPhotoWithObstacles(ctx3);
            } else {
                // No obstacles detected
                statusDiv.style.background = '#fff3e0';
                statusDiv.style.color = '#e65100';
                statusDiv.innerHTML = '‚ö†Ô∏è <strong>No obstacles detected</strong><br>' +
                    'Use manual marking below to draw rectangles around obstacles.';
            }

            btn.disabled = false;

        } catch (error) {
            console.error('Auto-detection error:', error);
            statusDiv.style.background = '#ffebee';
            statusDiv.style.color = '#c62828';
            statusDiv.innerHTML = `‚ùå <strong>AI Detection Failed</strong><br>` +
                `${error.message}<br><br>` +
                `<strong>Solution: Use Manual Marking below</strong>`;
            btn.disabled = false;
        }
    });

    // Step 4: Mark Obstacles
    function setupObstacleCanvas() {
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        
        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;
        
        drawPhotoWithObstacles(ctx);
        
        canvas.addEventListener('mousedown', handleObstacleMouseDown);
        canvas.addEventListener('mousemove', handleObstacleMouseMove);
        canvas.addEventListener('mouseup', handleObstacleMouseUp);
        
        canvas.addEventListener('touchstart', handleObstacleTouchStart);
        canvas.addEventListener('touchmove', handleObstacleTouchMove);
        canvas.addEventListener('touchend', handleObstacleTouchEnd);
    }

    function handleObstacleMouseDown(e) {
        const canvas = document.getElementById('photoCanvas3');
        state.currentObstacleStart = getCanvasCoordinates(canvas, e);
    }

    function handleObstacleMouseMove(e) {
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);
        
        drawPhotoWithObstacles(ctx);
        
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(
            state.currentObstacleStart.x,
            state.currentObstacleStart.y,
            current.x - state.currentObstacleStart.x,
            current.y - state.currentObstacleStart.y
        );
    }

    function handleObstacleMouseUp(e) {
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const current = getCanvasCoordinates(canvas, e);
        
        const obstacleType = document.getElementById('obstacleType').value;
        
        state.obstacles.push({
            type: obstacleType,
            bounds: {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            }
        });
        
        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function handleObstacleTouchStart(e) {
        e.preventDefault();
        const canvas = document.getElementById('photoCanvas3');
        state.currentObstacleStart = getCanvasCoordinates(canvas, e);
    }

    function handleObstacleTouchMove(e) {
        e.preventDefault();
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        const current = getCanvasCoordinates(canvas, e);
        
        drawPhotoWithObstacles(ctx);
        
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(
            state.currentObstacleStart.x,
            state.currentObstacleStart.y,
            current.x - state.currentObstacleStart.x,
            current.y - state.currentObstacleStart.y
        );
    }

    function handleObstacleTouchEnd(e) {
        e.preventDefault();
        if (!state.currentObstacleStart) return;
        const canvas = document.getElementById('photoCanvas3');
        const touch = e.changedTouches[0];
        const current = getCanvasCoordinates(canvas, { clientX: touch.clientX, clientY: touch.clientY });
        
        const obstacleType = document.getElementById('obstacleType').value;
        
        state.obstacles.push({
            type: obstacleType,
            bounds: {
                x: Math.min(state.currentObstacleStart.x, current.x),
                y: Math.min(state.currentObstacleStart.y, current.y),
                width: Math.abs(current.x - state.currentObstacleStart.x),
                height: Math.abs(current.y - state.currentObstacleStart.y)
            }
        });
        
        state.currentObstacleStart = null;
        updateObstacleList();
        drawPhotoWithObstacles(canvas.getContext('2d'));
    }

    function drawPhotoWithObstacles(ctx) {
        ctx.clearRect(0, 0, state.photoWidth, state.photoHeight);
        ctx.drawImage(state.photo, 0, 0);
        
        if (state.equipment) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(state.equipment.x, state.equipment.y, 15, 0, Math.PI * 2);
            ctx.fill();
        }
        
        state.obstacles.forEach((obstacle, index) => {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(
                obstacle.bounds.x,
                obstacle.bounds.y,
                obstacle.bounds.width,
                obstacle.bounds.height
            );
            
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`${index + 1}`, obstacle.bounds.x + 10, obstacle.bounds.y + 30);
        });
    }

    function updateObstacleList() {
        const list = document.getElementById('obstacleList');
        list.innerHTML = '<h3 style="margin: 10px 0;">Marked Obstacles:</h3>';
        
        state.obstacles.forEach((obstacle, index) => {
            const item = document.createElement('div');
            item.className = 'obstacle-item';
            item.innerHTML = `
                <span>${index + 1}. ${OBSTACLE_LABELS[obstacle.type]}</span>
                <button onclick="removeObstacle(${index})">Remove</button>
            `;
            list.appendChild(item);
        });
    }

    window.removeObstacle = function(index) {
        state.obstacles.splice(index, 1);
        updateObstacleList();
        const canvas = document.getElementById('photoCanvas3');
        const ctx = canvas.getContext('2d');
        drawPhotoWithObstacles(ctx);
    };

    document.getElementById('nextToRulesBtn').addEventListener('click', () => {
        if (state.obstacles.length === 0) {
            alert('Please mark at least one obstacle');
            return;
        }
        
        document.getElementById('step4').classList.add('hidden');
        document.getElementById('step5').classList.remove('hidden');
        
        // Populate manufacturer options
        const brandSelect = document.getElementById('brand');
        brandSelect.innerHTML = '';
        const manufacturers = CLEARANCE_RULES[state.equipmentType];
        Object.keys(manufacturers).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = manufacturers[key].name;
            brandSelect.appendChild(option);
        });
    });

    // Step 5: Generate Clearance Overlay
    document.getElementById('generateBtn').addEventListener('click', () => {
        state.brand = document.getElementById('brand').value;
        
        document.getElementById('step5').classList.add('hidden');
        document.getElementById('step6').classList.remove('hidden');
        
        generateClearanceOverlay();
    });

    // Draw rounded rectangle (rectangle with 90¬∞ arc corners)
    function drawRoundedRect(ctx, x, y, width, height, radius, fill = true, stroke = true) {
        // Ensure radius doesn't exceed half of width or height
        const maxRadius = Math.min(width, height) / 2;
        const r = Math.min(radius, maxRadius);

        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.arc(x + width - r, y + r, r, Math.PI * 1.5, Math.PI * 2); // Top-right corner
        ctx.lineTo(x + width, y + height - r);
        ctx.arc(x + width - r, y + height - r, r, 0, Math.PI * 0.5); // Bottom-right corner
        ctx.lineTo(x + r, y + height);
        ctx.arc(x + r, y + height - r, r, Math.PI * 0.5, Math.PI); // Bottom-left corner
        ctx.lineTo(x, y + r);
        ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5); // Top-left corner
        ctx.closePath();

        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }

    // Check if point is inside rounded rectangle clearance zone
    function isPointInRoundedRect(px, py, x, y, width, height, radius) {
        const maxRadius = Math.min(width, height) / 2;
        const r = Math.min(radius, maxRadius);

        // Check if point is within the overall bounding box
        if (px < x || px > x + width || py < y || py > y + height) {
            return false;
        }

        // Check corner regions
        // Top-left corner
        if (px < x + r && py < y + r) {
            const dx = px - (x + r);
            const dy = py - (y + r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Top-right corner
        if (px > x + width - r && py < y + r) {
            const dx = px - (x + width - r);
            const dy = py - (y + r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Bottom-left corner
        if (px < x + r && py > y + height - r) {
            const dx = px - (x + r);
            const dy = py - (y + height - r);
            return (dx * dx + dy * dy) <= (r * r);
        }
        // Bottom-right corner
        if (px > x + width - r && py > y + height - r) {
            const dx = px - (x + width - r);
            const dy = py - (y + height - r);
            return (dx * dx + dy * dy) <= (r * r);
        }

        // Point is in main rectangular region
        return true;
    }

    function generateClearanceOverlay() {
        const canvas = document.getElementById('photoCanvas4');
        const ctx = canvas.getContext('2d');

        canvas.width = state.photoWidth;
        canvas.height = state.photoHeight;

        ctx.drawImage(state.photo, 0, 0);

        const rules = CLEARANCE_RULES[state.equipmentType][state.brand].rules;
        const violations = [];

        state.obstacles.forEach(obstacle => {
            const rule = rules.find(r => r.obstacle_type === obstacle.type);
            if (!rule) return;

            const clearancePx = {
                above: rule.clearances.above * state.scale.pixelsPerMM,
                below: rule.clearances.below * state.scale.pixelsPerMM,
                sides: rule.clearances.sides * state.scale.pixelsPerMM
            };

            // Calculate clearance zone bounds
            const zoneX = obstacle.bounds.x - clearancePx.sides;
            const zoneY = obstacle.bounds.y - clearancePx.above;
            const zoneWidth = obstacle.bounds.width + (2 * clearancePx.sides);
            const zoneHeight = obstacle.bounds.height + clearancePx.above + clearancePx.below;

            // Corner radius for 90¬∞ arcs - use the smaller of the clearances for natural rounding
            const cornerRadius = Math.min(clearancePx.above, clearancePx.below, clearancePx.sides);

            // Draw clearance zone with rounded corners (90¬∞ arcs)
            ctx.fillStyle = rule.color;
            ctx.strokeStyle = rule.stroke;
            ctx.lineWidth = 3;

            drawRoundedRect(ctx, zoneX, zoneY, zoneWidth, zoneHeight, cornerRadius, true, true);

            // Check if equipment point is in clearance zone using rounded rectangle collision
            if (isPointInRoundedRect(state.equipment.x, state.equipment.y, zoneX, zoneY, zoneWidth, zoneHeight, cornerRadius)) {
                violations.push({ obstacle, rule });
            }
        });

        // Draw equipment position marker
        ctx.fillStyle = violations.length > 0 ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.arc(state.equipment.x, state.equipment.y, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.stroke();

        displayComplianceResult(violations);
    }

    function displayComplianceResult(violations) {
        const resultDiv = document.getElementById('complianceResult');
        
        if (violations.length === 0) {
            resultDiv.className = 'compliance-result compliance-pass';
            resultDiv.innerHTML = `‚úÖ COMPLIANT<br>${EQUIPMENT_INFO[state.equipmentType].name} position meets all clearance requirements.`;
        } else {
            resultDiv.className = 'compliance-result compliance-fail';
            let html = '‚ùå NON-COMPLIANT<br><ul class="violation-list">';
            violations.forEach(v => {
                const typeLabel = OBSTACLE_LABELS[v.obstacle.type];
                html += `<li>Too close to ${typeLabel} (requires ${Math.max(v.rule.clearances.above, v.rule.clearances.sides, v.rule.clearances.below)}mm clearance)</li>`;
            });
            html += '</ul>';
            resultDiv.innerHTML = html;
        }
    }

    document.getElementById('downloadBtn').addEventListener('click', () => {
        const canvas = document.getElementById('photoCanvas4');
        const link = document.createElement('a');
        link.download = `clearance-check-${state.equipmentType}-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
    });

    document.getElementById('startOverBtn').addEventListener('click', () => {
        location.reload();
    });
</script>
```

</body>
</html>
