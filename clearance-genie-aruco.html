<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie - ArUco Calibration</title>

    <!-- OpenCV.js for ArUco detection and perspective correction -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="onOpenCvReady()"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 16px;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* Equipment Type Selection */
        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .equipment-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            color: white;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            border: 3px solid transparent;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .equipment-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .equipment-card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .equipment-card .icon {
            font-size: 60px;
            margin-bottom: 15px;
            pointer-events: none;
        }

        .equipment-card .label {
            font-size: 20px;
            font-weight: 600;
            pointer-events: none;
        }

        .equipment-card .description {
            font-size: 13px;
            margin-top: 10px;
            opacity: 0.9;
            pointer-events: none;
        }

        /* Camera Container */
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }

        #cameraFeed, #cameraFeed2 {
            width: 100%;
            height: auto;
            display: block;
        }

        #overlayCanvas, #overlayCanvas2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Calibration Status Indicator */
        .calibration-status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            z-index: 10;
            text-align: center;
            transition: all 0.3s ease;
        }

        .calibration-status.searching {
            background: rgba(241, 196, 15, 0.95);
            color: #000;
        }

        .calibration-status.detected {
            background: rgba(39, 174, 96, 0.95);
            color: #fff;
        }

        .calibration-status.locked {
            background: rgba(46, 204, 113, 0.95);
            color: #fff;
        }

        .calibration-status.error {
            background: rgba(231, 76, 60, 0.95);
            color: #fff;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .btn-capture {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            font-size: 18px;
            padding: 18px 40px;
        }

        /* Instructions */
        .instructions {
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.6;
        }

        .instructions strong {
            color: #667eea;
        }

        .instructions ul {
            margin: 10px 0 10px 20px;
        }

        /* Calibration Info Box */
        .calibration-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .calibration-info .row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .calibration-info .row:last-child {
            border-bottom: none;
        }

        .calibration-info .label {
            color: #6c757d;
            font-weight: 500;
        }

        .calibration-info .value {
            color: #2c3e50;
            font-weight: 600;
        }

        /* Result Canvas */
        .result-container {
            position: relative;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #resultCanvas, #markingCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }

        /* Clearance Legend */
        .clearance-legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }

        /* Results */
        .result-box {
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
        }

        .result-box.compliant {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .result-box.non-compliant {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .result-box.amber {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .result-icon {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .result-title {
            font-size: 24px;
            font-weight: 600;
        }

        .result-details {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.9;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .card {
                background: #1e1e1e;
                color: #e0e0e0;
            }
            .instructions {
                background: #2d2d2d;
            }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 24px;
            }
            .equipment-grid {
                grid-template-columns: 1fr;
            }
            .card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî• Clearance Genie</h1>
            <div class="subtitle">ArUco Marker Calibration System</div>
        </div>

        <!-- Step 1: Equipment Type Selection -->
        <div class="card" id="step1">
            <h2>Step 1: Select Equipment Type</h2>
            <div class="instructions">
                <strong>Choose what you're checking:</strong> Select the equipment type to analyze clearance requirements.
            </div>
            <div class="equipment-grid">
                <div class="equipment-card" data-type="flue" onclick="selectEquipment('flue')">
                    <div class="icon">üå¨Ô∏è</div>
                    <div class="label">Flue Terminal</div>
                    <div class="description">External clearances to windows, vents, doors</div>
                </div>
                <div class="equipment-card" data-type="boiler" onclick="selectEquipment('boiler')">
                    <div class="icon">üî•</div>
                    <div class="label">Boiler</div>
                    <div class="description">Service clearances to walls, cupboards</div>
                </div>
                <div class="equipment-card" data-type="radiator" onclick="selectEquipment('radiator')">
                    <div class="icon">‚ô®Ô∏è</div>
                    <div class="label">Radiator</div>
                    <div class="description">Clearances to windows, curtains, furniture</div>
                </div>
                <div class="equipment-card" data-type="cylinder" onclick="selectEquipment('cylinder')">
                    <div class="icon">üõ¢Ô∏è</div>
                    <div class="label">Cylinder</div>
                    <div class="description">Service access to doors, shelves, valves</div>
                </div>
            </div>
            <button class="btn" id="continueToCalibration" disabled onclick="goToStep(2)">Continue to Calibration</button>
        </div>

        <!-- Step 2: ArUco Calibration Instructions -->
        <div class="card hidden" id="step2">
            <h2>Step 2: ArUco Marker Calibration</h2>
            <div class="instructions">
                <strong>üìê Calibration with ArUco Marker:</strong><br><br>
                Place your <strong>150mm ArUco marker</strong> on the wall:
                <ul>
                    <li>Hold the marker flat against the same plane as the flue/window</li>
                    <li>Position it next to the flue or window frame</li>
                    <li>Ensure good lighting (avoid reflections)</li>
                    <li>The marker should be visible in the camera frame</li>
                </ul>
            </div>
            
            <div class="calibration-info">
                <h3>üìã ArUco Marker Specification</h3>
                <div class="row">
                    <span class="label">Marker Size:</span>
                    <span class="value">150mm √ó 150mm</span>
                </div>
                <div class="row">
                    <span class="label">Dictionary:</span>
                    <span class="value">DICT_6X6_50</span>
                </div>
                <div class="row">
                    <span class="label">Border Margin:</span>
                    <span class="value">10-15mm white</span>
                </div>
                <div class="row">
                    <span class="label">Finish:</span>
                    <span class="value">Matte (no reflections)</span>
                </div>
            </div>

            <button class="btn btn-success" onclick="startCalibration()">Start Camera Calibration üì∑</button>
            <button class="btn btn-secondary" onclick="goToStep(1)">Back to Equipment Selection</button>
        </div>

        <!-- Step 3: Live Calibration Camera -->
        <div class="card hidden" id="step3">
            <h2>Step 3: Calibration Mode</h2>
            
            <div class="camera-container">
                <div class="calibration-status searching" id="calibrationStatusBadge">
                    üîç Searching for ArUco marker...
                </div>
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="overlayCanvas"></canvas>
            </div>

            <div class="calibration-info" id="calibrationData">
                <div class="row">
                    <span class="label">Status:</span>
                    <span class="value" id="detectionStatus">Searching...</span>
                </div>
                <div class="row">
                    <span class="label">Scale:</span>
                    <span class="value" id="scaleValue">--</span>
                </div>
                <div class="row">
                    <span class="label">Distance:</span>
                    <span class="value" id="distanceValue">--</span>
                </div>
                <div class="row">
                    <span class="label">Orientation:</span>
                    <span class="value" id="orientationValue">--</span>
                </div>
            </div>

            <button class="btn btn-capture" id="captureBtn" disabled onclick="capturePhoto()">
                üì∏ Capture Photo
            </button>
            <button class="btn btn-secondary" onclick="stopCalibration(); goToStep(2)">
                ‚Üê Back to Instructions
            </button>
        </div>

        <!-- Step 4: Wall Photo Capture -->
        <div class="card hidden" id="step4">
            <h2>Step 4: Capture Wall Photo</h2>
            
            <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
                <strong style="color: #155724;">‚úì Calibration Locked!</strong>
                <p style="margin-top: 5px; color: #155724;" id="lockedCalibrationInfo">
                    <!-- Filled dynamically -->
                </p>
            </div>

            <div class="instructions">
                <strong>üì∏ Pull back to frame the whole wall:</strong>
                <ul>
                    <li>Keep the ArUco marker visible in frame (if possible)</li>
                    <li>Capture the flue, windows, doors, and other obstacles</li>
                    <li>Hold the camera parallel to the wall</li>
                    <li>Take the photo when ready</li>
                </ul>
            </div>

            <div class="camera-container">
                <div class="calibration-status locked" id="calibrationStatusBadge2">
                    ‚úì Calibration Locked
                </div>
                <video id="cameraFeed2" autoplay playsinline></video>
                <canvas id="overlayCanvas2"></canvas>
            </div>

            <button class="btn btn-capture" onclick="captureWallPhoto()">
                üì∏ Capture Wall Photo
            </button>
            <button class="btn btn-secondary" onclick="recalibrate()">
                üîÑ Re-calibrate
            </button>
        </div>

        <!-- Step 5: Mark Objects -->
        <div class="card hidden" id="step5">
            <h2>Step 5: Mark Objects</h2>
            
            <div class="instructions">
                <strong>üéØ Tap to mark the flue center and obstacle corners:</strong>
                <ul>
                    <li>First, tap the center of the flue terminal</li>
                    <li>Then, tap corners of windows, doors, vents, etc.</li>
                    <li>The system will draw clearance arcs automatically</li>
                </ul>
            </div>

            <div class="result-container">
                <canvas id="markingCanvas"></canvas>
            </div>

            <div id="markedObjectsList" style="margin: 15px 0;">
                <!-- Dynamically filled -->
            </div>

            <button class="btn btn-success" onclick="analyzeClearances()">
                ‚úì Analyze Clearances
            </button>
            <button class="btn btn-secondary" onclick="clearMarks()">
                üóëÔ∏è Clear All Marks
            </button>
        </div>

        <!-- Step 6: Results -->
        <div class="card hidden" id="step6">
            <h2>Step 6: Clearance Results</h2>

            <div class="result-container">
                <canvas id="resultCanvas"></canvas>
            </div>

            <div class="clearance-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(231, 76, 60, 0.5);"></div>
                    <span>Red: Non-compliant (&lt;75mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(241, 196, 15, 0.5);"></div>
                    <span>Amber: Influenced (75-150mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(46, 204, 113, 0.5);"></div>
                    <span>Green: Compliant (&gt;300mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(52, 152, 219, 0.3);"></div>
                    <span>150mm zone</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(155, 89, 182, 0.3);"></div>
                    <span>200mm zone</span>
                </div>
            </div>

            <div id="resultSummary">
                <!-- Dynamically filled -->
            </div>

            <button class="btn btn-success" onclick="downloadResult()">
                üì• Download Annotated Photo
            </button>
            <button class="btn btn-secondary" onclick="startOver()">
                üîÑ Start New Check
            </button>
        </div>

        <!-- OpenCV Loading -->
        <div class="card hidden" id="loadingScreen">
            <div class="loading">
                <div class="spinner"></div>
                <div id="loadingMessage">Loading OpenCV.js...</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // CLEARANCE GENIE - ARUCO CALIBRATION SYSTEM
        // ============================================================

        // OpenCV ready flag
        let cvReady = false;

        function onOpenCvReady() {
            cvReady = true;
            console.log('‚úì OpenCV.js loaded and ready for ArUco detection');
            document.getElementById('loadingScreen')?.classList.add('hidden');
        }

        // Application State
        const state = {
            equipmentType: null,
            currentStep: 1,
            
            // Calibration
            calibration: {
                locked: false,
                pixelsPerMM: 0,
                markerSize: 150, // mm
                markerCorners: null,
                rvec: null,
                tvec: null,
                distance: 0,
                orientation: { pitch: 0, yaw: 0, roll: 0 }
            },
            
            // Camera
            cameraStream: null,
            detectionInterval: null,
            detectionCount: 0,
            requiredDetections: 5,
            
            // Images
            calibrationImage: null,
            wallImage: null,
            
            // Marked objects
            fluePosition: null,
            obstacles: [],
            
            // Metadata
            metadata: {
                timestamp: null,
                gps: null,
                calibrationValid: false
            }
        };

        // Equipment Configurations with clearance zones
        const EQUIPMENT_CONFIG = {
            flue: {
                name: 'Flue Terminal',
                icon: 'üå¨Ô∏è',
                diameter: 100, // mm
                clearanceZones: [
                    { distance: 75, color: 'rgba(231, 76, 60, 0.5)', label: 'Prohibited', status: 'fail' },
                    { distance: 150, color: 'rgba(241, 196, 15, 0.4)', label: '150mm', status: 'amber' },
                    { distance: 200, color: 'rgba(155, 89, 182, 0.3)', label: '200mm', status: 'amber' },
                    { distance: 300, color: 'rgba(46, 204, 113, 0.3)', label: '300mm Safe', status: 'pass' }
                ],
                obstacleClearances: {
                    opening_window: 300,
                    fixed_window: 150,
                    door: 300,
                    air_vent: 300,
                    gas_meter: 300,
                    gutter: 75,
                    boundary: 600
                }
            },
            boiler: {
                name: 'Boiler',
                icon: 'üî•',
                clearanceZones: [
                    { distance: 50, color: 'rgba(231, 76, 60, 0.5)', label: 'Min', status: 'fail' },
                    { distance: 150, color: 'rgba(241, 196, 15, 0.4)', label: 'Service', status: 'amber' },
                    { distance: 300, color: 'rgba(46, 204, 113, 0.3)', label: 'Optimal', status: 'pass' }
                ]
            },
            radiator: {
                name: 'Radiator',
                icon: '‚ô®Ô∏è',
                clearanceZones: [
                    { distance: 50, color: 'rgba(231, 76, 60, 0.5)', label: 'Wall', status: 'fail' },
                    { distance: 100, color: 'rgba(241, 196, 15, 0.4)', label: 'Curtain', status: 'amber' },
                    { distance: 150, color: 'rgba(46, 204, 113, 0.3)', label: 'Furniture', status: 'pass' }
                ]
            },
            cylinder: {
                name: 'Cylinder',
                icon: 'üõ¢Ô∏è',
                clearanceZones: [
                    { distance: 150, color: 'rgba(231, 76, 60, 0.5)', label: 'Service', status: 'fail' },
                    { distance: 300, color: 'rgba(241, 196, 15, 0.4)', label: 'Access', status: 'amber' },
                    { distance: 450, color: 'rgba(46, 204, 113, 0.3)', label: 'Discharge', status: 'pass' }
                ]
            }
        };

        // ============================================================
        // STEP 1: Equipment Selection
        // ============================================================

        function selectEquipment(type) {
            state.equipmentType = type;

            document.querySelectorAll('.equipment-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('selected');

            document.getElementById('continueToCalibration').disabled = false;
        }

        // ============================================================
        // NAVIGATION
        // ============================================================

        function goToStep(stepNumber) {
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`step${i}`)?.classList.add('hidden');
            }
            document.getElementById(`step${stepNumber}`).classList.remove('hidden');
            state.currentStep = stepNumber;
        }

        // ============================================================
        // STEP 3: ARUCO CALIBRATION
        // ============================================================

        async function startCalibration() {
            if (!cvReady) {
                alert('OpenCV is still loading. Please wait a moment and try again.');
                return;
            }

            goToStep(3);

            try {
                state.cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                const video = document.getElementById('cameraFeed');
                video.srcObject = state.cameraStream;

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    startArUcoDetection();
                });

            } catch (error) {
                console.error('Camera access error:', error);
                alert('Failed to access camera: ' + error.message);
                goToStep(2);
            }
        }

        function stopCalibration() {
            if (state.detectionInterval) {
                clearInterval(state.detectionInterval);
                state.detectionInterval = null;
            }

            if (state.cameraStream) {
                state.cameraStream.getTracks().forEach(track => track.stop());
                state.cameraStream = null;
            }
        }

        function startArUcoDetection() {
            const video = document.getElementById('cameraFeed');
            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');

            state.detectionCount = 0;

            state.detectionInterval = setInterval(() => {
                if (!video.videoWidth || !video.videoHeight) return;

                // Create temporary canvas to get video frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0);

                // Detect ArUco markers
                const result = detectArUcoMarker(tempCanvas);

                // Clear overlay
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (result.detected) {
                    state.detectionCount++;
                    
                    // Draw green outline around detected marker
                    drawMarkerOutline(ctx, result.corners, '#2ecc71');
                    
                    // Update calibration data
                    updateCalibrationDisplay(result);

                    // Update status badge
                    const badge = document.getElementById('calibrationStatusBadge');
                    badge.className = 'calibration-status detected';
                    badge.textContent = `‚úì Marker Detected (${state.detectionCount}/${state.requiredDetections})`;

                    // Enable capture after required detections
                    if (state.detectionCount >= state.requiredDetections) {
                        document.getElementById('captureBtn').disabled = false;
                        badge.className = 'calibration-status locked';
                        badge.textContent = '‚úì Calibration Ready - Capture Photo!';
                        
                        // Store calibration data
                        state.calibration.locked = true;
                        state.calibration.pixelsPerMM = result.pixelsPerMM;
                        state.calibration.markerCorners = result.corners;
                        state.calibration.distance = result.distance;
                        state.calibration.orientation = result.orientation;
                    }

                } else {
                    // Reset detection count if marker lost
                    if (state.detectionCount > 0 && state.detectionCount < state.requiredDetections) {
                        state.detectionCount = Math.max(0, state.detectionCount - 1);
                    }

                    const badge = document.getElementById('calibrationStatusBadge');
                    badge.className = 'calibration-status searching';
                    badge.textContent = 'üîç Searching for ArUco marker...';

                    document.getElementById('detectionStatus').textContent = 'Searching...';
                }

            }, 100); // 10 FPS detection
        }

        function detectArUcoMarker(canvas) {
            try {
                // Read image into OpenCV Mat
                const src = cv.imread(canvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // Create ArUco dictionary (6x6_50)
                // Note: OpenCV.js has limited ArUco support, so we'll use contour-based detection as fallback
                const result = detectMarkerContours(gray, canvas);

                src.delete();
                gray.delete();

                return result;

            } catch (error) {
                console.error('ArUco detection error:', error);
                return { detected: false };
            }
        }

        // Fallback detection using contour analysis for square markers
        function detectMarkerContours(grayMat, canvas) {
            try {
                // Apply adaptive thresholding
                const binary = new cv.Mat();
                cv.adaptiveThreshold(grayMat, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                // Find contours
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(binary, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                let bestMarker = null;
                let bestArea = 0;

                for (let i = 0; i < contours.size(); i++) {
                    const contour = contours.get(i);
                    const area = cv.contourArea(contour);
                    
                    // Filter by area (marker should be reasonably sized)
                    if (area < 1000 || area > canvas.width * canvas.height * 0.5) {
                        contour.delete();
                        continue;
                    }

                    // Approximate contour to polygon
                    const approx = new cv.Mat();
                    const epsilon = 0.04 * cv.arcLength(contour, true);
                    cv.approxPolyDP(contour, approx, epsilon, true);

                    // Check if it's a quadrilateral
                    if (approx.rows === 4) {
                        // Check if it's roughly square (aspect ratio)
                        const corners = [];
                        for (let j = 0; j < 4; j++) {
                            corners.push({
                                x: approx.data32S[j * 2],
                                y: approx.data32S[j * 2 + 1]
                            });
                        }

                        // Calculate side lengths
                        const side1 = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
                        const side2 = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);
                        const aspectRatio = Math.max(side1, side2) / Math.min(side1, side2);

                        // Square markers should have aspect ratio close to 1
                        if (aspectRatio < 1.3 && area > bestArea) {
                            // Check if interior has black/white pattern (ArUco characteristic)
                            if (hasArUcoPattern(grayMat, corners)) {
                                bestMarker = corners;
                                bestArea = area;
                            }
                        }
                    }

                    approx.delete();
                    contour.delete();
                }

                binary.delete();
                contours.delete();
                hierarchy.delete();

                if (bestMarker) {
                    // Calculate scale: known marker size is 150mm
                    const side1 = Math.hypot(bestMarker[1].x - bestMarker[0].x, bestMarker[1].y - bestMarker[0].y);
                    const side2 = Math.hypot(bestMarker[2].x - bestMarker[1].x, bestMarker[2].y - bestMarker[1].y);
                    const avgSidePx = (side1 + side2) / 2;
                    const pixelsPerMM = avgSidePx / state.calibration.markerSize;

                    // Estimate distance (rough approximation)
                    // Assuming typical camera FOV and sensor size
                    const focalLengthPx = canvas.width * 0.8; // Approximate
                    const distance = (state.calibration.markerSize * focalLengthPx) / avgSidePx;

                    // Estimate orientation from corner positions
                    const orientation = estimateOrientation(bestMarker);

                    return {
                        detected: true,
                        corners: bestMarker,
                        pixelsPerMM: pixelsPerMM,
                        distance: distance,
                        orientation: orientation
                    };
                }

                return { detected: false };

            } catch (error) {
                console.error('Contour detection error:', error);
                return { detected: false };
            }
        }

        // Check if the detected quadrilateral has ArUco-like pattern
        function hasArUcoPattern(grayMat, corners) {
            try {
                // Sample points inside the quadrilateral
                const centerX = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;
                const centerY = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;

                // Check if center region has high contrast (characteristic of ArUco)
                const sampleSize = 10;
                let whiteCount = 0;
                let blackCount = 0;

                for (let dy = -sampleSize; dy <= sampleSize; dy += 5) {
                    for (let dx = -sampleSize; dx <= sampleSize; dx += 5) {
                        const x = Math.round(centerX + dx);
                        const y = Math.round(centerY + dy);
                        
                        if (x >= 0 && x < grayMat.cols && y >= 0 && y < grayMat.rows) {
                            const val = grayMat.ucharAt(y, x);
                            if (val > 128) whiteCount++;
                            else blackCount++;
                        }
                    }
                }

                // ArUco markers have roughly equal black and white areas
                const total = whiteCount + blackCount;
                if (total === 0) return false;
                
                const ratio = Math.min(whiteCount, blackCount) / Math.max(whiteCount, blackCount);
                return ratio > 0.2; // At least 20% contrast balance

            } catch (error) {
                return false;
            }
        }

        function estimateOrientation(corners) {
            // Estimate rotation from quadrilateral shape
            // This is a simplified estimation

            const topWidth = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
            const bottomWidth = Math.hypot(corners[2].x - corners[3].x, corners[2].y - corners[3].y);
            const leftHeight = Math.hypot(corners[3].x - corners[0].x, corners[3].y - corners[0].y);
            const rightHeight = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);

            // Pitch: if top is narrower than bottom, camera is tilted up
            const pitch = Math.atan2(bottomWidth - topWidth, (topWidth + bottomWidth) / 2) * (180 / Math.PI);

            // Yaw: if left is taller than right, camera is rotated right
            const yaw = Math.atan2(leftHeight - rightHeight, (leftHeight + rightHeight) / 2) * (180 / Math.PI);

            // Roll: angle of top edge
            const roll = Math.atan2(corners[1].y - corners[0].y, corners[1].x - corners[0].x) * (180 / Math.PI);

            return { pitch, yaw, roll };
        }

        function drawMarkerOutline(ctx, corners, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            ctx.lineTo(corners[1].x, corners[1].y);
            ctx.lineTo(corners[2].x, corners[2].y);
            ctx.lineTo(corners[3].x, corners[3].y);
            ctx.closePath();
            ctx.stroke();

            // Draw corner circles
            ctx.fillStyle = color;
            corners.forEach((corner, i) => {
                ctx.beginPath();
                ctx.arc(corner.x, corner.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Label corners
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.fillText((i + 1).toString(), corner.x + 12, corner.y - 5);
                ctx.fillStyle = color;
            });
        }

        function updateCalibrationDisplay(result) {
            document.getElementById('detectionStatus').textContent = 'Detected ‚úì';
            document.getElementById('scaleValue').textContent = 
                result.pixelsPerMM.toFixed(3) + ' px/mm';
            document.getElementById('distanceValue').textContent = 
                Math.round(result.distance) + ' mm';
            document.getElementById('orientationValue').textContent = 
                `P:${result.orientation.pitch.toFixed(1)}¬∞ Y:${result.orientation.yaw.toFixed(1)}¬∞ R:${result.orientation.roll.toFixed(1)}¬∞`;
        }

        // ============================================================
        // STEP 4: CAPTURE PHOTO
        // ============================================================

        function capturePhoto() {
            if (!state.calibration.locked) {
                alert('Calibration not ready. Please wait for marker detection.');
                return;
            }

            const video = document.getElementById('cameraFeed');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            state.calibrationImage = canvas.toDataURL('image/jpeg', 0.9);

            // Store metadata
            state.metadata.timestamp = new Date().toISOString();
            state.metadata.calibrationValid = true;

            // Try to get GPS
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        state.metadata.gps = {
                            latitude: pos.coords.latitude,
                            longitude: pos.coords.longitude,
                            accuracy: pos.coords.accuracy
                        };
                    },
                    (err) => {
                        console.log('GPS not available:', err.message);
                    }
                );
            }

            // Stop detection and move to wall capture
            stopCalibration();
            goToStep(4);
            startWallCapture();
        }

        async function startWallCapture() {
            // Update locked calibration info
            document.getElementById('lockedCalibrationInfo').textContent = 
                `Scale: ${state.calibration.pixelsPerMM.toFixed(3)} px/mm | ` +
                `Distance: ${Math.round(state.calibration.distance)}mm | ` +
                `Marker: 150mm ArUco`;

            try {
                state.cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                const video = document.getElementById('cameraFeed2');
                video.srcObject = state.cameraStream;

            } catch (error) {
                console.error('Camera error:', error);
                alert('Failed to restart camera: ' + error.message);
            }
        }

        function captureWallPhoto() {
            const video = document.getElementById('cameraFeed2');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            state.wallImage = new Image();
            state.wallImage.onload = () => {
                stopCalibration();
                goToStep(5);
                setupMarkingCanvas();
            };
            state.wallImage.src = canvas.toDataURL('image/jpeg', 0.9);
        }

        function recalibrate() {
            state.calibration.locked = false;
            state.calibration.pixelsPerMM = 0;
            state.detectionCount = 0;
            stopCalibration();
            goToStep(3);
            startCalibration();
        }

        // ============================================================
        // STEP 5: MARK OBJECTS
        // ============================================================

        function setupMarkingCanvas() {
            const canvas = document.getElementById('markingCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = state.wallImage.width;
            canvas.height = state.wallImage.height;

            ctx.drawImage(state.wallImage, 0, 0);

            // Reset marks
            state.fluePosition = null;
            state.obstacles = [];

            // Setup click handler
            canvas.onclick = handleMarkingClick;

            updateMarkedObjectsList();
        }

        function handleMarkingClick(e) {
            const canvas = document.getElementById('markingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (!state.fluePosition) {
                // First click marks flue center
                state.fluePosition = { x, y };
            } else {
                // Subsequent clicks mark obstacles
                state.obstacles.push({ 
                    x, y, 
                    type: 'obstacle',
                    label: `Obstacle ${state.obstacles.length + 1}`
                });
            }

            redrawMarkingCanvas();
            updateMarkedObjectsList();
        }

        function redrawMarkingCanvas() {
            const canvas = document.getElementById('markingCanvas');
            const ctx = canvas.getContext('2d');

            // Redraw image
            ctx.drawImage(state.wallImage, 0, 0);

            // Draw flue position
            if (state.fluePosition) {
                const config = EQUIPMENT_CONFIG[state.equipmentType];
                
                // Draw flue marker
                ctx.beginPath();
                ctx.arc(state.fluePosition.x, state.fluePosition.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(config.icon, state.fluePosition.x, state.fluePosition.y + 5);
            }

            // Draw obstacles
            state.obstacles.forEach((obs, i) => {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), obs.x, obs.y + 4);
            });
        }

        function updateMarkedObjectsList() {
            const list = document.getElementById('markedObjectsList');
            let html = '<h4 style="margin-bottom: 10px;">Marked Objects:</h4>';

            if (state.fluePosition) {
                const config = EQUIPMENT_CONFIG[state.equipmentType];
                html += `<div style="padding: 8px; background: #f8d7da; border-radius: 4px; margin-bottom: 5px;">
                    ${config.icon} ${config.name} - Center marked
                </div>`;
            } else {
                html += `<div style="padding: 8px; background: #fff3cd; border-radius: 4px; margin-bottom: 5px;">
                    üëÜ Tap to mark ${EQUIPMENT_CONFIG[state.equipmentType].name} center first
                </div>`;
            }

            state.obstacles.forEach((obs, i) => {
                html += `<div style="padding: 8px; background: #d1ecf1; border-radius: 4px; margin-bottom: 5px;">
                    ${i + 1}. ${obs.label}
                </div>`;
            });

            list.innerHTML = html;
        }

        function clearMarks() {
            state.fluePosition = null;
            state.obstacles = [];
            redrawMarkingCanvas();
            updateMarkedObjectsList();
        }

        // ============================================================
        // STEP 6: ANALYZE CLEARANCES
        // ============================================================

        function analyzeClearances() {
            if (!state.fluePosition) {
                alert('Please mark the flue/equipment position first.');
                return;
            }

            goToStep(6);
            drawClearanceResults();
        }

        function drawClearanceResults() {
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = state.wallImage.width;
            canvas.height = state.wallImage.height;

            // Draw wall image
            ctx.drawImage(state.wallImage, 0, 0);

            const config = EQUIPMENT_CONFIG[state.equipmentType];
            const pxPerMM = state.calibration.pixelsPerMM;

            // Draw clearance arcs (curved zones, not boxes)
            config.clearanceZones.slice().reverse().forEach(zone => {
                const radiusPx = zone.distance * pxPerMM;
                
                ctx.beginPath();
                ctx.arc(state.fluePosition.x, state.fluePosition.y, radiusPx, 0, Math.PI * 2);
                ctx.fillStyle = zone.color;
                ctx.fill();
                ctx.strokeStyle = zone.color.replace(/[\d.]+\)$/, '1)');
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw flue center (100mm diameter)
            const flueDiameterPx = (config.diameter || 100) * pxPerMM;
            ctx.beginPath();
            ctx.arc(state.fluePosition.x, state.fluePosition.y, flueDiameterPx / 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(52, 73, 94, 0.8)';
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw flue icon
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(config.icon, state.fluePosition.x, state.fluePosition.y);

            // Check obstacles and determine compliance
            let violations = [];
            let warnings = [];
            let compliant = [];

            state.obstacles.forEach((obs, i) => {
                const distancePx = Math.hypot(obs.x - state.fluePosition.x, obs.y - state.fluePosition.y);
                const distanceMM = distancePx / pxPerMM;

                // Draw obstacle marker
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, 12, 0, Math.PI * 2);
                
                // Determine status based on distance
                let status = 'pass';
                let color = '#2ecc71';
                
                for (const zone of config.clearanceZones) {
                    if (distanceMM <= zone.distance) {
                        status = zone.status;
                        if (status === 'fail') color = '#e74c3c';
                        else if (status === 'amber') color = '#f39c12';
                        break;
                    }
                }

                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label with distance
                ctx.fillStyle = color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${Math.round(distanceMM)}mm`, obs.x + 18, obs.y + 4);

                // Categorize
                if (status === 'fail') {
                    violations.push({ label: obs.label, distance: distanceMM });
                } else if (status === 'amber') {
                    warnings.push({ label: obs.label, distance: distanceMM });
                } else {
                    compliant.push({ label: obs.label, distance: distanceMM });
                }
            });

            // Draw zone labels
            config.clearanceZones.forEach(zone => {
                const radiusPx = zone.distance * pxPerMM;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${zone.distance}mm`, state.fluePosition.x, state.fluePosition.y - radiusPx - 5);
            });

            // Generate result summary
            generateResultSummary(violations, warnings, compliant);
        }

        function generateResultSummary(violations, warnings, compliant) {
            const summary = document.getElementById('resultSummary');
            let html = '';

            if (violations.length > 0) {
                html += `<div class="result-box non-compliant">
                    <div class="result-icon">‚ùå</div>
                    <div class="result-title">NON-COMPLIANT</div>
                    <div class="result-details">
                        ${violations.length} clearance violation(s) found
                    </div>
                </div>`;

                html += '<h4 style="margin-top: 15px; color: #e74c3c;">Violations:</h4>';
                html += '<ul style="margin-left: 20px; color: #e74c3c;">';
                violations.forEach(v => {
                    html += `<li>${v.label}: ${Math.round(v.distance)}mm (too close)</li>`;
                });
                html += '</ul>';

            } else if (warnings.length > 0) {
                html += `<div class="result-box amber">
                    <div class="result-icon">‚ö†Ô∏è</div>
                    <div class="result-title">INFLUENCED</div>
                    <div class="result-details">
                        ${warnings.length} item(s) require engineer consideration
                    </div>
                </div>`;

            } else {
                html += `<div class="result-box compliant">
                    <div class="result-icon">‚úÖ</div>
                    <div class="result-title">COMPLIANT</div>
                    <div class="result-details">
                        All clearances meet requirements
                    </div>
                </div>`;
            }

            // Add metadata
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 12px; color: #6c757d;">
                <strong>Metadata:</strong><br>
                Timestamp: ${state.metadata.timestamp || 'N/A'}<br>
                GPS: ${state.metadata.gps ? `${state.metadata.gps.latitude.toFixed(5)}, ${state.metadata.gps.longitude.toFixed(5)}` : 'Not available'}<br>
                Calibration: ${state.calibration.pixelsPerMM.toFixed(3)} px/mm (ArUco 150mm)
            </div>`;

            summary.innerHTML = html;
        }

        // ============================================================
        // DOWNLOAD & RESTART
        // ============================================================

        function downloadResult() {
            const canvas = document.getElementById('resultCanvas');
            const link = document.createElement('a');
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `clearance-check-${state.equipmentType}-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function startOver() {
            stopCalibration();
            
            // Reset state
            state.equipmentType = null;
            state.calibration.locked = false;
            state.calibration.pixelsPerMM = 0;
            state.detectionCount = 0;
            state.fluePosition = null;
            state.obstacles = [];
            state.wallImage = null;
            state.calibrationImage = null;

            // Reset UI
            document.querySelectorAll('.equipment-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('continueToCalibration').disabled = true;
            document.getElementById('captureBtn').disabled = true;

            goToStep(1);
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================

        console.log('üî• Clearance Genie - ArUco Calibration System initialized');
        console.log('üìê Marker specification: 150mm ArUco (DICT_6X6_50)');
    </script>
</body>
</html>
