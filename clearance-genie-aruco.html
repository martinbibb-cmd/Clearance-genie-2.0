<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie - ArUco Calibration with 3D</title>

    <!-- OpenCV.js for ArUco detection and perspective correction -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="onOpenCvReady()"></script>
    
    <!-- Three.js for 3D rendering -->
    <script src="js/vendor/three.min.js"></script>
    
    <!-- Model Store for equipment dimensions -->
    <script src="js/modelStore.js"></script>
    
    <!-- Live Clearance View Module -->
    <script src="js/liveClearance.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 16px;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* Equipment Type Selection */
        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .equipment-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            color: white;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            border: 3px solid transparent;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .equipment-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .equipment-card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .equipment-card .icon {
            font-size: 60px;
            margin-bottom: 15px;
            pointer-events: none;
        }

        .equipment-card .label {
            font-size: 20px;
            font-weight: 600;
            pointer-events: none;
        }

        .equipment-card .description {
            font-size: 13px;
            margin-top: 10px;
            opacity: 0.9;
            pointer-events: none;
        }

        /* Camera Container */
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }

        #cameraFeed, #cameraFeed2 {
            width: 100%;
            height: auto;
            display: block;
        }

        #overlayCanvas, #overlayCanvas2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Calibration Status Indicator */
        .calibration-status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            z-index: 10;
            text-align: center;
            transition: all 0.3s ease;
        }

        .calibration-status.searching {
            background: rgba(241, 196, 15, 0.95);
            color: #000;
        }

        .calibration-status.detected {
            background: rgba(39, 174, 96, 0.95);
            color: #fff;
        }

        .calibration-status.locked {
            background: rgba(46, 204, 113, 0.95);
            color: #fff;
        }

        .calibration-status.error {
            background: rgba(231, 76, 60, 0.95);
            color: #fff;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .btn-capture {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            font-size: 18px;
            padding: 18px 40px;
        }

        /* Instructions */
        .instructions {
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.6;
        }

        .instructions strong {
            color: #667eea;
        }

        .instructions ul {
            margin: 10px 0 10px 20px;
        }

        /* Calibration Info Box */
        .calibration-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .calibration-info .row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .calibration-info .row:last-child {
            border-bottom: none;
        }

        .calibration-info .label {
            color: #6c757d;
            font-weight: 500;
        }

        .calibration-info .value {
            color: #2c3e50;
            font-weight: 600;
        }

        /* Result Canvas */
        .result-container {
            position: relative;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #resultCanvas, #markingCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }

        /* Clearance Legend */
        .clearance-legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }

        /* Results */
        .result-box {
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
        }

        .result-box.compliant {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .result-box.non-compliant {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .result-box.amber {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .result-icon {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .result-title {
            font-size: 24px;
            font-weight: 600;
        }

        .result-details {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.9;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Model Selection Styles */
        .model-selector {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .model-selector .form-group {
            margin: 15px 0;
        }

        .model-selector label {
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .model-selector select {
            width: 100%;
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #667eea;
            font-size: 15px;
        }

        .model-info {
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 14px;
        }

        .model-info .info-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .model-info .info-label {
            color: #6c757d;
        }

        .model-info .info-value {
            font-weight: 600;
            color: #2c3e50;
        }

        /* 3D Overlay Container */
        .threejs-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 15;
        }

        .live3d-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .live3d-controls .btn {
            flex: 1;
            min-width: 140px;
        }

        .calibration-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .calibration-badge.valid {
            background: #d4edda;
            color: #155724;
        }

        .calibration-badge.invalid {
            background: #f8d7da;
            color: #721c24;
        }

        /* Live Clearance View Styles */
        .live-clearance-container {
            padding: 10px 0;
        }

        .live-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .live-header h2 {
            color: #667eea;
            font-size: 22px;
            margin-bottom: 8px;
        }

        .live-header p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .live-video-wrapper {
            position: relative;
            width: 100%;
            overflow: hidden;
            border-radius: 16px;
            background: #000;
        }

        #cg-video, #cg-overlay {
            display: block;
            width: 100%;
            height: auto;
        }

        #cg-video {
            position: relative;
            z-index: 1;
        }

        #cg-overlay {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            pointer-events: none;
        }

        .live-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .live-controls button {
            flex: 1;
            min-width: 140px;
        }

        .live-hint {
            text-align: center;
            font-size: 13px;
            color: #7f8c8d;
            margin-top: 15px;
            line-height: 1.5;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .card {
                background: #1e1e1e;
                color: #e0e0e0;
            }
            .instructions {
                background: #2d2d2d;
            }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 24px;
            }
            .equipment-grid {
                grid-template-columns: 1fr;
            }
            .card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî• Clearance Genie</h1>
            <div class="subtitle">ArUco Marker Calibration with 3D Object Placement</div>
        </div>

        <!-- Step 1: Equipment Type Selection -->
        <div class="card" id="step1">
            <h2>Step 1: Select Equipment Type</h2>
            <div class="instructions">
                <strong>Choose what you're checking:</strong> Select the equipment type to analyze clearance requirements.
            </div>
            <div class="equipment-grid">
                <div class="equipment-card" data-type="flue" onclick="selectEquipment('flue')">
                    <div class="icon">üå¨Ô∏è</div>
                    <div class="label">Flue Terminal</div>
                    <div class="description">External clearances to windows, vents, doors</div>
                </div>
                <div class="equipment-card" data-type="boiler" onclick="selectEquipment('boiler')">
                    <div class="icon">üî•</div>
                    <div class="label">Boiler</div>
                    <div class="description">Service clearances to walls, cupboards</div>
                </div>
                <div class="equipment-card" data-type="radiator" onclick="selectEquipment('radiator')">
                    <div class="icon">‚ô®Ô∏è</div>
                    <div class="label">Radiator</div>
                    <div class="description">Clearances to windows, curtains, furniture</div>
                </div>
                <div class="equipment-card" data-type="cylinder" onclick="selectEquipment('cylinder')">
                    <div class="icon">üõ¢Ô∏è</div>
                    <div class="label">Cylinder</div>
                    <div class="description">Service access to doors, shelves, valves</div>
                </div>
            </div>
            
            <!-- Model Selection (for boiler, radiator, cylinder) -->
            <div class="model-selector hidden" id="modelSelector">
                <div class="form-group">
                    <label for="modelSelect">üì¶ Select Specific Model (Optional):</label>
                    <select id="modelSelect">
                        <option value="">-- Use Default Dimensions --</option>
                    </select>
                </div>
                <div id="modelInfoPanel" class="model-info hidden">
                    <h4 style="margin-bottom: 10px;">üìã Model Dimensions</h4>
                    <div class="info-row">
                        <span class="info-label">Width:</span>
                        <span class="info-value" id="modelWidth">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Height:</span>
                        <span class="info-value" id="modelHeight">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Depth:</span>
                        <span class="info-value" id="modelDepth">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Front Clearance:</span>
                        <span class="info-value" id="modelFrontClearance">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Side Clearance:</span>
                        <span class="info-value" id="modelSideClearance">--</span>
                    </div>
                </div>
            </div>
            
            <button class="btn" id="continueToCalibration" disabled onclick="goToStep(2)">Continue to Calibration</button>
        </div>

        <!-- Step 2: ArUco Calibration Instructions -->
        <div class="card hidden" id="step2">
            <h2>Step 2: ArUco Marker Calibration</h2>
            <div class="instructions">
                <strong>üìê Calibration with ArUco Marker:</strong><br><br>
                Select your marker size and place it on the wall:
                <ul>
                    <li>Hold the marker flat against the same plane as the flue/window</li>
                    <li>Position it next to the flue or window frame</li>
                    <li>Ensure good lighting (avoid reflections)</li>
                    <li>The marker should be visible in the camera frame</li>
                </ul>
            </div>
            
            <div class="calibration-info">
                <h3>üìã Select Marker Size</h3>
                <div style="margin: 15px 0;">
                    <label for="markerSizeSelect" style="font-weight: 600; display: block; margin-bottom: 8px;">
                        Which marker size are you using?
                    </label>
                    <select id="markerSizeSelect" onchange="toggleCustomMarkerSize()" style="width: 100%; padding: 12px; border-radius: 6px; border: 2px solid #667eea; font-size: 15px;">
                        <option value="53">üí≥ Credit Card Size (53mm √ó 53mm)</option>
                        <option value="148">üìÑ A5 Size (148mm √ó 148mm)</option>
                        <option value="210">üìÉ A4 Size (210mm √ó 210mm)</option>
                        <option value="custom">‚úèÔ∏è Custom Size</option>
                    </select>
                </div>
                <div id="customMarkerSizeInput" class="hidden" style="margin: 15px 0;">
                    <label for="customMarkerSize" style="font-weight: 600; display: block; margin-bottom: 8px;">
                        Enter custom marker size (mm):
                    </label>
                    <input type="number" id="customMarkerSize" min="10" max="500" value="100"
                           style="width: 100%; padding: 12px; border-radius: 6px; border: 2px solid #667eea; font-size: 15px;"
                           placeholder="Enter size in mm (e.g., 100)">
                </div>
                <div class="row">
                    <span class="label">Dictionary:</span>
                    <span class="value">DICT_6X6_50</span>
                </div>
                <div class="row">
                    <span class="label">Border Margin:</span>
                    <span class="value">Keep white border visible</span>
                </div>
                <div class="row">
                    <span class="label">Finish:</span>
                    <span class="value">Matte (no reflections)</span>
                </div>
            </div>

            <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #28a745;">
                <strong style="color: #155724;">üí° Need to print a marker?</strong>
                <p style="margin-top: 5px; color: #155724;">
                    <a href="aruco-markers.html" style="color: #155724; text-decoration: underline;">Click here to print ArUco markers</a> in credit card, A5, or A4 sizes.
                </p>
            </div>

            <button class="btn btn-success" onclick="startCalibration()">Start Camera Calibration üì∑</button>
            <button class="btn btn-secondary" onclick="goToStep(1)">Back to Equipment Selection</button>
        </div>

        <!-- Step 3: Live Calibration Camera -->
        <div class="card hidden" id="step3">
            <h2>Step 3: Calibration Mode</h2>
            
            <div class="camera-container">
                <div class="calibration-status searching" id="calibrationStatusBadge">
                    üîç Searching for ArUco marker...
                </div>
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="overlayCanvas"></canvas>
            </div>

            <div class="calibration-info" id="calibrationData">
                <div class="row">
                    <span class="label">Status:</span>
                    <span class="value" id="detectionStatus">Searching...</span>
                </div>
                <div class="row">
                    <span class="label">Markers Detected:</span>
                    <span class="value" id="markerCountValue">0</span>
                </div>
                <div class="row">
                    <span class="label">Scale:</span>
                    <span class="value" id="scaleValue">--</span>
                </div>
                <div class="row">
                    <span class="label">Distance:</span>
                    <span class="value" id="distanceValue">--</span>
                </div>
                <div class="row">
                    <span class="label">Orientation:</span>
                    <span class="value" id="orientationValue">--</span>
                </div>
            </div>

            <div id="allMarkersInfo" class="hidden" style="background: #e8f4f8; border-left: 4px solid #667eea; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h4 style="margin-bottom: 10px; color: #667eea;">üìç All Detected Markers</h4>
                <div id="markersListContainer"></div>
            </div>

            <button class="btn btn-capture" id="captureBtn" disabled onclick="capturePhoto()">
                üì∏ Capture Photo
            </button>
            <button class="btn btn-secondary" onclick="stopCalibration(); goToStep(2)">
                ‚Üê Back to Instructions
            </button>
        </div>

        <!-- Step 4: Wall Photo Capture with 3D Equipment Placement -->
        <div class="card hidden" id="step4">
            <h2>Step 4: Live 3D Equipment Placement</h2>
            
            <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
                <strong style="color: #155724;">‚úì Calibration Locked!</strong>
                <span class="calibration-badge valid" id="calibrationBadge">Ready</span>
                <p style="margin-top: 5px; color: #155724;" id="lockedCalibrationInfo">
                    <!-- Filled dynamically -->
                </p>
            </div>

            <div class="instructions">
                <strong>üìê Position your equipment on the wall:</strong>
                <ul>
                    <li>A 3D box shows your selected equipment at real scale</li>
                    <li>Drag the equipment to position it on the wall</li>
                    <li>Green wireframe shows required clearance zones</li>
                    <li>Capture photo when positioned correctly</li>
                </ul>
            </div>

            <div class="camera-container" id="live3dContainer">
                <div class="calibration-status locked" id="calibrationStatusBadge2">
                    ‚úì Calibration Locked - Drag equipment to position
                </div>
                <video id="cameraFeed2" autoplay playsinline></video>
                <canvas id="overlayCanvas2"></canvas>
                <canvas id="threejsCanvas" class="threejs-overlay"></canvas>
            </div>

            <div class="live3d-controls">
                <button class="btn btn-secondary" onclick="resetEquipmentPosition()">
                    ‚Ü∫ Reset Position
                </button>
                <button class="btn btn-secondary" id="toggleMeasurementBtn" onclick="toggleMeasurementMode()">
                    üìè Measure Distance
                </button>
                <button class="btn btn-capture" onclick="captureWallPhoto()">
                    üì∏ Capture Photo
                </button>
            </div>

            <div id="measurementInfo" class="hidden" style="background: #e8f4f8; border-left: 4px solid #667eea; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>üìè Measurement Mode Active</strong>
                <p style="margin: 10px 0;">Click two points on the video to measure the distance between them.</p>
                <div id="measurementResult" style="font-size: 20px; font-weight: 600; color: #667eea; margin-top: 10px;"></div>
            </div>

            <!-- Object Shape Customization -->
            <div style="background: #f8f9fa; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4 style="margin-bottom: 15px; color: #667eea;">üé® Customize Object Shape & Size</h4>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Shape:</label>
                        <select id="objectShape" onchange="updateObjectShape()" style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea;">
                            <option value="rectangle">üì¶ Rectangle</option>
                            <option value="circle">‚≠ï Circle</option>
                        </select>
                    </div>
                    <div id="clearanceShapeContainer">
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Clearance Shape:</label>
                        <select id="clearanceShape" onchange="updateObjectShape()" style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea;">
                            <option value="box">üì¶ Box</option>
                            <option value="circle">‚≠ï Circle</option>
                        </select>
                    </div>
                </div>

                <div id="rectangleSettings">
                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Width (mm):</label>
                    <input type="number" id="objectWidth" value="400" min="50" max="5000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea; margin-bottom: 10px;">

                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Height (mm):</label>
                    <input type="number" id="objectHeight" value="600" min="50" max="5000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea; margin-bottom: 10px;">

                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Depth (mm):</label>
                    <input type="number" id="objectDepth" value="300" min="50" max="5000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea;">
                </div>

                <div id="circleSettings" class="hidden">
                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Diameter (mm):</label>
                    <input type="number" id="objectDiameter" value="400" min="50" max="5000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea; margin-bottom: 10px;">

                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Depth (mm):</label>
                    <input type="number" id="circleDepth" value="100" min="50" max="5000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea;">
                </div>

                <div style="margin-top: 15px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 8px;">Clearance Distance (mm):</label>
                    <input type="number" id="clearanceDistance" value="300" min="0" max="2000" onchange="updateObjectShape()"
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #667eea;">
                </div>
            </div>
            
            <button class="btn btn-secondary" onclick="recalibrate()">
                üîÑ Re-calibrate
            </button>
        </div>

        <!-- Step 5: Mark Objects -->
        <div class="card hidden" id="step5">
            <h2>Step 5: Mark Objects</h2>
            
            <div class="instructions">
                <strong>üéØ Tap to mark the flue center and obstacle corners:</strong>
                <ul>
                    <li>First, tap the center of the flue terminal</li>
                    <li>Then, tap corners of windows, doors, vents, etc.</li>
                    <li>The system will draw clearance arcs automatically</li>
                </ul>
            </div>

            <div class="result-container">
                <canvas id="markingCanvas"></canvas>
            </div>

            <div id="markedObjectsList" style="margin: 15px 0;">
                <!-- Dynamically filled -->
            </div>

            <button class="btn btn-success" onclick="analyzeClearances()">
                ‚úì Analyze Clearances
            </button>
            <button class="btn" onclick="goToStep(6)">
                üìπ Use Live Clearance View
            </button>
            <button class="btn btn-secondary" onclick="clearMarks()">
                üóëÔ∏è Clear All Marks
            </button>
        </div>

        <!-- Step 6: Live Clearance View -->
        <div class="card hidden" id="step6">
            <div class="live-clearance-container">
                <div class="live-header">
                    <h2>Live Clearance View</h2>
                    <p>Point your camera at the wall and marker. Tap to set the flue centre.</p>
                </div>
                <div class="live-video-wrapper">
                    <video id="cg-video" autoplay playsinline muted></video>
                    <canvas id="cg-overlay"></canvas>
                </div>
                <div class="live-controls">
                    <button class="btn btn-secondary" id="cg-recalibrate">Recalibrate marker</button>
                    <button class="btn btn-secondary" id="cg-clear-flue">Clear flue point</button>
                </div>
                <p class="live-hint">
                    Tap on the flue terminal on the screen to set the centre. The coloured
                    rings show required clearances (100mm / 300mm / 600mm).
                </p>
                <button class="btn btn-secondary" onclick="startOver()">
                    üîÑ Start New Check
                </button>
            </div>
        </div>

        <!-- Step 7: Results -->
        <div class="card hidden" id="step7">
            <h2>Step 7: Clearance Results</h2>

            <div class="result-container">
                <canvas id="resultCanvas"></canvas>
            </div>

            <div class="clearance-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(231, 76, 60, 0.5);"></div>
                    <span>Red: Non-compliant (&lt;75mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(241, 196, 15, 0.5);"></div>
                    <span>Amber: Influenced (75-150mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(46, 204, 113, 0.5);"></div>
                    <span>Green: Compliant (&gt;300mm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(52, 152, 219, 0.3);"></div>
                    <span>150mm zone</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(155, 89, 182, 0.3);"></div>
                    <span>200mm zone</span>
                </div>
            </div>

            <div id="resultSummary">
                <!-- Dynamically filled -->
            </div>

            <button class="btn btn-success" onclick="downloadResult()">
                üì• Download Annotated Photo
            </button>
            <button class="btn btn-secondary" onclick="startOver()">
                üîÑ Start New Check
            </button>
        </div>

        <!-- OpenCV Loading -->
        <div class="card hidden" id="loadingScreen">
            <div class="loading">
                <div class="spinner"></div>
                <div id="loadingMessage">Loading OpenCV.js...</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // CLEARANCE GENIE - ARUCO CALIBRATION SYSTEM
        // ============================================================

        // OpenCV ready flag
        let cvReady = false;

        function onOpenCvReady() {
            cvReady = true;
            console.log('‚úì OpenCV.js loaded and ready for ArUco detection');
            document.getElementById('loadingScreen')?.classList.add('hidden');
        }

        // Get selected marker size from dropdown
        function getSelectedMarkerSize() {
            const select = document.getElementById('markerSizeSelect');
            if (!select) return 53;

            const value = select.value;
            if (value === 'custom') {
                const customInput = document.getElementById('customMarkerSize');
                return customInput ? parseInt(customInput.value, 10) : 100;
            }
            return parseInt(value, 10);
        }

        // Toggle custom marker size input visibility
        function toggleCustomMarkerSize() {
            const select = document.getElementById('markerSizeSelect');
            const customDiv = document.getElementById('customMarkerSizeInput');

            if (select && customDiv) {
                if (select.value === 'custom') {
                    customDiv.classList.remove('hidden');
                } else {
                    customDiv.classList.add('hidden');
                }
            }
        }

        // Application State
        const state = {
            equipmentType: null,
            currentStep: 1,
            
            // Selected model from ModelStore
            selectedModel: null,
            
            // Calibration
            calibration: {
                locked: false,
                pixelsPerMM: 0,
                markerSize: 53, // Default: 53mm (credit card) - matches first option in markerSizeSelect dropdown
                markerCorners: null,
                rvec: null,
                tvec: null,
                distance: 0,
                orientation: { pitch: 0, yaw: 0, roll: 0 }
            },

            // Multiple ArUco markers tracking
            detectedMarkers: [],
            measurementPoints: [],
            measurementMode: false,
            
            // Camera
            cameraStream: null,
            detectionInterval: null,
            detectionCount: 0,
            requiredDetections: 5,
            
            // Images
            calibrationImage: null,
            wallImage: null,
            
            // Marked objects
            fluePosition: null,
            obstacles: [],
            
            // 3D Rendering
            threeJS: {
                renderer: null,
                scene: null,
                camera: null,
                equipmentMesh: null,
                clearanceMesh: null,
                isInitialized: false,
                animationId: null
            },
            
            // Equipment position (in mm from center)
            equipmentPosition: { x: 0, y: 0 },
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            
            // Metadata
            metadata: {
                timestamp: null,
                gps: null,
                calibrationValid: false
            }
        };
        
        // 3D Rendering Constants
        const RENDER_CONSTANTS = {
            EQUIPMENT_COLOR: 0x667eea,
            CLEARANCE_COLOR: 0x27ae60,
            DEFAULT_DEPTH: 100, // mm - default depth when not specified by model
            DEFAULT_DIMENSIONS: {
                boiler: { width: 400, height: 600, depth: 300 },
                radiator: { width: 1000, height: 600, depth: 100 },
                cylinder: { width: 450, height: 1200, depth: 450 }
            }
        };

        // Equipment Configurations with clearance zones
        const EQUIPMENT_CONFIG = {
            flue: {
                name: 'Flue Terminal',
                icon: 'üå¨Ô∏è',
                diameter: 100, // mm
                defaultDimensions: { width: 100, height: 100, depth: 50 },
                clearanceZones: [
                    { distance: 75, color: 'rgba(231, 76, 60, 0.5)', label: 'Prohibited', status: 'fail' },
                    { distance: 150, color: 'rgba(241, 196, 15, 0.4)', label: '150mm', status: 'amber' },
                    { distance: 200, color: 'rgba(155, 89, 182, 0.3)', label: '200mm', status: 'amber' },
                    { distance: 300, color: 'rgba(46, 204, 113, 0.3)', label: '300mm Safe', status: 'pass' }
                ],
                obstacleClearances: {
                    opening_window: 300,
                    fixed_window: 150,
                    door: 300,
                    air_vent: 300,
                    gas_meter: 300,
                    gutter: 75,
                    boundary: 600
                }
            },
            boiler: {
                name: 'Boiler',
                icon: 'üî•',
                defaultDimensions: { width: 400, height: 600, depth: 300 },
                clearanceZones: [
                    { distance: 50, color: 'rgba(231, 76, 60, 0.5)', label: 'Min', status: 'fail' },
                    { distance: 150, color: 'rgba(241, 196, 15, 0.4)', label: 'Service', status: 'amber' },
                    { distance: 300, color: 'rgba(46, 204, 113, 0.3)', label: 'Optimal', status: 'pass' }
                ]
            },
            radiator: {
                name: 'Radiator',
                icon: '‚ô®Ô∏è',
                defaultDimensions: { width: 1000, height: 600, depth: 100 },
                clearanceZones: [
                    { distance: 50, color: 'rgba(231, 76, 60, 0.5)', label: 'Wall', status: 'fail' },
                    { distance: 100, color: 'rgba(241, 196, 15, 0.4)', label: 'Curtain', status: 'amber' },
                    { distance: 150, color: 'rgba(46, 204, 113, 0.3)', label: 'Furniture', status: 'pass' }
                ]
            },
            cylinder: {
                name: 'Cylinder',
                icon: 'üõ¢Ô∏è',
                defaultDimensions: { width: 450, height: 1200, depth: 450 },
                clearanceZones: [
                    { distance: 150, color: 'rgba(231, 76, 60, 0.5)', label: 'Service', status: 'fail' },
                    { distance: 300, color: 'rgba(241, 196, 15, 0.4)', label: 'Access', status: 'amber' },
                    { distance: 450, color: 'rgba(46, 204, 113, 0.3)', label: 'Discharge', status: 'pass' }
                ]
            }
        };

        // ============================================================
        // STEP 1: Equipment Selection
        // ============================================================

        async function selectEquipment(type) {
            state.equipmentType = type;

            document.querySelectorAll('.equipment-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('selected');

            document.getElementById('continueToCalibration').disabled = false;
            
            // Show model selector for boiler, radiator, cylinder (not flue)
            const modelSelector = document.getElementById('modelSelector');
            if (type !== 'flue') {
                modelSelector.classList.remove('hidden');
                await populateModelDropdown(type);
            } else {
                modelSelector.classList.add('hidden');
                hideModelInfo();
                state.selectedModel = null;
            }
        }
        
        // Populate model dropdown based on equipment type
        async function populateModelDropdown(type) {
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = '<option value="">-- Use Default Dimensions --</option>';
            
            // Load models if not already loaded
            if (typeof ModelStore !== 'undefined') {
                try {
                    await ModelStore.loadAllModels();
                    const models = ModelStore.getModelsByType(type);
                    
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        const displayName = ModelStore.formatModelName(model, type);
                        const dims = model.dimensions;
                        const dimText = dims ? ` (${dims.width}√ó${dims.height}mm)` : '';
                        option.textContent = displayName + dimText;
                        modelSelect.appendChild(option);
                    });
                    
                    console.log(`üì¶ Loaded ${models.length} ${type} models`);
                } catch (error) {
                    console.warn('Failed to load models:', error);
                }
            }
        }
        
        // Handle model selection change
        function onModelSelected() {
            const modelSelect = document.getElementById('modelSelect');
            const modelId = modelSelect.value;
            
            if (modelId && typeof ModelStore !== 'undefined') {
                const result = ModelStore.getModelById(modelId);
                if (result) {
                    state.selectedModel = result.model;
                    showModelInfo(result.model);
                    console.log('üì¶ Selected model:', result.model.id);
                }
            } else {
                state.selectedModel = null;
                hideModelInfo();
            }
        }
        
        // Show model info panel
        function showModelInfo(model) {
            const panel = document.getElementById('modelInfoPanel');
            const dims = model.dimensions || {};
            const clearances = model.serviceClearances || {};

            document.getElementById('modelWidth').textContent = dims.width ? `${dims.width} mm` : '--';
            document.getElementById('modelHeight').textContent = dims.height ? `${dims.height} mm` : '--';
            document.getElementById('modelDepth').textContent = dims.depth ? `${dims.depth} mm` : '--';
            document.getElementById('modelFrontClearance').textContent = clearances.front ? `${clearances.front} mm` : '--';
            document.getElementById('modelSideClearance').textContent = clearances.sides ? `${clearances.sides} mm` : '--';

            panel.classList.remove('hidden');
        }
        
        // Hide model info panel
        function hideModelInfo() {
            document.getElementById('modelInfoPanel').classList.add('hidden');
        }
        
        // Add event listener for model selection
        document.getElementById('modelSelect')?.addEventListener('change', onModelSelected);

        // ============================================================
        // NAVIGATION
        // ============================================================

        function goToStep(stepNumber) {
            for (let i = 1; i <= 7; i++) {
                document.getElementById(`step${i}`)?.classList.add('hidden');
            }
            document.getElementById(`step${stepNumber}`).classList.remove('hidden');
            state.currentStep = stepNumber;
            
            // Initialize live clearance view when entering step 6
            if (stepNumber === 6 && typeof initLiveClearance === 'function') {
                initLiveClearance();
            }
            
            // Dispose live clearance when leaving step 6
            if (stepNumber !== 6 && typeof LiveClearance !== 'undefined' && LiveClearance.isReady()) {
                LiveClearance.dispose();
            }
        }

        // ============================================================
        // STEP 3: ARUCO CALIBRATION
        // ============================================================

        async function startCalibration() {
            if (!cvReady) {
                alert('OpenCV is still loading. Please wait a moment and try again.');
                return;
            }

            // Update marker size from dropdown selection
            state.calibration.markerSize = getSelectedMarkerSize();
            console.log(`üìê Using marker size: ${state.calibration.markerSize}mm`);

            goToStep(3);

            try {
                state.cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                const video = document.getElementById('cameraFeed');
                video.srcObject = state.cameraStream;

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    startArUcoDetection();
                });

            } catch (error) {
                console.error('Camera access error:', error);
                alert('Failed to access camera: ' + error.message);
                goToStep(2);
            }
        }

        function stopCalibration() {
            if (state.detectionInterval) {
                clearInterval(state.detectionInterval);
                state.detectionInterval = null;
            }

            if (state.cameraStream) {
                state.cameraStream.getTracks().forEach(track => track.stop());
                state.cameraStream = null;
            }
        }

        function startArUcoDetection() {
            const video = document.getElementById('cameraFeed');
            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');

            state.detectionCount = 0;

            state.detectionInterval = setInterval(() => {
                if (!video.videoWidth || !video.videoHeight) return;

                // Create temporary canvas to get video frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0);

                // Detect ArUco markers
                const result = detectArUcoMarker(tempCanvas);

                // Clear overlay
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (result.detected) {
                    state.detectionCount++;

                    // Store all detected markers
                    state.detectedMarkers = result.allMarkers || [result];

                    // Draw all detected markers
                    if (result.allMarkers && result.allMarkers.length > 0) {
                        result.allMarkers.forEach((marker, index) => {
                            const color = index === 0 ? '#2ecc71' : '#3498db'; // Primary marker green, others blue
                            drawMarkerOutline(ctx, marker.corners, color, index + 1);
                        });
                    } else {
                        drawMarkerOutline(ctx, result.corners, '#2ecc71', 1);
                    }

                    // Update calibration data
                    updateCalibrationDisplay(result);

                    // Update status badge
                    const badge = document.getElementById('calibrationStatusBadge');
                    const markerCount = result.allMarkers ? result.allMarkers.length : 1;
                    badge.className = 'calibration-status detected';
                    badge.textContent = `‚úì ${markerCount} Marker${markerCount > 1 ? 's' : ''} Detected (${state.detectionCount}/${state.requiredDetections})`;

                    // Enable capture after required detections
                    if (state.detectionCount >= state.requiredDetections) {
                        document.getElementById('captureBtn').disabled = false;
                        badge.className = 'calibration-status locked';
                        badge.textContent = `‚úì Calibration Ready - ${markerCount} Marker${markerCount > 1 ? 's' : ''} Tracked!`;

                        // Store calibration data
                        state.calibration.locked = true;
                        state.calibration.pixelsPerMM = result.pixelsPerMM;
                        state.calibration.markerCorners = result.corners;
                        state.calibration.distance = result.distance;
                        state.calibration.orientation = result.orientation;
                    }

                } else {
                    // Reset detection count if marker lost
                    if (state.detectionCount > 0 && state.detectionCount < state.requiredDetections) {
                        state.detectionCount = Math.max(0, state.detectionCount - 1);
                    }

                    const badge = document.getElementById('calibrationStatusBadge');
                    badge.className = 'calibration-status searching';
                    badge.textContent = 'üîç Searching for ArUco marker...';

                    document.getElementById('detectionStatus').textContent = 'Searching...';
                }

            }, 100); // 10 FPS detection
        }

        function detectArUcoMarker(canvas) {
            try {
                // Read image into OpenCV Mat
                const src = cv.imread(canvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // Create ArUco dictionary (6x6_50)
                // Note: OpenCV.js has limited ArUco support, so we'll use contour-based detection as fallback
                const result = detectMarkerContours(gray, canvas);

                src.delete();
                gray.delete();

                return result;

            } catch (error) {
                console.error('ArUco detection error:', error);
                return { detected: false };
            }
        }

        // Fallback detection using contour analysis for square markers - detects multiple markers
        function detectMarkerContours(grayMat, canvas) {
            try {
                // Apply adaptive thresholding
                const binary = new cv.Mat();
                cv.adaptiveThreshold(grayMat, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                // Find contours
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(binary, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                let allMarkers = [];

                for (let i = 0; i < contours.size(); i++) {
                    const contour = contours.get(i);
                    const area = cv.contourArea(contour);

                    // Filter by area (marker should be reasonably sized)
                    if (area < 1000 || area > canvas.width * canvas.height * 0.5) {
                        contour.delete();
                        continue;
                    }

                    // Approximate contour to polygon
                    const approx = new cv.Mat();
                    const epsilon = 0.04 * cv.arcLength(contour, true);
                    cv.approxPolyDP(contour, approx, epsilon, true);

                    // Check if it's a quadrilateral
                    if (approx.rows === 4) {
                        // Check if it's roughly square (aspect ratio)
                        const corners = [];
                        for (let j = 0; j < 4; j++) {
                            corners.push({
                                x: approx.data32S[j * 2],
                                y: approx.data32S[j * 2 + 1]
                            });
                        }

                        // Calculate side lengths
                        const side1 = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
                        const side2 = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);
                        const aspectRatio = Math.max(side1, side2) / Math.min(side1, side2);

                        // Square markers should have aspect ratio close to 1
                        if (aspectRatio < 1.3) {
                            // Check if interior has black/white pattern (ArUco characteristic)
                            if (hasArUcoPattern(grayMat, corners)) {
                                // Calculate scale
                                const avgSidePx = (side1 + side2) / 2;
                                const pixelsPerMM = avgSidePx / state.calibration.markerSize;

                                // Estimate distance
                                const focalLengthPx = canvas.width * 0.8;
                                const distance = (state.calibration.markerSize * focalLengthPx) / avgSidePx;

                                // Estimate orientation
                                const orientation = estimateOrientation(corners);

                                allMarkers.push({
                                    corners: corners,
                                    pixelsPerMM: pixelsPerMM,
                                    distance: distance,
                                    orientation: orientation,
                                    area: area,
                                    id: allMarkers.length
                                });
                            }
                        }
                    }

                    approx.delete();
                    contour.delete();
                }

                binary.delete();
                contours.delete();
                hierarchy.delete();

                if (allMarkers.length > 0) {
                    // Sort by area (largest first) to prioritize closest markers
                    allMarkers.sort((a, b) => b.area - a.area);

                    // Return primary marker (largest) with all markers info
                    return {
                        detected: true,
                        corners: allMarkers[0].corners,
                        pixelsPerMM: allMarkers[0].pixelsPerMM,
                        distance: allMarkers[0].distance,
                        orientation: allMarkers[0].orientation,
                        allMarkers: allMarkers
                    };
                }

                return { detected: false, allMarkers: [] };

            } catch (error) {
                console.error('Contour detection error:', error);
                return { detected: false, allMarkers: [] };
            }
        }

        // Check if the detected quadrilateral has ArUco-like pattern
        function hasArUcoPattern(grayMat, corners) {
            try {
                // Sample points inside the quadrilateral
                const centerX = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;
                const centerY = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;

                // Check if center region has high contrast (characteristic of ArUco)
                const sampleSize = 10;
                let whiteCount = 0;
                let blackCount = 0;

                for (let dy = -sampleSize; dy <= sampleSize; dy += 5) {
                    for (let dx = -sampleSize; dx <= sampleSize; dx += 5) {
                        const x = Math.round(centerX + dx);
                        const y = Math.round(centerY + dy);
                        
                        if (x >= 0 && x < grayMat.cols && y >= 0 && y < grayMat.rows) {
                            const val = grayMat.ucharAt(y, x);
                            if (val > 128) whiteCount++;
                            else blackCount++;
                        }
                    }
                }

                // ArUco markers have roughly equal black and white areas
                const total = whiteCount + blackCount;
                if (total === 0) return false;
                
                const ratio = Math.min(whiteCount, blackCount) / Math.max(whiteCount, blackCount);
                return ratio > 0.2; // At least 20% contrast balance

            } catch (error) {
                return false;
            }
        }

        function estimateOrientation(corners) {
            // Estimate rotation from quadrilateral shape
            // This is a simplified estimation

            const topWidth = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
            const bottomWidth = Math.hypot(corners[2].x - corners[3].x, corners[2].y - corners[3].y);
            const leftHeight = Math.hypot(corners[3].x - corners[0].x, corners[3].y - corners[0].y);
            const rightHeight = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);

            // Pitch: if top is narrower than bottom, camera is tilted up
            const pitch = Math.atan2(bottomWidth - topWidth, (topWidth + bottomWidth) / 2) * (180 / Math.PI);

            // Yaw: if left is taller than right, camera is rotated right
            const yaw = Math.atan2(leftHeight - rightHeight, (leftHeight + rightHeight) / 2) * (180 / Math.PI);

            // Roll: angle of top edge
            const roll = Math.atan2(corners[1].y - corners[0].y, corners[1].x - corners[0].x) * (180 / Math.PI);

            return { pitch, yaw, roll };
        }

        function drawMarkerOutline(ctx, corners, color, markerId) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            ctx.lineTo(corners[1].x, corners[1].y);
            ctx.lineTo(corners[2].x, corners[2].y);
            ctx.lineTo(corners[3].x, corners[3].y);
            ctx.closePath();
            ctx.stroke();

            // Draw corner circles
            ctx.fillStyle = color;
            corners.forEach((corner, i) => {
                ctx.beginPath();
                ctx.arc(corner.x, corner.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw marker ID in center
            if (markerId !== undefined) {
                const centerX = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;
                const centerY = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;

                ctx.fillStyle = color;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeText(`#${markerId}`, centerX, centerY);
                ctx.fillText(`#${markerId}`, centerX, centerY);
            }
        }

        function updateCalibrationDisplay(result) {
            document.getElementById('detectionStatus').textContent = 'Detected ‚úì';
            document.getElementById('scaleValue').textContent =
                result.pixelsPerMM.toFixed(3) + ' px/mm';
            document.getElementById('distanceValue').textContent =
                Math.round(result.distance) + ' mm';
            document.getElementById('orientationValue').textContent =
                `P:${result.orientation.pitch.toFixed(1)}¬∞ Y:${result.orientation.yaw.toFixed(1)}¬∞ R:${result.orientation.roll.toFixed(1)}¬∞`;

            // Update marker count
            const markerCount = result.allMarkers ? result.allMarkers.length : 1;
            document.getElementById('markerCountValue').textContent = markerCount;

            // Show all markers info if multiple detected
            const allMarkersInfo = document.getElementById('allMarkersInfo');
            const markersListContainer = document.getElementById('markersListContainer');

            if (result.allMarkers && result.allMarkers.length > 1) {
                allMarkersInfo.classList.remove('hidden');

                let html = '<div style="display: grid; gap: 10px;">';
                result.allMarkers.forEach((marker, index) => {
                    const isPrimary = index === 0;
                    const bgColor = isPrimary ? '#d4edda' : '#d1ecf1';
                    const label = isPrimary ? '(Primary)' : '';

                    html += `
                        <div style="background: ${bgColor}; padding: 10px; border-radius: 6px;">
                            <strong>Marker #${index + 1} ${label}</strong><br>
                            <small>
                                Distance: ${Math.round(marker.distance)}mm |
                                Scale: ${marker.pixelsPerMM.toFixed(3)} px/mm
                            </small>
                        </div>
                    `;
                });
                html += '</div>';

                markersListContainer.innerHTML = html;
            } else {
                allMarkersInfo.classList.add('hidden');
            }
        }

        // ============================================================
        // STEP 4: CAPTURE PHOTO
        // ============================================================

        function capturePhoto() {
            if (!state.calibration.locked) {
                alert('Calibration not ready. Please wait for marker detection.');
                return;
            }

            const video = document.getElementById('cameraFeed');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            state.calibrationImage = canvas.toDataURL('image/jpeg', 0.9);

            // Store metadata
            state.metadata.timestamp = new Date().toISOString();
            state.metadata.calibrationValid = true;

            // Try to get GPS
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        state.metadata.gps = {
                            latitude: pos.coords.latitude,
                            longitude: pos.coords.longitude,
                            accuracy: pos.coords.accuracy
                        };
                    },
                    (err) => {
                        console.log('GPS not available:', err.message);
                    }
                );
            }

            // Stop detection and move to wall capture
            stopCalibration();
            goToStep(4);
            startWallCapture();
        }

        async function startWallCapture() {
            // Update locked calibration info
            const config = EQUIPMENT_CONFIG[state.equipmentType];
            let modelInfo = '';
            if (state.selectedModel) {
                modelInfo = ` | Model: ${state.selectedModel.id}`;
            }
            document.getElementById('lockedCalibrationInfo').textContent = 
                `Scale: ${state.calibration.pixelsPerMM.toFixed(3)} px/mm | ` +
                `Distance: ${Math.round(state.calibration.distance)}mm | ` +
                `Marker: ${state.calibration.markerSize}mm ArUco${modelInfo}`;

            try {
                state.cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                const video = document.getElementById('cameraFeed2');
                video.srcObject = state.cameraStream;
                
                // Wait for video to load, then start 3D rendering
                video.addEventListener('loadedmetadata', () => {
                    setTimeout(() => {
                        start3DRendering();
                    }, 100);
                });

            } catch (error) {
                console.error('Camera error:', error);
                alert('Failed to restart camera: ' + error.message);
            }
        }

        function captureWallPhoto() {
            const video = document.getElementById('cameraFeed2');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            // Composite 3D overlay onto the captured image
            const threejsCanvas = document.getElementById('threejsCanvas');
            if (threejsCanvas && state.threeJS.isInitialized) {
                // Scale Three.js canvas to match video dimensions
                const scaleX = video.videoWidth / threejsCanvas.width;
                const scaleY = video.videoHeight / threejsCanvas.height;
                ctx.save();
                ctx.scale(scaleX, scaleY);
                ctx.drawImage(threejsCanvas, 0, 0);
                ctx.restore();
            }
            
            // Store equipment position in the image coordinates
            if (state.equipmentPosition) {
                // Convert mm position to pixel position for marking
                const centerX = canvas.width / 2 + (state.equipmentPosition.x * state.calibration.pixelsPerMM);
                const centerY = canvas.height / 2 - (state.equipmentPosition.y * state.calibration.pixelsPerMM);
                state.fluePosition = { x: centerX, y: centerY };
            }

            state.wallImage = new Image();
            state.wallImage.onload = () => {
                stopCalibration();
                dispose3DRenderer();
                goToStep(5);
                setupMarkingCanvas();
            };
            state.wallImage.src = canvas.toDataURL('image/jpeg', 0.9);
        }

        function recalibrate() {
            state.calibration.locked = false;
            state.calibration.pixelsPerMM = 0;
            state.detectionCount = 0;
            state.detectedMarkers = [];

            // Disable measurement mode if active
            if (state.measurementMode) {
                toggleMeasurementMode();
            }

            dispose3DRenderer();
            stopCalibration();
            goToStep(3);
            startCalibration();
        }

        // ============================================================
        // MEASUREMENT TOOL
        // ============================================================

        function toggleMeasurementMode() {
            state.measurementMode = !state.measurementMode;
            state.measurementPoints = [];

            const btn = document.getElementById('toggleMeasurementBtn');
            const info = document.getElementById('measurementInfo');
            const canvas = document.getElementById('overlayCanvas2');

            if (state.measurementMode) {
                btn.textContent = '‚ùå Cancel Measurement';
                btn.classList.add('btn-capture');
                btn.classList.remove('btn-secondary');
                info.classList.remove('hidden');
                document.getElementById('measurementResult').textContent = '';
                canvas.style.pointerEvents = 'auto';
                canvas.style.cursor = 'crosshair';

                // Add click listener for measurements
                canvas.onclick = handleMeasurementClick;
            } else {
                btn.textContent = 'üìè Measure Distance';
                btn.classList.remove('btn-capture');
                btn.classList.add('btn-secondary');
                info.classList.add('hidden');
                canvas.style.pointerEvents = 'none';
                canvas.style.cursor = 'default';
                canvas.onclick = null;

                // Clear measurement overlay
                clearMeasurementOverlay();
            }
        }

        function handleMeasurementClick(e) {
            if (!state.calibration.locked) {
                alert('Please complete calibration first!');
                return;
            }

            const canvas = document.getElementById('overlayCanvas2');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            state.measurementPoints.push({ x, y });

            if (state.measurementPoints.length === 1) {
                // First point - show it
                drawMeasurementOverlay();
                document.getElementById('measurementResult').textContent = 'Click second point...';
            } else if (state.measurementPoints.length === 2) {
                // Second point - calculate and show distance
                const p1 = state.measurementPoints[0];
                const p2 = state.measurementPoints[1];

                const distancePx = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                const distanceMM = distancePx / state.calibration.pixelsPerMM;

                drawMeasurementOverlay();

                // Display result
                let distanceText = '';
                if (distanceMM < 1000) {
                    distanceText = `${Math.round(distanceMM)}mm`;
                } else {
                    distanceText = `${(distanceMM / 1000).toFixed(2)}m (${Math.round(distanceMM)}mm)`;
                }

                document.getElementById('measurementResult').textContent = `Distance: ${distanceText}`;

                // Reset for next measurement
                setTimeout(() => {
                    state.measurementPoints = [];
                }, 3000);
            }
        }

        function drawMeasurementOverlay() {
            const canvas = document.getElementById('overlayCanvas2');
            const ctx = canvas.getContext('2d');

            // Don't clear - draw on top of existing content
            if (state.measurementPoints.length === 0) return;

            // Draw points
            state.measurementPoints.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), point.x, point.y + 5);
            });

            // Draw line between points if we have 2
            if (state.measurementPoints.length === 2) {
                const p1 = state.measurementPoints[0];
                const p2 = state.measurementPoints[1];

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw distance label at midpoint
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;

                const distancePx = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                const distanceMM = distancePx / state.calibration.pixelsPerMM;

                let distanceText = '';
                if (distanceMM < 1000) {
                    distanceText = `${Math.round(distanceMM)}mm`;
                } else {
                    distanceText = `${(distanceMM / 1000).toFixed(2)}m`;
                }

                // Background for text
                ctx.font = 'bold 20px Arial';
                const textWidth = ctx.measureText(distanceText).width;
                ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
                ctx.fillRect(midX - textWidth / 2 - 10, midY - 20, textWidth + 20, 30);

                // Text
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(distanceText, midX, midY - 5);
            }
        }

        function clearMeasurementOverlay() {
            const canvas = document.getElementById('overlayCanvas2');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Add continuous update for measurement overlay during 3D rendering
        function updateMeasurementOverlay() {
            if (state.measurementMode && state.measurementPoints.length > 0) {
                // Redraw measurement on overlay canvas
                const canvas = document.getElementById('overlayCanvas2');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMeasurementOverlay();
            }
        }

        // ============================================================
        // STEP 5: MARK OBJECTS
        // ============================================================

        function setupMarkingCanvas() {
            const canvas = document.getElementById('markingCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = state.wallImage.width;
            canvas.height = state.wallImage.height;

            ctx.drawImage(state.wallImage, 0, 0);

            // Reset marks
            state.fluePosition = null;
            state.obstacles = [];

            // Setup click handler
            canvas.onclick = handleMarkingClick;

            updateMarkedObjectsList();
        }

        function handleMarkingClick(e) {
            const canvas = document.getElementById('markingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (!state.fluePosition) {
                // First click marks flue center
                state.fluePosition = { x, y };
            } else {
                // Subsequent clicks mark obstacles
                state.obstacles.push({ 
                    x, y, 
                    type: 'obstacle',
                    label: `Obstacle ${state.obstacles.length + 1}`
                });
            }

            redrawMarkingCanvas();
            updateMarkedObjectsList();
        }

        function redrawMarkingCanvas() {
            const canvas = document.getElementById('markingCanvas');
            const ctx = canvas.getContext('2d');

            // Redraw image
            ctx.drawImage(state.wallImage, 0, 0);

            // Draw flue position
            if (state.fluePosition) {
                const config = EQUIPMENT_CONFIG[state.equipmentType];
                
                // Draw flue marker
                ctx.beginPath();
                ctx.arc(state.fluePosition.x, state.fluePosition.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(config.icon, state.fluePosition.x, state.fluePosition.y + 5);
            }

            // Draw obstacles
            state.obstacles.forEach((obs, i) => {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), obs.x, obs.y + 4);
            });
        }

        function updateMarkedObjectsList() {
            const list = document.getElementById('markedObjectsList');
            let html = '<h4 style="margin-bottom: 10px;">Marked Objects:</h4>';

            if (state.fluePosition) {
                const config = EQUIPMENT_CONFIG[state.equipmentType];
                html += `<div style="padding: 8px; background: #f8d7da; border-radius: 4px; margin-bottom: 5px;">
                    ${config.icon} ${config.name} - Center marked
                </div>`;
            } else {
                html += `<div style="padding: 8px; background: #fff3cd; border-radius: 4px; margin-bottom: 5px;">
                    üëÜ Tap to mark ${EQUIPMENT_CONFIG[state.equipmentType].name} center first
                </div>`;
            }

            state.obstacles.forEach((obs, i) => {
                html += `<div style="padding: 8px; background: #d1ecf1; border-radius: 4px; margin-bottom: 5px;">
                    ${i + 1}. ${obs.label}
                </div>`;
            });

            list.innerHTML = html;
        }

        function clearMarks() {
            state.fluePosition = null;
            state.obstacles = [];
            redrawMarkingCanvas();
            updateMarkedObjectsList();
        }

        // ============================================================
        // STEP 6: ANALYZE CLEARANCES
        // ============================================================

        function analyzeClearances() {
            if (!state.fluePosition) {
                alert('Please mark the flue/equipment position first.');
                return;
            }

            goToStep(7);
            drawClearanceResults();
        }

        function drawClearanceResults() {
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = state.wallImage.width;
            canvas.height = state.wallImage.height;

            // Draw wall image
            ctx.drawImage(state.wallImage, 0, 0);

            const config = EQUIPMENT_CONFIG[state.equipmentType];
            const pxPerMM = state.calibration.pixelsPerMM;

            // Draw clearance arcs (curved zones, not boxes)
            config.clearanceZones.slice().reverse().forEach(zone => {
                const radiusPx = zone.distance * pxPerMM;
                
                ctx.beginPath();
                ctx.arc(state.fluePosition.x, state.fluePosition.y, radiusPx, 0, Math.PI * 2);
                ctx.fillStyle = zone.color;
                ctx.fill();
                ctx.strokeStyle = zone.color.replace(/[\d.]+\)$/, '1)');
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw flue center (100mm diameter)
            const flueDiameterPx = (config.diameter || 100) * pxPerMM;
            ctx.beginPath();
            ctx.arc(state.fluePosition.x, state.fluePosition.y, flueDiameterPx / 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(52, 73, 94, 0.8)';
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw flue icon
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(config.icon, state.fluePosition.x, state.fluePosition.y);

            // Check obstacles and determine compliance
            let violations = [];
            let warnings = [];
            let compliant = [];

            state.obstacles.forEach((obs, i) => {
                const distancePx = Math.hypot(obs.x - state.fluePosition.x, obs.y - state.fluePosition.y);
                const distanceMM = distancePx / pxPerMM;

                // Draw obstacle marker
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, 12, 0, Math.PI * 2);
                
                // Determine status based on distance
                let status = 'pass';
                let color = '#2ecc71';
                
                for (const zone of config.clearanceZones) {
                    if (distanceMM <= zone.distance) {
                        status = zone.status;
                        if (status === 'fail') color = '#e74c3c';
                        else if (status === 'amber') color = '#f39c12';
                        break;
                    }
                }

                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label with distance
                ctx.fillStyle = color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${Math.round(distanceMM)}mm`, obs.x + 18, obs.y + 4);

                // Categorize
                if (status === 'fail') {
                    violations.push({ label: obs.label, distance: distanceMM });
                } else if (status === 'amber') {
                    warnings.push({ label: obs.label, distance: distanceMM });
                } else {
                    compliant.push({ label: obs.label, distance: distanceMM });
                }
            });

            // Draw zone labels
            config.clearanceZones.forEach(zone => {
                const radiusPx = zone.distance * pxPerMM;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${zone.distance}mm`, state.fluePosition.x, state.fluePosition.y - radiusPx - 5);
            });

            // Generate result summary
            generateResultSummary(violations, warnings, compliant);
        }

        function generateResultSummary(violations, warnings, compliant) {
            const summary = document.getElementById('resultSummary');
            let html = '';

            if (violations.length > 0) {
                html += `<div class="result-box non-compliant">
                    <div class="result-icon">‚ùå</div>
                    <div class="result-title">NON-COMPLIANT</div>
                    <div class="result-details">
                        ${violations.length} clearance violation(s) found
                    </div>
                </div>`;

                html += '<h4 style="margin-top: 15px; color: #e74c3c;">Violations:</h4>';
                html += '<ul style="margin-left: 20px; color: #e74c3c;">';
                violations.forEach(v => {
                    html += `<li>${v.label}: ${Math.round(v.distance)}mm (too close)</li>`;
                });
                html += '</ul>';

            } else if (warnings.length > 0) {
                html += `<div class="result-box amber">
                    <div class="result-icon">‚ö†Ô∏è</div>
                    <div class="result-title">INFLUENCED</div>
                    <div class="result-details">
                        ${warnings.length} item(s) require engineer consideration
                    </div>
                </div>`;

            } else {
                html += `<div class="result-box compliant">
                    <div class="result-icon">‚úÖ</div>
                    <div class="result-title">COMPLIANT</div>
                    <div class="result-details">
                        All clearances meet requirements
                    </div>
                </div>`;
            }

            // Add metadata
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 12px; color: #6c757d;">
                <strong>Metadata:</strong><br>
                Timestamp: ${state.metadata.timestamp || 'N/A'}<br>
                GPS: ${state.metadata.gps ? `${state.metadata.gps.latitude.toFixed(5)}, ${state.metadata.gps.longitude.toFixed(5)}` : 'Not available'}<br>
                Calibration: ${state.calibration.pixelsPerMM.toFixed(3)} px/mm (ArUco ${state.calibration.markerSize}mm)
            </div>`;

            summary.innerHTML = html;
        }

        // ============================================================
        // DOWNLOAD & RESTART
        // ============================================================

        function downloadResult() {
            const canvas = document.getElementById('resultCanvas');
            const link = document.createElement('a');
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `clearance-check-${state.equipmentType}-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function startOver() {
            stopCalibration();
            dispose3DRenderer();

            // Dispose live clearance if active
            if (typeof LiveClearance !== 'undefined' && LiveClearance.isReady()) {
                LiveClearance.dispose();
            }

            // Disable measurement mode if active
            if (state.measurementMode) {
                toggleMeasurementMode();
            }

            // Reset state
            state.equipmentType = null;
            state.selectedModel = null;
            state.calibration.locked = false;
            state.calibration.pixelsPerMM = 0;
            state.detectionCount = 0;
            state.fluePosition = null;
            state.obstacles = [];
            state.wallImage = null;
            state.calibrationImage = null;
            state.equipmentPosition = { x: 0, y: 0 };
            state.detectedMarkers = [];
            state.measurementPoints = [];
            state.measurementMode = false;

            // Reset UI
            document.querySelectorAll('.equipment-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('continueToCalibration').disabled = true;
            document.getElementById('captureBtn').disabled = true;
            document.getElementById('modelSelector').classList.add('hidden');
            document.getElementById('allMarkersInfo')?.classList.add('hidden');
            hideModelInfo();

            goToStep(1);
        }

        // ============================================================
        // 3D RENDERING WITH THREE.JS
        // ============================================================
        
        // Initialize 3D renderer when entering Step 4
        function init3DRenderer() {
            if (typeof THREE === 'undefined') {
                console.warn('Three.js not loaded, 3D overlay disabled');
                return false;
            }
            
            if (state.threeJS.isInitialized) {
                return true;
            }
            
            const container = document.getElementById('live3dContainer');
            const video = document.getElementById('cameraFeed2');
            const canvas = document.getElementById('threejsCanvas');
            
            if (!container || !video || !canvas) {
                console.warn('3D container elements not found');
                return false;
            }
            
            // Create renderer
            state.threeJS.renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            state.threeJS.renderer.setPixelRatio(window.devicePixelRatio);
            
            // Create scene
            state.threeJS.scene = new THREE.Scene();
            
            // Create orthographic camera
            state.threeJS.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 2000);
            state.threeJS.camera.position.z = 500;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            state.threeJS.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 0, 1);
            state.threeJS.scene.add(directionalLight);
            
            // Setup event listeners for dragging
            setupDragListeners();
            
            state.threeJS.isInitialized = true;
            console.log('‚úì 3D renderer initialized');
            
            return true;
        }
        
        // Update 3D camera to match calibrated mm-based coordinate system
        function update3DCamera() {
            if (!state.threeJS.isInitialized || !state.calibration.locked) return;
            
            const video = document.getElementById('cameraFeed2');
            if (!video.videoWidth || !video.videoHeight) return;
            
            const mmPerPixel = 1 / state.calibration.pixelsPerMM;
            const screenWidthMM = video.clientWidth * mmPerPixel;
            const screenHeightMM = video.clientHeight * mmPerPixel;
            
            state.threeJS.camera.left = -screenWidthMM / 2;
            state.threeJS.camera.right = screenWidthMM / 2;
            state.threeJS.camera.top = screenHeightMM / 2;
            state.threeJS.camera.bottom = -screenHeightMM / 2;
            state.threeJS.camera.updateProjectionMatrix();
        }
        
        // Create or update equipment mesh
        function updateEquipmentMesh() {
            const config = EQUIPMENT_CONFIG[state.equipmentType];
            if (!config) return;
            
            // Get dimensions from selected model, config defaults, or render constants
            let dims;
            if (state.selectedModel && state.selectedModel.dimensions) {
                dims = state.selectedModel.dimensions;
            } else if (config.defaultDimensions) {
                dims = config.defaultDimensions;
            } else if (config.diameter) {
                // Flue - circular
                dims = { width: config.diameter, height: config.diameter, depth: RENDER_CONSTANTS.DEFAULT_DEPTH / 2 };
            } else {
                // Fallback to render constants
                dims = RENDER_CONSTANTS.DEFAULT_DIMENSIONS[state.equipmentType] || 
                       { width: 400, height: 600, depth: RENDER_CONSTANTS.DEFAULT_DEPTH };
            }
            
            // Remove existing meshes
            if (state.threeJS.equipmentMesh) {
                state.threeJS.scene.remove(state.threeJS.equipmentMesh);
                state.threeJS.equipmentMesh.geometry.dispose();
                state.threeJS.equipmentMesh.material.dispose();
            }
            if (state.threeJS.clearanceMesh) {
                state.threeJS.scene.remove(state.threeJS.clearanceMesh);
                state.threeJS.clearanceMesh.geometry.dispose();
                state.threeJS.clearanceMesh.material.dispose();
            }
            
            // Create equipment box
            const equipmentGeometry = new THREE.BoxGeometry(
                dims.width, 
                dims.height, 
                dims.depth || RENDER_CONSTANTS.DEFAULT_DEPTH
            );
            const equipmentMaterial = new THREE.MeshPhongMaterial({
                color: RENDER_CONSTANTS.EQUIPMENT_COLOR,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            state.threeJS.equipmentMesh = new THREE.Mesh(equipmentGeometry, equipmentMaterial);
            
            // Add wireframe edge
            const edges = new THREE.EdgesGeometry(equipmentGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            state.threeJS.equipmentMesh.add(wireframe);
            
            state.threeJS.scene.add(state.threeJS.equipmentMesh);
            
            // Create clearance halo
            let clearances = { front: 50, sides: 50, above: 150, below: 50 };
            if (state.selectedModel && state.selectedModel.serviceClearances) {
                clearances = state.selectedModel.serviceClearances;
            } else if (config.clearanceZones && config.clearanceZones.length > 0) {
                // Use first clearance zone distance
                const minClearance = config.clearanceZones[0].distance;
                clearances = { front: minClearance, sides: minClearance, above: minClearance, below: minClearance };
            }
            
            const haloWidth = dims.width + (clearances.sides || 0) * 2;
            const haloHeight = dims.height + (clearances.above || 0) + (clearances.below || 0);
            const haloDepth = (dims.depth || RENDER_CONSTANTS.DEFAULT_DEPTH) + (clearances.front || 0);
            
            const haloOffsetY = ((clearances.above || 0) - (clearances.below || 0)) / 2;
            
            const haloGeometry = new THREE.BoxGeometry(haloWidth, haloHeight, haloDepth);
            const haloEdges = new THREE.EdgesGeometry(haloGeometry);
            const haloMaterial = new THREE.LineBasicMaterial({
                color: RENDER_CONSTANTS.CLEARANCE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            state.threeJS.clearanceMesh = new THREE.LineSegments(haloEdges, haloMaterial);
            state.threeJS.clearanceMesh.position.y = haloOffsetY;
            
            state.threeJS.scene.add(state.threeJS.clearanceMesh);
            
            // Set initial position
            updateMeshPositions();
            
            console.log(`üì¶ Created 3D mesh: ${dims.width}√ó${dims.height}√ó${dims.depth || RENDER_CONSTANTS.DEFAULT_DEPTH}mm`);
        }
        
        // Update mesh positions based on current equipment position
        function updateMeshPositions() {
            if (state.threeJS.equipmentMesh) {
                state.threeJS.equipmentMesh.position.x = state.equipmentPosition.x;
                state.threeJS.equipmentMesh.position.y = state.equipmentPosition.y;
            }
            if (state.threeJS.clearanceMesh) {
                state.threeJS.clearanceMesh.position.x = state.equipmentPosition.x;
                // Keep the y-offset for asymmetric clearances
                const currentOffsetY = state.threeJS.clearanceMesh.position.y - state.equipmentPosition.y;
                state.threeJS.clearanceMesh.position.y = state.equipmentPosition.y + currentOffsetY;
            }
        }

        // Update object shape based on user selection
        function updateObjectShape() {
            const shape = document.getElementById('objectShape')?.value;
            const clearanceShape = document.getElementById('clearanceShape')?.value;

            // Toggle settings visibility
            const rectangleSettings = document.getElementById('rectangleSettings');
            const circleSettings = document.getElementById('circleSettings');

            if (shape === 'rectangle') {
                rectangleSettings?.classList.remove('hidden');
                circleSettings?.classList.add('hidden');
            } else {
                rectangleSettings?.classList.add('hidden');
                circleSettings?.classList.remove('hidden');
            }

            // Recreate the 3D mesh if already initialized
            if (state.threeJS.isInitialized && state.currentStep === 4) {
                updateEquipmentMeshWithCustomShape();
            }
        }

        // Update equipment mesh with custom shape
        function updateEquipmentMeshWithCustomShape() {
            if (!state.threeJS.isInitialized) return;

            const shape = document.getElementById('objectShape')?.value || 'rectangle';
            const clearanceShape = document.getElementById('clearanceShape')?.value || 'box';
            const clearanceDistance = parseInt(document.getElementById('clearanceDistance')?.value || '300', 10);

            // Remove existing meshes
            if (state.threeJS.equipmentMesh) {
                state.threeJS.scene.remove(state.threeJS.equipmentMesh);
                state.threeJS.equipmentMesh.geometry.dispose();
                state.threeJS.equipmentMesh.material.dispose();
            }
            if (state.threeJS.clearanceMesh) {
                state.threeJS.scene.remove(state.threeJS.clearanceMesh);
                state.threeJS.clearanceMesh.geometry.dispose();
                state.threeJS.clearanceMesh.material.dispose();
            }

            // Get dimensions based on shape
            let geometry, clearanceGeometry;

            if (shape === 'rectangle') {
                const width = parseInt(document.getElementById('objectWidth')?.value || '400', 10);
                const height = parseInt(document.getElementById('objectHeight')?.value || '600', 10);
                const depth = parseInt(document.getElementById('objectDepth')?.value || '300', 10);

                geometry = new THREE.BoxGeometry(width, height, depth);

                // Clearance mesh
                if (clearanceShape === 'box') {
                    clearanceGeometry = new THREE.BoxGeometry(
                        width + clearanceDistance * 2,
                        height + clearanceDistance * 2,
                        depth + clearanceDistance
                    );
                } else {
                    // Cylindrical clearance around box
                    const radius = Math.max(width, height) / 2 + clearanceDistance;
                    clearanceGeometry = new THREE.CylinderGeometry(radius, radius, depth + clearanceDistance, 32);
                    clearanceGeometry.rotateX(Math.PI / 2);
                }
            } else {
                // Circle shape
                const diameter = parseInt(document.getElementById('objectDiameter')?.value || '400', 10);
                const depth = parseInt(document.getElementById('circleDepth')?.value || '100', 10);
                const radius = diameter / 2;

                geometry = new THREE.CylinderGeometry(radius, radius, depth, 32);
                geometry.rotateX(Math.PI / 2);

                // Clearance mesh
                const clearanceRadius = radius + clearanceDistance;
                clearanceGeometry = new THREE.CylinderGeometry(
                    clearanceRadius,
                    clearanceRadius,
                    depth + clearanceDistance,
                    32
                );
                clearanceGeometry.rotateX(Math.PI / 2);
            }

            // Create equipment mesh
            const equipmentMaterial = new THREE.MeshPhongMaterial({
                color: RENDER_CONSTANTS.EQUIPMENT_COLOR,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            state.threeJS.equipmentMesh = new THREE.Mesh(geometry, equipmentMaterial);

            // Add wireframe edge
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            state.threeJS.equipmentMesh.add(wireframe);

            state.threeJS.scene.add(state.threeJS.equipmentMesh);

            // Create clearance mesh
            const haloEdges = new THREE.EdgesGeometry(clearanceGeometry);
            const haloMaterial = new THREE.LineBasicMaterial({
                color: RENDER_CONSTANTS.CLEARANCE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            state.threeJS.clearanceMesh = new THREE.LineSegments(haloEdges, haloMaterial);

            state.threeJS.scene.add(state.threeJS.clearanceMesh);

            // Update positions
            updateMeshPositions();

            console.log(`‚úì Updated 3D mesh: Shape=${shape}, Clearance=${clearanceShape}`);
        }
        
        // Reset equipment to center
        function resetEquipmentPosition() {
            state.equipmentPosition = { x: 0, y: 0 };
            updateMeshPositions();
        }
        
        // Setup drag listeners for equipment positioning
        function setupDragListeners() {
            const canvas = document.getElementById('threejsCanvas');
            if (!canvas) return;
            
            canvas.style.cursor = 'grab';
            
            const getWorldCoords = (event) => {
                if (!state.calibration.locked) return { x: 0, y: 0 };
                
                const rect = canvas.getBoundingClientRect();
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                // Convert to normalized coordinates (-1 to 1)
                const nx = (x / rect.width) * 2 - 1;
                const ny = -((y / rect.height) * 2 - 1);
                
                // Convert to world coordinates (mm)
                const mmPerPixel = 1 / state.calibration.pixelsPerMM;
                const screenWidthMM = rect.width * mmPerPixel;
                const screenHeightMM = rect.height * mmPerPixel;
                
                return {
                    x: nx * screenWidthMM / 2,
                    y: ny * screenHeightMM / 2
                };
            };
            
            canvas.addEventListener('pointerdown', (e) => {
                if (!state.threeJS.equipmentMesh) return;
                
                const worldPos = getWorldCoords(e);
                state.isDragging = true;
                state.dragOffset.x = state.equipmentPosition.x - worldPos.x;
                state.dragOffset.y = state.equipmentPosition.y - worldPos.y;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('pointermove', (e) => {
                if (!state.isDragging) return;
                
                const worldPos = getWorldCoords(e);
                state.equipmentPosition.x = worldPos.x + state.dragOffset.x;
                state.equipmentPosition.y = worldPos.y + state.dragOffset.y;
                updateMeshPositions();
            });
            
            canvas.addEventListener('pointerup', () => {
                state.isDragging = false;
                const canvas = document.getElementById('threejsCanvas');
                if (canvas) canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('pointerleave', () => {
                state.isDragging = false;
                const canvas = document.getElementById('threejsCanvas');
                if (canvas) canvas.style.cursor = 'grab';
            });
        }
        
        // 3D animation loop
        function animate3D() {
            if (!state.threeJS.isInitialized) return;

            state.threeJS.animationId = requestAnimationFrame(animate3D);

            // Resize if needed
            const video = document.getElementById('cameraFeed2');
            const canvas = document.getElementById('threejsCanvas');
            const overlayCanvas = document.getElementById('overlayCanvas2');

            if (video && canvas && video.clientWidth > 0) {
                const width = video.clientWidth;
                const height = video.clientHeight;

                if (canvas.width !== width || canvas.height !== height) {
                    state.threeJS.renderer.setSize(width, height);
                    update3DCamera();
                }

                // Update overlay canvas size to match video
                if (overlayCanvas && (overlayCanvas.width !== video.videoWidth || overlayCanvas.height !== video.videoHeight)) {
                    overlayCanvas.width = video.videoWidth;
                    overlayCanvas.height = video.videoHeight;
                }
            }

            // Update measurement overlay if active
            updateMeasurementOverlay();

            // Render 3D scene
            state.threeJS.renderer.render(state.threeJS.scene, state.threeJS.camera);
        }
        
        // Start 3D rendering
        function start3DRendering() {
            if (!init3DRenderer()) return;
            
            updateEquipmentMesh();
            update3DCamera();
            animate3D();
            
            console.log('‚úì 3D rendering started');
        }
        
        // Dispose 3D renderer
        function dispose3DRenderer() {
            if (!state.threeJS.isInitialized) return;
            
            if (state.threeJS.animationId) {
                cancelAnimationFrame(state.threeJS.animationId);
                state.threeJS.animationId = null;
            }
            
            if (state.threeJS.equipmentMesh) {
                state.threeJS.scene.remove(state.threeJS.equipmentMesh);
                state.threeJS.equipmentMesh.geometry.dispose();
                state.threeJS.equipmentMesh.material.dispose();
                state.threeJS.equipmentMesh = null;
            }
            
            if (state.threeJS.clearanceMesh) {
                state.threeJS.scene.remove(state.threeJS.clearanceMesh);
                state.threeJS.clearanceMesh.geometry.dispose();
                state.threeJS.clearanceMesh.material.dispose();
                state.threeJS.clearanceMesh = null;
            }
            
            if (state.threeJS.renderer) {
                state.threeJS.renderer.dispose();
                state.threeJS.renderer = null;
            }
            
            state.threeJS.scene = null;
            state.threeJS.camera = null;
            state.threeJS.isInitialized = false;
            
            console.log('‚úì 3D renderer disposed');
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================

        console.log('üî• Clearance Genie - ArUco Calibration with 3D Object Placement');
        console.log('üìê Marker sizes available: 53mm (credit card), 148mm (A5), 210mm (A4)');
    </script>
</body>
</html>
