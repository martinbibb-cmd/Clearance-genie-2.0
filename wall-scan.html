<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clearance-Genie – Wall Scan (Experimental)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- OpenCV.js (async load) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b0c10;
      color: #f5f5f5;
    }

    body {
      margin: 0;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    h1 {
      margin: 0 0 0.25rem;
      font-size: 1.4rem;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #bbbbbb;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    button {
      padding: 0.5rem 0.9rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      background: #1f6feb;
      color: #fff;
    }

    button.secondary {
      background: #30363d;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .status {
      font-size: 0.85rem;
      color: #cccccc;
    }

    .status strong {
      color: #f5f5f5;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    @media (min-width: 900px) {
      .layout {
        grid-template-columns: 1fr 1fr;
      }
    }

    .panel {
      background: #111827;
      border-radius: 0.75rem;
      padding: 0.75rem;
      border: 1px solid #1f2933;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .panel h2 {
      margin: 0;
      font-size: 1rem;
    }

    video, canvas {
      width: 100%;
      max-height: 60vh;
      border-radius: 0.5rem;
      background: #020617;
      border: 1px solid #1f2933;
    }

    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .point-indicator {
      font-size: 0.8rem;
      margin-top: 0.25rem;
      color: #e5e7eb;
    }

    .point-indicator span {
      display: inline-block;
      min-width: 1.5rem;
      text-align: center;
      padding: 0.1rem 0.25rem;
      border-radius: 0.3rem;
      background: #1f2937;
      margin-right: 0.25rem;
    }
  </style>
</head>
<body>
  <header>
    <h1>Clearance-Genie – Wall Scan (Experimental)</h1>
    <div class="subtitle">
      Capture a wall photo inside the app, then click the 4 corners of your calibration card to flatten the wall.
    </div>
  </header>

  <section class="controls">
    <button id="startCameraBtn">Start Camera</button>
    <button id="captureBtn" disabled>Capture Frame</button>
    <button id="resetPointsBtn" class="secondary" disabled>Reset Card Points</button>
    <span class="status" id="statusText">
      <strong>Step 1:</strong> Tap <strong>Start Camera</strong>, hold the phone roughly square to the wall, with your card visible.
    </span>
  </section>

  <section class="layout">
    <div class="panel">
      <h2>1. Live / Original View</h2>
      <div class="hint">
        When ready, tap <strong>Capture Frame</strong>, then click the 4 corners of your card in order:
        top-left → top-right → bottom-right → bottom-left.
      </div>
      <video id="video" autoplay playsinline></video>
      <canvas id="originalCanvas"></canvas>
      <div class="point-indicator" id="pointsInfo">
        Points: <span>0 / 4</span>
      </div>
    </div>

    <div class="panel">
      <h2>2. Corrected Wall View</h2>
      <div class="hint">
        Once 4 points are selected and OpenCV is ready, the wall will be perspective-corrected here.
      </div>
      <canvas id="correctedCanvas"></canvas>
    </div>
  </section>

  <script>
    // --- State ---
    let videoStream = null;
    let cvReady = false;
    let originalCanvas = null;
    let correctedCanvas = null;
    let origCtx = null;
    let cardPoints = []; // [{x, y}, ...]

    // OpenCV runtime ready flag
    window.cv = window.cv || {};
    cv['onRuntimeInitialized'] = () => {
      cvReady = true;
      const status = document.getElementById('statusText');
      status.innerHTML = "<strong>OpenCV loaded.</strong> You can capture a frame and start marking card corners.";
    };

    // DOM references
    const startCameraBtn = document.getElementById('startCameraBtn');
    const captureBtn = document.getElementById('captureBtn');
    const resetPointsBtn = document.getElementById('resetPointsBtn');
    const statusText = document.getElementById('statusText');
    const pointsInfo = document.getElementById('pointsInfo');
    const video = document.getElementById('video');

    // Setup canvases once DOM loaded
    window.addEventListener('load', () => {
      originalCanvas = document.getElementById('originalCanvas');
      correctedCanvas = document.getElementById('correctedCanvas');
      origCtx = originalCanvas.getContext('2d');

      originalCanvas.addEventListener('click', handleCanvasClick);
      updatePointsInfo();
    });

    async function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusText.innerHTML = "Camera access not supported in this browser.";
        return;
      }

      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" }
          },
          audio: false
        });

        video.srcObject = videoStream;
        captureBtn.disabled = false;
        statusText.innerHTML = "<strong>Camera running.</strong> Position the wall and card, then tap <strong>Capture Frame</strong>.";
      } catch (err) {
        console.error(err);
        statusText.innerHTML = "Unable to access camera: " + err.message;
      }
    }

    function stopCamera() {
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
    }

    function captureFrame() {
      if (!video.videoWidth || !video.videoHeight) {
        statusText.innerHTML = "Video not ready yet. Wait a moment, then try capturing again.";
        return;
      }

      const width = video.videoWidth;
      const height = video.videoHeight;

      originalCanvas.width = width;
      originalCanvas.height = height;
      correctedCanvas.width = width;
      correctedCanvas.height = height;

      origCtx.drawImage(video, 0, 0, width, height);

      // Freeze preview by stopping the camera stream
      stopCamera();
      video.srcObject = null;

      statusText.innerHTML = "<strong>Frame captured.</strong> Now click the 4 corners of your card in order: TL → TR → BR → BL.";
      resetCardPoints();
      resetPointsBtn.disabled = false;
    }

    function resetCardPoints() {
      cardPoints = [];
      redrawOriginalWithMarkers();
      updatePointsInfo();
    }

    function updatePointsInfo() {
      const span = pointsInfo.querySelector('span');
      span.textContent = cardPoints.length + " / 4";
    }

    function handleCanvasClick(event) {
      if (!originalCanvas.width || !originalCanvas.height) {
        return; // no image yet
      }

      const rect = originalCanvas.getBoundingClientRect();
      const scaleX = originalCanvas.width / rect.width;
      const scaleY = originalCanvas.height / rect.height;

      const x = (event.clientX - rect.left) * scaleX;
      const y = (event.clientY - rect.top) * scaleY;

      if (cardPoints.length >= 4) {
        // Ignore extra clicks; user can reset
        return;
      }

      cardPoints.push({ x, y });
      redrawOriginalWithMarkers();
      updatePointsInfo();

      if (cardPoints.length === 4) {
        if (!cvReady) {
          statusText.innerHTML = "You’ve selected 4 points, but OpenCV is still loading. Wait a moment, then click again or reset.";
          return;
        }
        statusText.innerHTML = "<strong>4 points selected.</strong> Computing perspective correction…";
        setTimeout(applyPerspectiveCorrection, 0);
      }
    }

    function redrawOriginalWithMarkers() {
      if (!origCtx || !originalCanvas.width) return;

      // Redraw the underlying frame
      const frame = video.srcObject ? video : originalCanvas;
      // If camera stopped, we already have the frame in the canvas, so just clear & redraw from itself
      const temp = origCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
      origCtx.putImageData(temp, 0, 0);

      // Draw point markers and lines
      origCtx.lineWidth = 3;
      origCtx.strokeStyle = '#22c55e';
      origCtx.fillStyle = '#22c55e';
      origCtx.font = '20px system-ui';

      if (cardPoints.length > 1) {
        origCtx.beginPath();
        origCtx.moveTo(cardPoints[0].x, cardPoints[0].y);
        for (let i = 1; i < cardPoints.length; i++) {
          origCtx.lineTo(cardPoints[i].x, cardPoints[i].y);
        }
        // If we have all 4, close the path
        if (cardPoints.length === 4) {
          origCtx.closePath();
        }
        origCtx.stroke();
      }

      cardPoints.forEach((p, index) => {
        origCtx.beginPath();
        origCtx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
        origCtx.fill();
        // Number label
        origCtx.fillText(String(index + 1), p.x + 10, p.y - 10);
      });
    }

    function applyPerspectiveCorrection() {
      if (cardPoints.length !== 4) {
        return;
      }
      if (!cvReady) {
        statusText.innerHTML = "OpenCV is not ready yet. Please wait a moment and try again.";
        return;
      }

      try {
        const width = originalCanvas.width;
        const height = originalCanvas.height;

        // Create OpenCV images
        let src = cv.imread(originalCanvas);

        // Source points: user-clicked card corners, in the order:
        // TL, TR, BR, BL (as instructed)
        const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
          cardPoints[0].x, cardPoints[0].y,
          cardPoints[1].x, cardPoints[1].y,
          cardPoints[2].x, cardPoints[2].y,
          cardPoints[3].x, cardPoints[3].y
        ]);

        // Destination points: we map the card to a nice, axis-aligned rectangle.
        // We keep the full image size, but we define how the card should look within it.
        // For simplicity, we map the card onto a rectangle centered in the output.
        const cardWidthPx = Math.floor(width * 0.25);  // 25% of image width
        const cardHeightPx = Math.floor(cardWidthPx * 0.63); // approx 85x54mm ratio

        const offsetX = Math.floor((width - cardWidthPx) / 2);
        const offsetY = Math.floor((height - cardHeightPx) / 2);

        const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
          offsetX, offsetY,
          offsetX + cardWidthPx, offsetY,
          offsetX + cardWidthPx, offsetY + cardHeightPx,
          offsetX, offsetY + cardHeightPx
        ]);

        const M = cv.getPerspectiveTransform(srcPts, dstPts);
        let dst = new cv.Mat();
        const size = new cv.Size(width, height);

        cv.warpPerspective(src, dst, M, size, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

        cv.imshow('correctedCanvas', dst);

        src.delete();
        dst.delete();
        srcPts.delete();
        dstPts.delete();
        M.delete();

        statusText.innerHTML = "<strong>Perspective corrected.</strong> The wall is now flattened in the right-hand view.";
      } catch (err) {
        console.error(err);
        statusText.innerHTML = "Error during perspective correction: " + err.message;
      }
    }

    // Hook up buttons
    startCameraBtn.addEventListener('click', startCamera);
    captureBtn.addEventListener('click', captureFrame);
    resetPointsBtn.addEventListener('click', () => {
      resetCardPoints();
      statusText.innerHTML = "Card points reset. Click the 4 corners again (TL → TR → BR → BL).";
    });

    // Clean up on unload
    window.addEventListener('beforeunload', stopCamera);
  </script>
</body>
</html>
