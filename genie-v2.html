<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie V2</title>
    
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="onCvLoaded()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root { --primary: #667eea; --accent: #764ba2; --text: #2d3748; }
        body { margin: 0; overflow: hidden; font-family: -apple-system, system-ui, sans-serif; background: #000; }
        
        /* UI Overlays */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        .interactive { pointer-events: auto; }
        
        /* Cards & Menus */
        .card { background: white; border-radius: 16px; padding: 20px; margin: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); pointer-events: auto; max-width: 400px; align-self: center; }
        .hidden { display: none !important; }
        
        h1 { margin: 0 0 10px 0; color: var(--primary); font-size: 1.5rem; }
        p { color: #718096; font-size: 0.9rem; margin-bottom: 15px; }
        
        /* Controls */
        .btn { background: linear-gradient(135deg, var(--primary), var(--accent)); color: white; border: none; padding: 12px 20px; border-radius: 8px; font-weight: 600; width: 100%; font-size: 1rem; cursor: pointer; transition: transform 0.1s; }
        .btn:active { transform: scale(0.98); }
        .btn-secondary { background: #cbd5e0; color: var(--text); }
        
        select { width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; font-size: 1rem; }
        
        /* Status Badge */
        .badge { background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.85rem; font-weight: 600; align-self: center; margin-top: 20px; backdrop-filter: blur(4px); }
        .badge.active { background: #48bb78; }
        .badge.searching { background: #ecc94b; color: #000; }
        
        /* Canvases */
        #camera-feed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #ar-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
        #touch-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; touch-action: none; }
    </style>
</head>
<body>

    <video id="camera-feed" autoplay playsinline muted></video>
    <canvas id="ar-canvas"></canvas>
    <div id="touch-layer"></div>

    <div id="ui-layer">
        
        <div id="status-badge" class="badge hidden">Initializing...</div>

        <div id="menu-screen" class="card">
            <h1>üî• Clearance Genie</h1>
            <p>To ensure accuracy, please select the exact size of your printed ArUco marker.</p>
            
            <label><strong>Equipment Type</strong></label>
            <select id="equip-type">
                <option value="boiler">Boiler (400x700mm)</option>
                <option value="flue">Flue Terminal</option>
                <option value="radiator">Radiator</option>
            </select>

            <label><strong>Marker Size</strong></label>
            <select id="marker-size">
                <option value="53">Credit Card (53mm)</option>
                <option value="100">100mm Standard</option>
                <option value="148">A5 Paper (148mm)</option>
                <option value="210">A4 Paper (210mm)</option>
            </select>

            <button class="btn" onclick="App.start()">Start Calibration üì∑</button>
        </div>

        <div id="live-controls" class="card hidden" style="margin-bottom: 40px;">
            <p style="margin:0; text-align:center;">
                üëá <strong>Drag</strong> object to position.<br>
                üö∂ <strong>Walk back</strong> to frame the wall.
            </p>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="btn btn-secondary" onclick="App.resetPosition()">Reset</button>
                <button class="btn" onclick="App.lockAndAnalyze()">üîí Lock & Check</button>
            </div>
        </div>

        <div id="result-controls" class="card hidden">
            <h1>‚úÖ Clearance Check</h1>
            <p>Zones: Green (>300mm), Amber (75-300mm), Red (<75mm).</p>
            <button class="btn" onclick="location.reload()">New Scan</button>
        </div>

    </div>

    <script>
        // ==========================================
        // ROBUST APP LOGIC (v2.1)
        // ==========================================
        const App = {
            state: 'MENU',
            config: { markerSize: 53, width: 400, height: 700, depth: 300 },
            cvReady: false,
            
            // Vision & AR
            stream: null,
            scene: null,
            camera: null,
            renderer: null,
            markerGroup: null, 
            objectMesh: null,
            zoneMesh: null,
            
            // Stabilizer Data
            lastValidPosition: new THREE.Vector3(0, 0, 0),
            hasLock: false,
            missedFrames: 0,
            
            init: function() {
                this.initThreeJS();
            },

            start: async function() {
                this.config.markerSize = parseInt(document.getElementById('marker-size').value);
                const type = document.getElementById('equip-type').value;
                
                if(type === 'boiler') { this.config.width = 400; this.config.height = 700; }
                if(type === 'flue') { this.config.width = 150; this.config.height = 150; this.config.depth = 100; }
                if(type === 'radiator') { this.config.width = 1000; this.config.height = 600; this.config.depth = 100; }
                
                // UI Cleanup
                document.getElementById('menu-screen').classList.add('hidden');
                document.getElementById('live-controls').classList.remove('hidden');
                document.getElementById('status-badge').classList.remove('hidden');

                const video = document.getElementById('camera-feed');
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } 
                    });
                    video.srcObject = this.stream;
                    video.play();
                    
                    this.state = 'LIVE';
                    this.updateObjectMesh();
                    requestAnimationFrame(this.loop.bind(this));
                } catch(e) {
                    alert("Camera Error: " + e.message);
                }
            },

            initThreeJS: function() {
                const canvas = document.getElementById('ar-canvas');
                this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.scene.add(this.camera);

                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(0, 1, 1);
                this.scene.add(ambient);
                this.scene.add(dir);

                this.markerGroup = new THREE.Group();
                this.scene.add(this.markerGroup);

                // Setup Touch Events
                this.setupTouchControls();
            },

            setupTouchControls: function() {
                const touchLayer = document.getElementById('touch-layer');
                let isDragging = false, startX, startY, objStartX, objStartY;

                const handleStart = (e) => {
                    if(this.state !== 'LIVE') return;
                    isDragging = true;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    startX = clientX; startY = clientY;
                    objStartX = this.objectMesh.position.x;
                    objStartY = this.objectMesh.position.y;
                };

                const handleMove = (e) => {
                    if(!isDragging || !this.hasLock) return;
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    // Simple scaling factor for movement
                    const scale = this.markerGroup.position.z / -1000; 
                    const dx = (clientX - startX) * scale * 2;
                    const dy = (clientY - startY) * scale * 2;

                    this.objectMesh.position.x = objStartX + dx;
                    this.objectMesh.position.y = objStartY - dy;
                };

                touchLayer.addEventListener('touchstart', handleStart, {passive: false});
                touchLayer.addEventListener('touchmove', handleMove, {passive: false});
                touchLayer.addEventListener('mousedown', handleStart);
                touchLayer.addEventListener('mousemove', handleMove);
                window.addEventListener('touchend', () => isDragging = false);
                window.addEventListener('mouseup', () => isDragging = false);
            },

            updateObjectMesh: function() {
                if(this.objectMesh) this.markerGroup.remove(this.objectMesh);
                
                const geometry = new THREE.BoxGeometry(this.config.width, this.config.height, this.config.depth);
                const material = new THREE.MeshPhongMaterial({ color: 0x667eea, opacity: 0.85, transparent: true });
                this.objectMesh = new THREE.Mesh(geometry, material);
                this.objectMesh.position.z = this.config.depth / 2;
                
                // Zones Group
                this.zoneMesh = new THREE.Group();
                
                // Red Zone (Solid Box)
                const redGeo = new THREE.BoxGeometry(this.config.width + 150, this.config.height + 150, 10);
                const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.4, transparent: true });
                const redMesh = new THREE.Mesh(redGeo, redMat);
                redMesh.visible = false;
                this.zoneMesh.add(redMesh);
                
                // Green Zone (Wireframe)
                const greenGeo = new THREE.BoxGeometry(this.config.width + 600, this.config.height + 600, 10);
                const greenEdges = new THREE.EdgesGeometry(greenGeo);
                const greenLine = new THREE.LineSegments(greenEdges, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                greenLine.visible = false;
                this.zoneMesh.add(greenLine);

                this.objectMesh.add(this.zoneMesh);
                this.markerGroup.add(this.objectMesh);
            },

            loop: function() {
                if(this.state !== 'LIVE') return;

                const video = document.getElementById('camera-feed');
                if (video.readyState === video.HAVE_ENOUGH_DATA && this.cvReady) {
                    
                    // Keep Canvas Sized Correctly
                    const displayWidth = window.innerWidth;
                    const displayHeight = window.innerHeight;
                    if(this.renderer.domElement.width !== displayWidth) {
                        this.renderer.setSize(displayWidth, displayHeight);
                        this.camera.aspect = displayWidth / displayHeight;
                        this.camera.updateProjectionMatrix();
                    }

                    // --- VISION PROCESSING ---
                    const pose = this.processFrame(video);

                    if(pose) {
                        // Update Smoothing
                        this.hasLock = true;
                        this.missedFrames = 0;
                        
                        // Simple Low-Pass Filter (Smoothing)
                        const smoothFactor = 0.2; // Lower = smoother but laggier
                        this.markerGroup.position.lerp(pose.position, smoothFactor);
                        
                        // Only update depth if it changes significantly (prevents Z-fighting)
                        if(Math.abs(this.markerGroup.position.z - pose.position.z) > 10) {
                             this.markerGroup.position.z = this.markerGroup.position.z * (1-smoothFactor) + pose.position.z * smoothFactor;
                        }

                        document.getElementById('status-badge').textContent = "‚úì Tracking Active";
                        document.getElementById('status-badge').className = "badge active";
                    } else {
                        this.missedFrames++;
                        if(this.missedFrames > 30) { // Lost for 1 second
                            this.hasLock = false;
                            document.getElementById('status-badge').textContent = "üîç Find Marker...";
                            document.getElementById('status-badge').className = "badge searching";
                        }
                    }

                    this.renderer.render(this.scene, this.camera);
                }
                requestAnimationFrame(this.loop.bind(this));
            },

            processFrame: function(video) {
                // DOWNSIZING FOR PERFORMANCE (Crucial for mobile)
                // We process at a smaller resolution than we display
                const processScale = 0.5; 
                const w = video.videoWidth * processScale;
                const h = video.videoHeight * processScale;

                if(!this.srcMat) {
                    // Initialize mats once
                    this.srcMat = new cv.Mat(h, w, cv.CV_8UC4);
                    this.grayMat = new cv.Mat();
                    this.binaryMat = new cv.Mat();
                    this.contours = new cv.MatVector();
                    this.hierarchy = new cv.Mat();
                    this.cap = new cv.VideoCapture(video);
                }

                // Draw video to mat (resizing automatically via canvas context if needed, 
                // but for raw opencv performance we create a temp canvas)
                if(!this.tempCanvas) {
                    this.tempCanvas = document.createElement('canvas');
                    this.tempCanvas.width = w;
                    this.tempCanvas.height = h;
                    this.tempCtx = this.tempCanvas.getContext('2d', {willReadFrequently: true});
                }
                
                this.tempCtx.drawImage(video, 0, 0, w, h);
                const imgData = this.tempCtx.getImageData(0, 0, w, h);
                this.srcMat.data.set(imgData.data);

                cv.cvtColor(this.srcMat, this.grayMat, cv.COLOR_RGBA2GRAY);
                
                // Adaptive Threshold handles lighting better
                cv.adaptiveThreshold(this.grayMat, this.binaryMat, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 2);

                cv.findContours(this.binaryMat, this.contours, this.hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                let bestPose = null;
                let maxArea = 0;

                for (let i = 0; i < this.contours.size(); ++i) {
                    let cnt = this.contours.get(i);
                    let area = cv.contourArea(cnt);

                    // Filter 1: Size (Must be big enough to be close, small enough to fit)
                    if (area > 1000 && area < (w*h)*0.8) {
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.05 * peri, true);
                        
                        // Filter 2: Must be a Quadrilateral (4 corners) && Convex
                        if (approx.rows === 4 && cv.isContourConvex(approx)) {
                            
                            // Filter 3: STRICT BORDER CHECK
                            // We check the "hole" inside. ArUco markers are a black box on white paper.
                            // Adaptive threshold makes the border black (0).
                            // If we sample the center of this quad in the binary image, it should be distinct.
                            // (Simplified for performance: We trust largest valid quad that maintains temporal coherence)
                            
                            if (area > maxArea) {
                                maxArea = area;
                                
                                // Extract corners
                                const corners = [];
                                for(let j=0; j<8; j+=2) {
                                    // Scale back up to full video coords
                                    corners.push({
                                        x: approx.data32S[j] / processScale, 
                                        y: approx.data32S[j+1] / processScale
                                    });
                                }
                                
                                // CALCULATE POSE
                                const pose = this.calculatePose(corners, video.videoWidth, video.videoHeight);
                                
                                // Filter 4: ANTI-TELEPORT (Sanity Check)
                                // If we have a lock, and the new position is > 500mm away, ignore it (glitch)
                                if(this.hasLock) {
                                    const dist = pose.position.distanceTo(this.lastValidPosition);
                                    if(dist < 500) { // Max 500mm (50cm) jump allowed per frame
                                        bestPose = pose;
                                        this.lastValidPosition.copy(pose.position);
                                    }
                                } else {
                                    bestPose = pose;
                                    this.lastValidPosition.copy(pose.position);
                                }
                            }
                        }
                        approx.delete();
                    }
                    cnt.delete(); // Clean up contour to prevent memory leak
                }

                return bestPose;
            },

            calculatePose: function(corners, vidW, vidH) {
                // Apparent Width (pixels)
                const w1 = Math.hypot(corners[0].x - corners[1].x, corners[0].y - corners[1].y);
                const w2 = Math.hypot(corners[3].x - corners[2].x, corners[3].y - corners[2].y);
                const avgPx = (w1 + w2) / 2;

                if(avgPx < 1) return null;

                // Z Calculation
                const vFov = this.camera.fov * Math.PI / 180;
                const focalLen = (vidH / 2) / Math.tan(vFov / 2);
                const z = -(this.config.markerSize * focalLen) / avgPx;

                // XY Calculation
                const centerX = (corners[0].x + corners[2].x) / 2;
                const centerY = (corners[0].y + corners[2].y) / 2;
                
                // Map to 3D coords (Flip X for mirror effect correction if needed, Flip Y for WebGL coords)
                const x = (centerX - vidW/2) * (Math.abs(z) / focalLen); 
                const y = (centerY - vidH/2) * (Math.abs(z) / focalLen) * -1; // -1 because screen Y is down

                return {
                    position: new THREE.Vector3(x, y, z)
                };
            },

            resetPosition: function() {
                if(this.objectMesh) {
                    this.objectMesh.position.set(0, 0, this.config.depth/2);
                }
            },

            lockAndAnalyze: function() {
                this.state = 'RESULT';
                if(this.zoneMesh) this.zoneMesh.children.forEach(c => c.visible = true);
                this.objectMesh.material.opacity = 1.0;
                document.getElementById('camera-feed').pause();
                document.getElementById('live-controls').classList.add('hidden');
                document.getElementById('result-controls').classList.remove('hidden');
                document.getElementById('status-badge').classList.add('hidden');
                this.renderer.render(this.scene, this.camera);
            }
        };

        function onCvLoaded() {
            App.cvReady = true;
            App.init();
        }
    </script>
</body>
</html>
